[["1", "Refactoring conventions", "Ben Christensen", "benjchristensen", "01/10/13, 09:33:34 PM", "NaN", "NaN"], ["2", "Language adaptors", "Ben Christensen", "benjchristensen", "01/11/13, 12:26:34 AM", "Includes Groovy and JRuby", "NaN"], ["3", "Clojure adaptor", "Ben Christensen", "benjchristensen", "01/11/13, 07:08:36 PM", "NaN", "NaN"], ["4", "remove 'wrap' functionality", "Ben Christensen", "benjchristensen", "01/12/13, 07:22:01 PM", "We no longer need this as we've merged the interface and abstract classes together and don't need to ensure we have the abstract class.", "NaN"], ["5", "Support multiple class types for language adaptors", "Ben Christensen", "benjchristensen", "01/15/13, 09:47:27 PM", "NaN", "NaN"], ["6", "Refactoring", "Ben Christensen", "benjchristensen", "01/16/13, 08:34:20 PM", "- convert to rx.\\* package names\n  - rx.observables\n  - rx.observables.operations (private package from javadocs)\n  - rx.util\n  - rx.lang\n  - rx.concurrency (placeholder for schedulers)\n- change Func order to have return type at end => T, R instead of R, T\n  - this matches the C# and Guava conventions\n- added Action as Func without return value\n  - added overload subscribe methods with Action typed arguments\n- added from() alias methods in Observable", "NaN"], ["27", "Scala adaptor", "Jason Cacciatore", "jcacciatore", "01/17/13, 01:12:16 AM", "NaN", "NaN"], ["105", "Performance optimizations.", "Ben Christensen", "benjchristensen", "01/22/13, 03:07:30 AM", "- memoize dynamic function constructions so executions are statically typed after a single dynamic lookup instead of dynamic on every execution\n- use chained observable to reduce composition costs (execute list of functions rather than compositionally invoking onNext)", "NaN"], ["106", "Performance optimizations for dynamic function execution.", "Ben Christensen", "benjchristensen", "01/22/13, 03:12:38 AM", "- memoize dynamic function constructions so executions are statically typed after a single dynamic lookup instead of dynamic on every execution\n\nhttps://github.com/Netflix/RxJava/issues/104", "NaN"], ["107", "Performance: Reduce synchronization", "Ben Christensen", "benjchristensen", "01/22/13, 11:49:16 PM", "Performance changes as part of https://github.com/Netflix/RxJava/issues/104 and is an extension of work done in pull https://github.com/Netflix/RxJava/pull/106.\n\nThis code was used to test the performance:\n\n``` java\n    public void runCompositionTest(Integer[] values) {\n        System.out.println(\"runCompositionTest\");\n\n        final AtomicInteger onNextSum = new AtomicInteger(0);\n        final long start = System.nanoTime();\n\n        MathFunction m = new MathFunction();\n        // 50 levels of composition (same function so that's not the cost)\n        Observable.from(values)\n                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)\n                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)\n                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)\n                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)\n                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)\n                .subscribe(new TestObserver(onNextSum, start));\n    }\n```\n\nBefore it took:\n\n```\nSum: 710082754 Time: 60.605ms\n```\n\nBy reducing the nested synchronization (eliminating most of it) it is now running at:\n\n```\nSum: 710082754 Time: 22.429ms\n```", "NaN"], ["108", "Adding a draft of Subject class", "George Campbell", "abersnaze", "01/31/13, 06:09:16 PM", "https://github.com/Netflix/RxJava/issues/19", "NaN"], ["109", "Creating toObservable for Future", "George Campbell", "abersnaze", "01/31/13, 06:08:37 PM", "simple wrapper that turns a future into a observable.", "NaN"], ["110", "Build fix", "Ben Christensen", "benjchristensen", "01/25/13, 04:22:34 AM", "Getting RxJava to build all of the LanguageAdaptor sub modules correctly.\n\nUpgraded to Gradle 1.3 and made changes to rxjava-scala build file.", "NaN"], ["111", "IDE Support", "Ben Christensen", "benjchristensen", "01/25/13, 04:50:53 AM", "NaN", "NaN"], ["112", "Examples Submodule", "Ben Christensen", "benjchristensen", "01/25/13, 06:24:16 AM", "new submodule for showing examples in various languages", "NaN"], ["113", "Concat", "Billy Yuen", "billyy", "01/31/13, 06:28:19 PM", "NaN", "NaN"], ["114", "Examples", "Ben Christensen", "benjchristensen", "01/29/13, 09:47:20 PM", "Start of \"How to Use\" examples in Clojure, Groovy and Java.", "NaN"], ["115", "more examples", "Ben Christensen", "benjchristensen", "01/31/13, 06:35:14 PM", "NaN", "NaN"], ["116", "Refactor", "Ben Christensen", "benjchristensen", "01/31/13, 09:27:04 PM", "NaN", "NaN"], ["117", "Aligning with internal infrastructure.", "Justin Ryan", "quidryan", "02/04/13, 05:32:04 PM", "NaN", "NaN"], ["120", "Fixing javadocs", "Ben Christensen", "benjchristensen", "02/05/13, 09:48:36 PM", "https://github.com/Netflix/RxJava/issues/119\n- added correct links to external images\n- cleaned up some of the text\n- improved some function memoization that was missed", "NaN"], ["121", "Minor cleanup of Clojure example.", "Dave Ray", "daveray", "02/06/13, 05:02:18 AM", "Cleaned up some formatting and spacing. Used future-cancel. Future\nsubscriptions were not being returned properly. Replaced use of #_ with\ncomment form. Fixed rest args usage for hello example.", "NaN"], ["122", "Examples Cleanup", "Ben Christensen", "benjchristensen", "02/06/13, 07:09:16 AM", "Some cleanup on builds, particularly rxjava-examples.\n\nI can't add Scala support while retaining Groovy and have it work in Eclipse as the plugins collide. Gradle handles it fine for builds from command-line but editing via text editors and not IDEs is not ideal.\n\nPerhaps the examples should go in the /src/test/ folder (or /src/examples/) of each of the rxjava-[language] projects instead of rxjava-examples?", "NaN"], ["124", "trivial syntax clean-up in scala adaptor", "Jason Cacciatore", "jcacciatore", "02/06/13, 11:15:17 PM", "NaN", "NaN"], ["125", "Implemented: TakeWhile", "Mairbek Khadikov", "mairbek", "02/14/13, 09:40:03 PM", "NaN", "NaN"], ["127", "Update README", "Matthew Michihara", "matthewmichihara", "02/07/13, 05:37:12 PM", "NaN", "NaN"], ["129", "Code cleanup", "Mairbek Khadikov", "mairbek", "02/07/13, 05:37:41 PM", "Cleaned up some warnings highlighted by Intellij Idea", "NaN"], ["131", "Implemented: ForEach", null, "dcapwell", "02/15/13, 09:28:40 PM", "implement #45.", "NaN"], ["132", "Refactoring language tests and examples layout", "Ben Christensen", "benjchristensen", "02/08/13, 07:21:41 AM", "- removed rxjava-examples as it was not working having all languages in the same project\n- started convention of having /src/examples/ in language-adaptors with first implementation being rxjava-groovy and rxjava-clojure (though the clojure one isn't compiling correctly yet)\n- moved language unit tests to actual language rather than via Java to language parsers", "NaN"], ["133", "Various fixes", "Ben Christensen", "benjchristensen", "02/08/13, 07:59:33 AM", "- restore performance optimization to reduce wrapping \n- restoring null check removed in recent commit ", "NaN"], ["134", "Adapt Groovy VideoExample to Clojure", "Dave Ray", "daveray", "02/09/13, 06:59:43 AM", "Seems to work.", "NaN"], ["135", "Idiomatic usage of import in ns macro in rx-examples.", "Daniel De Aguiar", "ddeaguiar", "02/09/13, 08:43:05 PM", "Reference: [clojure.core docs](http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/ns). \n\nThanks!", "NaN"], ["136", "Add examples for jbundler and sbt", null, "unrelentingtech", "02/11/13, 05:14:55 PM", "NaN", "NaN"], ["137", "Implemented range operator. Fixes issue #68", "Mairbek Khadikov", "mairbek", "02/11/13, 05:14:16 PM", "NaN", "NaN"], ["138", "Implemented SequenceEqual Operator", "Mairbek Khadikov", "mairbek", "02/12/13, 11:25:00 PM", "Fixes issue #76\n\nSince there is no direct analogue of `IEqualityComparer` in Java, `Func2<T, T, Boolean>` has been used.", "NaN"], ["140", "Implemented TakeLast operator", "Mairbek Khadikov", "mairbek", "02/12/13, 11:34:45 PM", "Fixes issue #85.", "NaN"], ["142", "RxJava ErrorHandler Plugin", "Ben Christensen", "benjchristensen", "02/13/13, 12:10:21 AM", "https://github.com/Netflix/RxJava/issues/141 Error Handler Plugin\nhttps://github.com/Netflix/RxJava/issues/139 Plugin System", "NaN"], ["144", "Used mockito's inOrder to verify ordering instead of hand-written stub", "Mairbek Khadikov", "mairbek", "02/14/13, 05:19:17 PM", "NaN", "NaN"], ["145", "Support 'provided' dependencies in IntelliJ Idea build", "Ben Christensen", "benjchristensen", "02/14/13, 08:25:09 PM", "This adds support to the Gradle builds for IntelliJ to import the project and have classpaths set correctly. \n\nGradle documentation for these changes: http://www.gradle.org/docs/current/dsl/org.gradle.plugins.ide.idea.model.IdeaModule.html", "NaN"], ["146", "Merge of Pull #125 for Issue #87 Operator TakeWhile", "Ben Christensen", "benjchristensen", "02/14/13, 09:41:16 PM", "Manually merging https://github.com/Netflix/RxJava/pull/125 from @mairbek ", "NaN"], ["147", "Operator: forEach", "Ben Christensen", "benjchristensen", "02/15/13, 09:27:54 PM", "Issue https://github.com/Netflix/RxJava/issues/45\n\nRelated to Pull https://github.com/Netflix/RxJava/pull/131", "NaN"], ["149", "Single/SingleOrDefault Operator Implemented", "Mairbek Khadikov", "mairbek", "02/19/13, 09:19:40 PM", "Fix for issue #77", "NaN"], ["150", "Cleaned up copy-paste in OperationMerge code", "Mairbek Khadikov", "mairbek", "02/19/13, 06:24:47 PM", "NaN", "NaN"], ["151", "Implemented TakeUntil operation", "Mairbek Khadikov", "mairbek", "03/11/13, 08:38:30 PM", "Fixes issue #86", "NaN"], ["152", "Implemented Next Operation", "Mairbek Khadikov", "mairbek", "02/27/13, 08:34:24 PM", "Fixes issue #66", "NaN"], ["155", "Change target compatibility from 1.5 to 1.6", "Ben Christensen", "benjchristensen", "02/27/13, 05:30:01 AM", "https://github.com/Netflix/RxJava/issues/153", "NaN"], ["156", "Implemented ToIterable Operation", "Mairbek Khadikov", "mairbek", "02/27/13, 08:29:46 PM", "For issue #18.\n\nThis would allow to implement other blocking methods like `single`, `lastOrDefault` next.", "NaN"], ["157", "Implemented single and singleOrDefault", "Mairbek Khadikov", "mairbek", "02/28/13, 08:33:37 PM", "For issue #77.", "NaN"], ["158", "Travis CI Configuration", "Mairbek Khadikov", "mairbek", "02/28/13, 09:50:51 PM", "The project would benefit by having Continuous Integration configured.\n\nI've configured travis-ci for my fork, it could be found at https://travis-ci.org/mairbek/RxJava", "NaN"], ["159", "Implemented LastOrDefault Operator", "Mairbek Khadikov", "mairbek", "02/28/13, 07:51:39 PM", "For issue #58", "NaN"], ["160", "Manual merge of mairbek/single Pull #157", "Ben Christensen", "benjchristensen", "02/28/13, 08:33:24 PM", "Merging https://github.com/Netflix/RxJava/pull/157 which had conflicts and needed a manual merge.", "NaN"], ["161", "Added build status badges", null, "garethbowles", "02/28/13, 08:38:09 PM", "I'm not wild about the icons that CloudBees provides, but it looks fairly straightforward to change them if needed.", "NaN"], ["162", "Test build of pull request", null, "garethbowles", "02/28/13, 09:38:48 PM", "NaN", "NaN"], ["163", "Implemented Next Operation", "Mairbek Khadikov", "mairbek", "03/02/13, 07:44:03 AM", "New implementation of #66.", "NaN"], ["165", "Fixed bug in ranges", "Mairbek Khadikov", "mairbek", "03/01/13, 08:00:15 PM", "Fixed issue #164.", "NaN"], ["166", "Review of Next Operation", "Ben Christensen", "benjchristensen", "03/02/13, 09:51:11 PM", "Some changes I made while reviewing https://github.com/Netflix/RxJava/pull/163", "NaN"], ["167", "Reimplemented Last operation", "Mairbek Khadikov", "mairbek", "03/12/13, 04:24:41 AM", "For issue #57.", "NaN"], ["168", "Implemented Most Recent", "Mairbek Khadikov", "mairbek", "03/11/13, 11:14:41 PM", "For issue #64.", "NaN"], ["169", "Implemented GetIterator", "Mairbek Khadikov", "mairbek", "03/11/13, 09:30:00 PM", "For issue #50.", "NaN"], ["171", "Implemented Defer Operation", "Mairbek Khadikov", "mairbek", "03/11/13, 09:36:46 PM", "For issue #35.", "NaN"], ["174", "Dematerialize", "Prabir Shrestha", "prabirshrestha", "03/11/13, 09:14:39 PM", "PR for #37\n\nSomeone might want to help me with proper unit tests :)", "NaN"], ["176", "Implemented GroupBy", "Mairbek Khadikov", "mairbek", "03/12/13, 03:00:52 AM", "For issue #51.", "NaN"], ["177", "Operator: Dematerialize - review and manual merge", "Ben Christensen", "benjchristensen", "03/11/13, 09:15:10 PM", "Manual merge of pull request https://github.com/Netflix/RxJava/pull/174 for issue https://github.com/Netflix/RxJava/issues/37", "NaN"], ["178", "Review and Refactor of GetIterator", "Ben Christensen", "benjchristensen", "03/11/13, 09:30:09 PM", "Review of pull request https://github.com/Netflix/RxJava/pull/169 for issue https://github.com/Netflix/RxJava/issues/50 along with a simple refactoring to reduce code in Observable.java.", "NaN"], ["179", "Operator GroupBy Pull Request - Review and Refactor", "Ben Christensen", "benjchristensen", "03/12/13, 03:00:51 AM", "Refactored version of pull request https://github.com/Netflix/RxJava/pull/176 for issue https://github.com/Netflix/RxJava/issues/51\n\nI would like to avoid delegation if possible since it will mean it needs to be kept in sync with Observable.\n\nThis refactored approach allows inheritance without delegation by composing the Observable  inside another operator function. ", "NaN"], ["180", "Formatting and cleanup", "Ben Christensen", "benjchristensen", "03/12/13, 03:20:44 AM", "NaN", "NaN"], ["181", "Add OSGi manifest headers", "Ben Christensen", "benjchristensen", "03/12/13, 03:58:33 AM", "https://github.com/Netflix/RxJava/issues/154\n\nI can't confirm that these work but submitting based on discussion on issue #154.", "NaN"], ["182", "Subscriptions utility class and rx.subscriptions package", "Ben Christensen", "benjchristensen", "03/12/13, 03:59:18 AM", "https://github.com/Netflix/RxJava/issues/173", "NaN"], ["183", "Groovy VideoExample improvements", "Ben Christensen", "benjchristensen", "03/12/13, 04:10:34 AM", "- Make VideoExample more idiomatic for Groovy based on feedback\n- Use the new BooleanSubscription object", "NaN"], ["184", "Convert 'last' from non-blocking to blocking to match Rx.Net", "Ben Christensen", "benjchristensen", "03/12/13, 04:24:40 AM", "Merging pull request https://github.com/Netflix/RxJava/pull/167 which needed manual merging.\n\nDid some other cleanup while in there and added a missing generic 'Object' override.\n\nThank you @mairbek for doing this work.", "NaN"], ["185", "toIterable() consistent wrapping of errors", "John Gardiner Myers", "johngmyers", "03/28/13, 05:57:59 PM", "toIterable() now wraps errors reported through the Observable in a (newly created) ObservedException. This allows a catch block to handle only the exceptions that came through the Observable, not catching exceptions thrown by RxJava itself.", "NaN"], ["186", "Add 'Fragment-Host' to submodules for OSGi", "Ben Christensen", "benjchristensen", "03/12/13, 08:26:54 PM", "Based on discussion on issue https://github.com/Netflix/RxJava/issues/154", "NaN"], ["187", "Confusing Javadoc for `toObservable(Future)` methods", "Ben Christensen", "benjchristensen", "03/12/13, 08:55:39 PM", "https://github.com/Netflix/RxJava/issues/148", "NaN"], ["188", "Subscriptions cleanup", "Ben Christensen", "benjchristensen", "03/12/13, 09:58:36 PM", "Some things I missed in previous commit and am cleaning up related to https://github.com/Netflix/RxJava/issues/173", "NaN"], ["189", "Handful of Improvements", "Ben Christensen", "benjchristensen", "03/13/13, 05:36:45 AM", "Some improvements made while reviewing code.\n- add error handling to VideoExample.groovy so it's a better representation of how onError is used\n- handle errors from Func1 failures when subscribe happens\n- handle null Subscriptions on 'trusted' functions, not just untrusted", "NaN"], ["190", "update dematerialize so can chain correctly", "Prabir Shrestha", "prabirshrestha", "03/13/13, 08:55:14 PM", "Just noticed this when I actually had to chain it.\n\n``` java\nObservable<File> saveResult = ....;\n```\n\ncurrent:\n\n``` java\nObservable<Notification<File>> a = saveResult.materialize().dematerialize();\n```\n\nexpected:\n\n``` java\nObservable<File> a = saveResult.materialize().dematerialize();\n```\n\nhere is what is happening\n\n``` java\nObservable<File> x = saveResult;\nObservable<Notification<File>> y = x.materialize();\nObservable<Notification<File>> currentResult = y.dematerialize();\nObservable<File> expectedResult = Observable.dematerialize(y);\n```\n\nworkaround is to use static method to get the expected result.\n\nWith this change you can chain correctly. Added unit test.\n\n``` java\nObservable<Integer> obs = Observable.just(1);\nObservable<Integer> chained = obs.materialize().dematerialize();\n```\n\nThis will be a breaking change. But I think this is the expected way.", "NaN"], ["191", "Where alias to filter", "Prabir Shrestha", "prabirshrestha", "03/15/13, 05:01:32 PM", "PR for #101", "NaN"], ["194", "Add pointer regarding unit tests as inner classes", "Steffen Opel", "sopel", "03/15/13, 02:14:30 AM", "@benjchristensen - If I hadn't stumbled over your respective [pointer](https://github.com/Netflix/RxJava/issues/154#issuecomment-14544894) by chance, I would have asked the same question as Matt Bishop when encountering this README.\n\nYour reasoning for embedding unit tests as inner classes is inspiring (thanks much) and a helpful explanation for those who disagree regardless, so I suggest to promote it accordingly.", "NaN"], ["196", "New operation Finally (issue #43)", "Adam Bliss", "abliss", "04/03/13, 06:40:48 PM", "Hi,\n\nI was looking around for some fun stuff to do for the Netflix Cloud Prize, and I figured I might start by contributing some enhancements to RxJava.\n\nI did my best to match your existing style and practices, but I've doubtless made some mistakes.  If you have time to take a quick look and give me some feedback, I'll accept it gratefully. \n\nCheers,\n--abliss", "NaN"], ["197", "TakeWhile observables do not properly complete", "Gijs Stuurman", "thegeez", "03/26/13, 08:08:43 PM", "See failing test case for an example.\n\nThis slipped through the tests because Observable.toObservable uses\nSubscription.EMPTY, which means the onCompleted call after all three items\nare produced calls the onComplete on the takeWhile observable, which already requested to be unsubscribed. The\nundesired behaviour is shown with Observables that use subscriptions\n(such as Subject) or inifinite Observables (which is how I ran into\nthis bug). \n\nSimilar bugs might exist elsewhere for other operations, because most\ntests use Observable.toObservable rather than an Observable that uses\nsubscriptions.\n\nThe fix follows Rx.Net", "NaN"], ["199", "SubscribeOn/ObserveOn Implementation", "Mairbek Khadikov", "mairbek", "04/05/13, 04:34:55 AM", "Implementation SubscribeOn #11 and ObserveOn #12 alongside with basic Schedulers implementation #19.", "NaN"], ["201", "Synchronize Observer on OperationMerge", "Ben Christensen", "benjchristensen", "04/02/13, 05:56:16 AM", "fix for Merge serialization bug reported in https://github.com/Netflix/RxJava/issues/200\n\nThis is necessary because by definition Merge is subscribing to multiple sequences in parallel and is supposed to serialize them into a single Observable.", "NaN"], ["203", "All Operation Implemented", "Mairbek Khadikov", "mairbek", "03/26/13, 08:12:09 PM", "Closes issue #21.", "NaN"], ["205", "Reimplementation of Concat, improved handling of Observable<Observable<T...", "Adam Bliss", "abliss", "04/18/13, 05:47:51 PM", "...>>.\n\nThe old version required all of the Observable<T>s to be generated and buffered\nbefore the concat could begin.  If the outer Observable was asynchronous, items\ncould be dropped (test added).  The new version passes the test, and does the\nbest job I could (after examining several possible strategies) of achieving\nclear and consistent semantics in accordance with the principle of least\nsurprise.\n\n(My attempt to fix issue #202)", "NaN"], ["206", "Observable.toList breaks with multiple subscribers", "Gijs Stuurman", "thegeez", "03/27/13, 04:48:52 AM", "``` clojure\n(let [i1 (Subject/create)\n        out (Observable/toList i1)]\n    (.subscribe out (partial prn \"first observer\"))\n    (.subscribe out (partial prn \"second observer\"))\n    (.subscribe out (partial prn \"third observer\"))\n    (.onNext i1 1)\n    (.onNext i1 2)\n    (.onNext i1 3)\n    (.onNext i1 4)\n    (.onNext i1 5)\n    (.onNext i1 6)\n    (.onCompleted i1))\n```\n\nOutput: \n\n```\n\"first observer\" [1 1 1 2 2 2 3 3 3 4 4 4 5 5 5 6 6 6]\n\"second observer\" [1 1 1 2 2 2 3 3 3 4 4 4 5 5 5 6 6 6]\n\"third observer\" [1 1 1 2 2 2 3 3 3 4 4 4 5 5 5 6 6 6]\n```\n\nShould be:\n\n```\n\"first observer\" [1 2 3 4 5 6]\n\"second observer\" [1 2 3 4 5 6]\n\"third observer\" [1 2 3 4 5 6]\n```", "NaN"], ["207", "Implemented combineLatest semantics", "Joachim Hofer", "jmhofer", "03/27/13, 11:18:46 PM", "... at least if I understand them correctly...\n\nThis is an attempt at resolving #29", "NaN"], ["209", "Implement cache operator", "John Gardiner Myers", "johngmyers", "04/19/13, 03:53:28 AM", "Returns an Observable that repeats the original Observable sequence to all subscribers.\nThe source Observable is subscribed to at most once.\n\nWhen looking into integrating Hystrix and RxJava, the need for this operator became apparent. It appears to be of general use, so should be considered for RxJava core.", "NaN"], ["211", "Remove use of JSR 305 and dependency on com.google.code.findbugs", "Ben Christensen", "benjchristensen", "03/27/13, 11:31:20 PM", "fixes https://github.com/Netflix/RxJava/issues/192\n\nThe library and annotations were being used for trivial reasons so removing the usage so we don't have the dependency.", "NaN"], ["212", "Operation take leaks errors", "John Gardiner Myers", "johngmyers", "03/31/13, 02:54:19 AM", "The take() operator improperly propagates an error from its source after the count has been exhausted.\n\nTest cases exhibiting the bug attached.", "NaN"], ["213", "More formal support for Scala", "Matt Jacobs", "mattrjacobs", "05/20/13, 09:25:36 PM", "- This allows for type safety in statically-typed languages\n  - This prevents dynamically-typed languages from hooking into rxjava-core.\n    -- See #204 for details on code generation for dynamic languages\n  - Added Scala implicits into rx.lang.scala.RxImplicits\n  - Added tests of most methods on Observable using Scala functions\n  - Fixed Scala Gradle/ScalaTest build", "NaN"], ["214", "Merge of Pull #212 for Take/TakeWhile Fixes", "Ben Christensen", "benjchristensen", "03/31/13, 02:45:24 AM", "This is a manual merge of https://github.com/Netflix/RxJava/pull/212", "NaN"], ["215", "Manual Merge of Pull Request #212", "Ben Christensen", "benjchristensen", "03/31/13, 02:54:17 AM", "Manual merge of https://github.com/Netflix/RxJava/pull/212 with small reorganization of 1 file/package.", "NaN"], ["218", "Implement ReplaySubject with infinite history", "John Gardiner Myers", "johngmyers", "04/18/13, 08:21:49 PM", "NaN", "NaN"], ["220", "TakeWhile protect calls to predicate", "John Gardiner Myers", "johngmyers", "04/01/13, 05:18:57 PM", "Per RX guideline 6.4, calls to selector functions passed in to the operator should be caught and fed through to the subscribed observer. Operator TakeWhile doesn't do this with the passed in predicate.", "NaN"], ["221", "Error Handling Improvements - User Provided Observers/Functions", "Ben Christensen", "benjchristensen", "04/02/13, 05:30:04 AM", "Improve error handling as per discussion in issue https://github.com/Netflix/RxJava/issues/216\n\nThis is by no means exhaustive in the search for places needing this protection but gets the most obvious ones entering via `subscribe` and `forEach`.\n\nThe intention is to protect against exceptions being thrown and ensure onNext/onError/onCompleted contract compliance.", "NaN"], ["222", "Pull issue 43 merge", null, "joshgord", "04/03/13, 06:40:47 PM", "Manual merge of https://github.com/Netflix/RxJava/pull/196", "NaN"], ["223", "Concat merge", "Billy Yuen", "billyy", "04/18/13, 05:47:50 PM", "1. Update javadoc on subscribe() blocking if observables are running on the same thread.\n2. Add test case with infinity observable.\n3. Add test case to unsubscribe() with all observables running in different thread (non-blocking).", "NaN"], ["224", "RxJavaObservableExecutionHook", "Ben Christensen", "benjchristensen", "04/04/13, 10:23:01 PM", "Allow a plugin to intercept invocations of an Observable via its subscribe method.\n\nUse cases:\n- extra logging or metrics for start, return and error events when subscribing\n- decorate (or replace) an 'onSubscribe' function with additional behavior\n- decorate an Exception\n- decorate a Subscription\n\nThis is modeled after Hystrix Plugins: http://netflix.github.com/Hystrix/javadoc/index.html?com/netflix/hystrix/strategy/executionhook/HystrixCommandExecutionHook.html\n\nJavadocs will be at http://netflix.github.com/RxJava/javadoc/", "NaN"], ["225", "Schedulers (merge of pull #199)", "Ben Christensen", "benjchristensen", "04/05/13, 08:19:18 PM", "Manual merge of https://github.com/Netflix/RxJava/pull/199 by @mairbek plus the following changes:\n- made some classes non-public so they don't become part of the published API (if we find they have value in the public API we can make them so but once published it's hard to remove them so I'd rather keep them implementation details until then)\n- consolidated ExecutorScheduler and ScheduledExecutorScheduler\n- made ExecutorScheduler use a system-wide ScheduledExecutorScheduler for handling delayed events when only an Executor is available\n- made the IOThreadPool use a non-bounded cached thread-pool \n\nNext step from here is to review all operator implementations and add the Scheduler overloads.", "NaN"], ["226", "Merge overload - possibility B", "Ben Christensen", "benjchristensen", "04/16/13, 08:16:49 PM", "A possible implementation of scheduler overloads on the merge operator.\n\nRelated to Schedulers pulled in https://github.com/Netflix/RxJava/pull/225 and issue https://github.com/Netflix/RxJava/issues/19", "NaN"], ["227", "Merge overload - possibility A", "Ben Christensen", "benjchristensen", "04/16/13, 08:16:44 PM", "A possible implementation of scheduler overloads on the merge operator.\n\nRelated to Schedulers pulled in https://github.com/Netflix/RxJava/pull/225 and issue https://github.com/Netflix/RxJava/issues/19", "NaN"], ["228", "Interval", "Joachim Hofer", "jmhofer", "04/18/13, 07:11:04 PM", "I have attempted to implement the \"Interval\" operator (#55) here. As far as I can see, it seems to work. This is based on the quite fresh work on schedulers.\n\nIt doesn't work with the `currentThread` or `newThread` schedulers, I guess due to the simple `SleepingAction`. It does work with a `ScheduledExecutorService`, though.\n\nFor testing this conveniently, I also wrote a test scheduler with adjustable time.\n\nLooking forward to any review comments.", "NaN"], ["229", "Trying to extend the Scheduler interface according to the comments at", "Joachim Hofer", "jmhofer", "04/18/13, 04:11:16 PM", "I've tried to extend the `Scheduler` interface according to the discussion at issue #19. If I understand this correctly, most of it can be done via the `AbstractScheduler`.\n\nI hope this helps. Please have a look.", "NaN"], ["230", "An unsubscribed AtomicObservableSubscription.wrap() unsubscribes its argument", "John Gardiner Myers", "johngmyers", "04/16/13, 08:16:22 PM", "Fixes #210", "NaN"], ["231", "Multicast", "Mairbek Khadikov", "mairbek", "04/18/13, 07:08:55 PM", "Implemented Multicast operation, working on issue #65.", "NaN"], ["232", "Corrected naming", "Mairbek Khadikov", "mairbek", "04/16/13, 08:08:04 PM", "Renamed `Operator` to `Operation` to be consistent.", "NaN"], ["234", "ScheduledObserver Ordering", "Mairbek Khadikov", "mairbek", "04/18/13, 05:47:04 PM", "Fixing issue #233.\nBlocking solution for now, thinking about non-blocking alternatives.", "NaN"], ["235", "Schedulers Interface (Merging and Adding to Pull Request 229)", "Ben Christensen", "benjchristensen", "04/18/13, 04:11:13 PM", "Merging and adding to pull request https://github.com/Netflix/RxJava/pull/229 from @jmhofer which adds functionality discussed in the Scheduler issue https://github.com/Netflix/RxJava/issues/19\n\nWork done in https://github.com/Netflix/RxJava/pull/229 added the following methods to `Scheduler`:\n- `Subscription schedule(T state, Func2<Scheduler, T, Subscription> action, long delayTime, TimeUnit unit)`\n- `Subscription schedule(T state, Func2<Scheduler, T, Subscription> action)`\n\nThese are in fact the primary methods from RxNet (http://msdn.microsoft.com/en-us/library/hh211963(v=vs.103).aspx) and the others are just helper overloads.\n\nIt seems beneficial to use these 2 methods for actual implementation logic while all other methods are just decorating and forwarding from AbstractScheduler to these methods.\n\nI propose these changes on top of pull request https://github.com/Netflix/RxJava/pull/229 to achieve this.\n\nI also added unit tests that @mairbek created (https://github.com/Netflix/RxJava/pull/229#issuecomment-16115941).\n\nAll unit tests are passing \u2026 but we don't yet have enough unit test coverage so I won't be surprised if bugs are found.", "NaN"], ["236", "Fixed Sleeping Action", "Mairbek Khadikov", "mairbek", "04/18/13, 05:29:29 PM", "Sleeping action wasn't working correctly.", "NaN"], ["237", "Implement ConnectableObservable and Observable.publish", "Gerben", "Treora", "04/19/13, 09:08:14 PM", "Hi,\nI hope you appreciate this implementation. Most of it is a quite straightforward mimic of the .NET version. Could you perhaps verify if I used the lock and the subscription wrapper correctly?\n\nFollowing the behaviour of the .NET Rx implementation, a ConnectableObservable\nconsists of a Subject that can be connected to its source Observable by calling\nthe connect() method. The Observable.publish() method can be used to create a\nnew ConnectableObservable for the given Observable.\n\nGreetings,\nGerben", "NaN"], ["238", "ScheduledObserver/ObserveOn - Manual Merge of Pull 234", "Ben Christensen", "benjchristensen", "04/18/13, 05:47:01 PM", "Manual merge of https://github.com/Netflix/RxJava/pull/234 with some unit test tweaks and additions.", "NaN"], ["239", "CurrentThreadScheduler Delayed Execution Fix", "Mairbek Khadikov", "mairbek", "04/18/13, 07:06:20 PM", "Added unit tests for the delayed execution for `CurrentThreadScheduler`.\nRe-implemented queueing in order to make those tests pass.", "NaN"], ["240", "Update TestScheduler to match merged Scheduler changes", "Ben Christensen", "benjchristensen", "04/18/13, 07:41:44 PM", "- I accidentally merged this code before fixing it to match the changes to AbstractScheduler/Scheduler", "NaN"], ["241", "ReplaySubject - Manual Merge of Pull 218", "Ben Christensen", "benjchristensen", "04/18/13, 08:21:47 PM", "Manual merge of ReplaySubject from pull request https://github.com/Netflix/RxJava/pull/218\n- merged DefaultSubject and PublishedSubject which were the same thing (lots more unit tests though from this pull request)\n- still not sure what the right name is for DefaultSubject/PublishSubject\n- renamed RepeatSubject to ReplaySubject to match .Net\n- tweaked unit tests with InOrder while reviewing them to understand behavior\n- moved UnsubscribeTester into a package private class as I'm still undecided on long-term placement of this and the OperatorTester class", "NaN"], ["244", "Pre 0.8.0 Release Changes", "Ben Christensen", "benjchristensen", "04/19/13, 06:50:27 PM", "Some cleanup before releasing.", "NaN"], ["245", "Moved state from Observable to Observer", "Mairbek Khadikov", "mairbek", "05/01/13, 04:51:00 AM", "NaN", "NaN"], ["246", "Scheduling actions periodically", "Joachim Hofer", "jmhofer", "05/01/13, 04:55:54 AM", "As proposed earlier by @mairbek in https://github.com/Netflix/RxJava/pull/228#issuecomment-16254526, I extended the `Scheduler` by yet another method `schedulePeriodically`. This has a default implementation that works via recursion. I tried it out with all existing schedulers, and it seems to work fine. I also wrote a unit test for it using the `TestScheduler`.\n\nI switched scheduled executor services to use their fixed rate scheduling instead of the recursive default implementation. And I also switched the `OperationInterval` implementation to use periodic scheduling.", "NaN"], ["247", "Add flatMap alias to mapMany", "Ben Christensen", "benjchristensen", "05/01/13, 04:50:14 AM", "This is to match with what Java 8 is adding to Stream so we support the duality of Iterable/Collection to Observable.\n\nhttp://download.java.net/lambda/b86/docs/api/java/util/stream/Stream.html#flatMap(java.util.function.Function)", "NaN"], ["248", "Implemented Sample Operation", "Joachim Hofer", "jmhofer", "05/01/13, 08:49:18 PM", "Now that `OperationInterval` is in, `OperationSample` (see  #74) was kind of straightforward. I also added a unit test against sampling, and allowed for specifying a scheduler used by the sample operation.", "NaN"], ["249", "Timestamp operation", "Joachim Hofer", "jmhofer", "05/01/13, 08:51:44 PM", "Straightforward implementation of issue #93, based on `OperationMap` (without the scheduler version, as `map` doesn't take a scheduler yet either).", "NaN"], ["250", "Initial implementation of AsyncSubject", "Michael de Jong", "michaeldejong", "05/01/13, 05:04:40 AM", "I've done some work on AsyncSubject<T>, including unit tests and I'm looking for feedback. \n\nI don't expect to get this pull request immediately accepted. But I hope to find out if this is the correct workflow for this repository, and if the code is up to your standards, before I start pouring in more hours into issue #17. If you guys are ok with the AsyncSubject<T> implementation I'll start working on the others.\n\nLooking forward to some feedback!", "NaN"], ["252", "Observable.toFuture", "Ben Christensen", "benjchristensen", "05/01/13, 04:56:04 AM", "NaN", "NaN"], ["253", "Fix multiple subscription bug on operation filter", "Gerben", "Treora", "05/01/13, 08:48:19 PM", "A new subscription must be created on every subscribe call, otherwise any\nsubscribe call after the first directly fails.", "NaN"], ["254", "Swing scheduler", "Joachim Hofer", "jmhofer", "05/06/13, 08:12:50 PM", "I've added a Swing-specific scheduler to RxJava. However, it probably doesn't belong to `rxjava-core` and therefore, I've created a subfolder named `extensions` with currently one single subproject `rxjava-swing` with currently one single class `SwingScheduler`.\n\nI've tried to create a build for this, too, but I'm not very familiar with Gradle, so somebody should probably check that it's okay like this.\n\nAlso, I'm not very happy with the subfolder name (`extensions`). Maybe somebody has a better idea for a more specific name?", "NaN"], ["255", "Cleaning up - fixing a lot of build warnings (mostly javadoc)", "Joachim Hofer", "jmhofer", "05/06/13, 08:14:13 PM", "I'm not good at ignoring warnings... - there are lots of them in the build output, mostly due to invalid javadoc link syntax or missing `@return` descriptions.\n\nThis is my attempt at fixing them.", "NaN"], ["256", "Created the initial implementation of BehaviorSubject", "Michael de Jong", "michaeldejong", "05/07/13, 04:19:12 PM", "I've been trying to implement the BehaviorSubject. Functionally it works as it should, but I'm not entirely happy with the static `createWithDefaultValue(T)` method. I can't create a static method `create(T)` because Subject extends Observable, which has a static `create(Object)` method. So to resolve that I had to give the static method in BehaviorSubject a different name.\n\nAdditionally I'm using an `AtomicReference<T>` in this static method to keep track of the last published value. I tried coming up with different solutions to push the last published value to the Observer when it's subscribing, but this seems to be the most clean solution.\n\nIf there's any feedback on either issue, please let me know.", "NaN"], ["257", "Improved scan, reduce, aggregate", "Joachim Hofer", "jmhofer", "05/07/13, 02:04:57 PM", "`scan` is currently restricted to accumulators of type `Func2<T, T, T>` where `Func2<R, T, R>` would be possible for initial values of type `R`. This pull request tries to fix this by generalizing the `scan` implementation. I had to restructure the scan operator a bit for this to stay typesafe. Imho it's more readable now, though.\n\nThis indirectly leads to generalized `reduce`, too.\n\nAlso, `aggregate` is added as an alias for `reduce` (see #20).", "NaN"], ["258", "Operation: throttle", "Michael de Jong", "michaeldejong", "09/11/13, 04:53:17 PM", "The throttle operation is a filtering operator which is meant to combat receiving bursts of events in short periods of time. The original Rx .Net implementation of this operator works as followed:\n\nUpon receiving an event A, it waits a certain specified amount of time Z before propagating it to the `Observer`. If another event B is received within this period of time, the propagation of A is cancelled, and B will be propagated in stead as soon as a Z amount of time has passed since B was received.\n\nAs @benjchristensen already mentioned, the use of threads in this way is quite inefficient. To this end I proposed two additional variations on this scheme of throttling [here](https://github.com/Netflix/RxJava/pull/258#issuecomment-17880627). The question now is which schemes do we want (to support)?\n\nAny thoughts on this is highly appreciated!", "NaN"], ["259", "Added the switch operator to Observable", "Michael de Jong", "michaeldejong", "05/16/13, 07:16:25 PM", "I've implemented the switch operator for `Observable` sequences (see issue #13). Because \"switch\" is a keyword in Java I have opted for switchDo. This matches to the finallyDo method which represents the finally operator and has the same naming problem. \n\nPlease let me know if you have any feedback.", "NaN"], ["260", "Publish, Replay and Cache Operators", "Ben Christensen", "benjchristensen", "05/07/13, 02:54:24 PM", "Added basic Publish (https://github.com/Netflix/RxJava/issues/15) and Replay (https://github.com/Netflix/RxJava/issues/71) operators to Observable. I have not done any of the overloads (particularly `Replay` which has 10+ in .Net.\n\nI also added a new `Cache` operator as discussed by @johngmyers and I at https://github.com/Netflix/RxJava/pull/209.\n\nPlaying with `Replay` and `ConnectableObservable` it does not cater well to the typical use case of needing to just de-dupe calls (cache the responses) so this `Cache` operator can be thought of as an automatic version of `Replay`. It comes with the same risk as `toList` if used with infinite or very large sequences as you can not unsubscribe from it.", "NaN"], ["261", "Multicast: `Observable.publish()`", "Joachim Hofer", "jmhofer", "05/07/13, 02:23:02 PM", "A very little API addition: publishing observables without requiring a `Subject`. See #65 (and http://northhorizon.net/2011/sharing-in-rx/).", "NaN"], ["262", "A few basic Swing observables", "Joachim Hofer", "jmhofer", "05/07/13, 03:37:01 PM", "This adds a few observables for observing common button click, keyboard and mouse events.", "NaN"], ["263", "Publish, Replay and Cache Operators", "Ben Christensen", "benjchristensen", "05/07/13, 02:53:54 PM", "(Redo of https://github.com/Netflix/RxJava/pull/260 after merging)\n\nAdded basic Publish (https://github.com/Netflix/RxJava/issues/15) and Replay (https://github.com/Netflix/RxJava/issues/71) operators to Observable. I have not done any of the overloads (particularly `Replay` which has 10+ in .Net.\n\nI also added a new `Cache` operator as discussed by @johngmyers and I at https://github.com/Netflix/RxJava/pull/209.\n\nPlaying with `Replay` and `ConnectableObservable` it does not cater well to the typical use case of needing to just de-dupe calls (cache the responses) so this `Cache` operator can be thought of as an automatic version of `Replay`. It comes with the same risk as `toList` if used with infinite or very large sequences as you can not unsubscribe from it.", "NaN"], ["264", "Merge BehaviorSubject from Pull 256", "Ben Christensen", "benjchristensen", "05/07/13, 04:19:11 PM", "Manual merge of https://github.com/Netflix/RxJava/pull/256 \n\nAdditionally removes SynchronizedObserver usage from Subject implementations.\n- We don't need to add synchronization as the subjects can trust their source Observables to comply with the Rx contract.\n- This optimization follows Rx Design Guidelines 6.8. Avoid serializing operators\n\nThis was discussed at https://github.com/Netflix/RxJava/pull/256", "NaN"], ["265", "Swing - component event observables and minor cleanup", "Joachim Hofer", "jmhofer", "05/07/13, 10:00:34 PM", "Here's another small pull request concerning the Swing contrib. - With this, I think I'm very well equipped to start with my little Swing Pong demo...", "NaN"], ["266", "change from junit to junit-dep", "Ben Christensen", "benjchristensen", "05/07/13, 10:06:11 PM", "- removes Hamcrest dependencies (http://saltnlight5.blogspot.com/2012/10/whats-up-with-junit-and-hamcrest.html)\n- solves conflicts on our CI server (blocking release to Maven Central)", "NaN"], ["267", "CombineLatest without synchronization", "Joachim Hofer", "jmhofer", "07/05/13, 10:03:20 PM", "Finally, I managed to get rid of all the synchronization in `CombineLatest` (it all boils down to two atomics and one concurrent map). As concurrency is always hairy to get right: Can someone please check that it's okay like that?\n\nI also added static methods to `Observable` for it, and fixed the handling of exceptions within the combining function.\n\nUsage is (though non-asynchronous source observables don't make sense, I use these here in order to keep the example simple):\n\n``` java\nObservable<Integer> o1 = Observable.from(1, 2, 3);\nObservable<Integer> o2 = Observable.from(4, 5, 6);\nObservable<Integer> r = Observable.combineLatest(o1, o2, new Func2<Integer, Integer, Integer>() {\n  @Override Integer call(Integer a, Integer b) {\n    return a + b;\n  }\n});\n```", "NaN"], ["268", "Fix concurrency bug in ScheduledObserver", "Ben Christensen", "benjchristensen", "05/10/13, 08:22:17 PM", "- found a concurrency bug while working on https://github.com/Netflix/Hystrix/issues/123\n- the following code would lock up occasionally due to onCompleted not being delivered:\n\n``` java\npublic class RunTest {\n    public static void main(String[] args) {\n        System.out.println(\"Starting test...\");\n\n        final ArrayList<String> strings = new ArrayList<String>(200000);\n\n        int num = 10000;\n        while (true) {\n            long start = System.currentTimeMillis();\n            final AtomicInteger count = new AtomicInteger();\n            for (int i = 0; i < num; i++) {\n                new TestService1(2, 5).toObservable().forEach(new Action1<Integer>() {\n\n                    @Override\n                    public void call(Integer v) {\n                        count.addAndGet(v);\n                    }\n                });\n\n                new TestService2(\"hello\").toObservable().forEach(new Action1<String>() {\n\n                    @Override\n                    public void call(String v) {\n                        strings.add(v);\n                    }\n\n                });\n            }\n            long time = (System.currentTimeMillis() - start);\n            long executions = num * 2;\n            System.out.println(\"Time: \" + time + \"ms for \" + executions + \" executions (\" + (time * 1000) / executions + \" microseconds)\");\n            System.out.println(\"   Count: \" + count);\n            System.out.println(\"   Strings: \" + strings.size());\n            strings.clear();\n        }\n    }\n}\n```\n- Also made OperationObserveOn not use ScheduledObserver if the `ImmediateScheduler` is chosen to allow an optimization. I believe this optimization is safe because ScheduledObserver does not require knowledge of a Scheduler (such as for now()) and all we do is emit data to the Observer on a scheduler and if we know it's Immediate we can go direct and skip the enqueuing step. This allows shaving off a noticable number of microseconds per execution in the loop above.", "NaN"], ["269", "Fix concurrency bug in ScheduledObserver", "Ben Christensen", "benjchristensen", "05/11/13, 02:10:25 PM", "This is a followup to https://github.com/Netflix/RxJava/commit/1fa6ae3be23200c787cc1c25c0bb8cac99ae0d17 that fixed one issue (concurrency) and created another (broke Rx contract by allowing concurrent execution of onNext).\n\nI have reverted back to the previous implementatio and then attempted to fix the concurrency issue again.\n\nI think it ended up being a simple fix \u2026 just re-ordering the `enqueue` method to remove the race-condition between the logic protected by the AtomicInteger and adding to the queue.\n\nIt's not an atomic operation (adding then processing) so we need to just add to the queue and treat it as an async data structure and keep the AtomicInteger portion to only protecting the \"process or not process\" logic.\n\n``` java\n        // this must happen before 'counter' is used to provide synchronization between threads\n        queue.offer(notification);\n```\n\nThis may still have issues but it's now working in all of my concurrency tests (the ones that broken with the original and then my modified version). The tests are not easy to build unit tests out of as they require running for many seconds and non-deterministically causing a race condition so I have not yet spend the time to try and figure out a deterministic unit test hence them not being committed.", "NaN"], ["271", "Rewrite concat operation to not block on subscribe", "Gerben", "Treora", "05/16/13, 04:23:18 PM", "Hi,\nWhile trying to stop the subscribe function from blocking, I ended up rewriting the most of the concat operation. From related issue discussions it appears the desired behaviour is still under debate, so I hope you agree on the chosen approach. See the explanation below.\nBecause practically it implements two asynchronous observers that interact with eachother, there are quite a few possible race conditions and other possibilities to break the Rx grammar, but I hope I fixed all of them.\nRegards,\n\nGerben\n\nThe concat operator previously blocked on calling subscribe until all the\nsequences had finished. In quite some cases this results in unwanted (and\nunexpected) behaviour, such as when prefixing an infinite Observable\nwith a fixed one, for example when using startWith (which calls concat):\n`someInputStream.startWith(123).subscribe(x -> print(x));`\nThis statement will block indefinitely if the input stream is infinite. Also\non finite sequences it seems silly to have to wait for them to finish.\n\nIn this new approach the incoming observables are put into a queue, instead\nof waiting for the whole sequence to finish. When the first observable\ncompletes, the next one is taken from the queue and subscribed to, and so\non. The queue can be extended while processing the observables, and\nonCompleted is only called when both the source of observables has completed\nand all observables in the queue have been read.", "NaN"], ["272", "BlockingObservable", "Ben Christensen", "benjchristensen", "05/16/13, 04:22:39 PM", "Move all blocking operators to `BlockingObservable`. This has breaking changes for anything using blocking operators ... part of the pursuit of establishing a clean API on our path to 1.0.\n\nThis is something I've been wanting to do for a while but got the push over the ledge via discussion at https://github.com/Netflix/RxJava/issues/270.\n\nThis strays from \"match Rx.Net as closely as possible\" but feels justified for the following reasons:\n- Rx is primarily intended for asynchronous event handling and composition\n- mixing blocking and non-blocking operators is confusing and leads to poor usage patterns\n- mixing blocking operators (like `take` and `takeLast` is non-obvious)\n- Rx.Net intends on deprecating (or has already) blocking operators as per Erik Meijer @headinthebox in this discussion: https://github.com/Netflix/RxJava/issues/270#issuecomment-17882444 \n\nI have removed all blocking operators from `Observable` and put them in `BlockingObservable`. I have left `Observable.toBlockingObservable` as a means of going from one to the other as it is an obvious communication of what is now being permitted. \n\nWhile doing this I also cleaned up some odd API artifacts such as `toObservable` vs `from` and moved implementation specific code from `rx.util` into the internal package `rx.operators` where all code reserves the right to change at any time.\n\nI intend on releasing this as version 0.9.", "NaN"], ["273", "Concat", "Billy Yuen", "billyy", "05/16/13, 04:23:16 PM", "Add new unit test to cover non-blocking subscribe() for Concat operator.", "NaN"], ["274", "0.9 cleanup", "Ben Christensen", "benjchristensen", "05/16/13, 10:54:43 PM", "NaN", "NaN"], ["275", "Move forEach to BlockingObservable", "Ben Christensen", "benjchristensen", "05/16/13, 11:07:31 PM", "- was missed in previous refactoring", "NaN"], ["279", "Adding marble diagrams", "David Gross", "DavidMGross", "05/28/13, 08:15:44 PM", "several new marble diagrams for previously undiagrammed methods", "NaN"], ["280", "Diagrams and some new javadoc content for Observable subclasses", "David Gross", "DavidMGross", "05/28/13, 08:40:58 PM", "Some marble or marblish diagrams and a bit of new documentation for the\nBlockingObservable and ConnectableObservable subclasses.", "NaN"], ["281", "Operation: buffer", "Michael de Jong", "michaeldejong", "07/22/13, 04:55:22 PM", "The buffer operation is an operation which allows you to buffer incoming events into one or more buffers. Depending on their purpose, these buffers can be emitted to an `Observer` when needed. In essence this means that events are collected and propagated to the `Observer` in batches. The [original issue](https://github.com/Netflix/RxJava/issues/16), which this pull request addresses, mentions a total of 10 variations on this operator. This pull request contains code which supports all of them.\n\n![buffer](https://f.cloud.github.com/assets/4491168/731348/2f076cc8-e269-11e2-8fa8-e798f04f2f3c.png)\n\nThe 10 variations which exist in Rx .Net, can be subdivided into two categories: single and multi buffers. With single buffers, only one buffer at any time is actively collecting incoming events, whereas with multi buffers, multiple buffers are actively collecting incoming events. In the first case the `Observer` will receive every original event only once in one buffer, whereas in the latter case, the `Observer` will receive every original event zero or more times.\n### Single buffers\n##### buffer(bufferClosingSelector)\n\nThe bufferClosingSelector parameter is a `Func0<Observable<BufferClosing>>`. It uses to `Func0` object to construct an `Observable` which produces a `BufferClosing` object. Once this object has been produced by the `Observable` the currently active buffer will be closed and emitted to the `Observer`. At the same time a new buffer will be created which will start recording incoming events. \n##### buffer(count)\n\nThis operator closes and emits the current buffer after counting a certain amount of received events. At the same time it will create a new buffer which will start recording incoming events. One example would be `buffer(2)`, which with the following input: `[0, 1, 2, 3, 4, 5]` will output the following buffers: `[0, 1], [2, 3], [4, 5]`.\n##### buffer(timespan)\n\nThis operator closes and emits the current buffer after a certain amount of time has elapsed. At the same time it will create a new buffer which will start recording incoming events.\n##### buffer(timespan, scheduler)\n\nSame as previous operator, but now with a custom scheduler.\n##### buffer(timespan, count)\n\nThis operator closes and emits the current buffer after counting a certain amount of received events or after a certain amount of time has elapsed. At the same time it will create a new buffer which will start recording incoming events.\n##### buffer(timespan, count, scheduler)\n\nSame as previous operator, but now with a custom scheduler.\n### Multiple buffers\n##### buffer(count, skip)\n\nThis operator will create a new buffer after it has received 'skip' amount of events. Each buffer will be closed once it has reached a capacity of '[count'. One example would be `buffer(3, 1)`, which with the following input: `0, 1, 2, 3, 4, 5]`, will output the following buffers: `[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5]`.\n##### buffer(bufferOpenings, bufferClosingSelector)\n\nThis operator takes two parameters: an `Observable<BufferOpening>` and a `Func1<BufferOpening, Observable<BufferClosing>>`. The first parameter determines when buffers are created. The second parameter determines when the buffers are closed. Every time a `BufferOpening` object is received from the `Observable` a new buffer is created. The received `BufferOpening` object is fed into the second parameter which yields an `Observable<BufferClosing>` object. When this `Observable` produces a `BufferClosing` object, the associated buffer is closed and emitted.\n##### buffer(timespan, timeshift)\n\nThis operator is very similar to `buffer(count, skip)`, but in stead of counting events, it's based on time. The `timeshift` period defines how often a new buffer will be created. The `timespan` period defines the period between buffer construction and buffer emission.\n##### buffer(timespan, timeshift, scheduler)\n\nSame as previous operator, but now with a custom scheduler.\n\nAs always, **feedback is welcome!**", "NaN"], ["283", "GroupBy GroupedObservables should not re-subscribe to parent sequence", "Ben Christensen", "benjchristensen", "06/02/13, 04:25:27 AM", "https://github.com/Netflix/RxJava/issues/282\n\nRefactored to maintain a single subscription that propagates events to the correct child GroupedObservables.", "NaN"], ["284", "GroupBy fixes as reported in Issue 282", "Ben Christensen", "benjchristensen", "06/05/13, 04:37:50 AM", "Issue https://github.com/Netflix/RxJava/issues/282\n- Refactored to maintain a single subscription that propagates events to the correct child GroupedObservables.\n- make unsubscribe work correctly for parent/child sequences\n- add language adaptor support", "NaN"], ["285", "Several new or more-precise marble diagrams", "David Gross", "DavidMGross", "06/03/13, 11:08:46 PM", "Add several new or more-specific marble diagrams, correct two bad image\nlinks, correct some typos", "NaN"], ["287", "Error handling and validation", "Ben Christensen", "benjchristensen", "06/04/13, 06:45:01 AM", "Refactoring related to arg validation and error handling.\n\nhttps://github.com/Netflix/RxJava/issues/198 Throw if no onError handler specified\nhttps://github.com/Netflix/RxJava/issues/278 Subscribe argument validation", "NaN"], ["288", "Fix PublishSubject non-deterministic behavior on concurrent modification", "Ben Christensen", "benjchristensen", "06/05/13, 04:30:43 AM", "- changed to take snapshot of observers.values() before iterating in onNext/onError/onCompleted so that nested subscriptions that add to observers can't change the values() iteration\n- single-threaded nested subscriptions are now deterministic\n- multi-threaded subscriptions will no longer be allowed to race to get into an interating onNext/onError/onCompleted loop, they will always wait until the next\n- also improved terminal state behavior when subscribing to a PublishSubject that has already received onError/onCompleted\n\nhttps://github.com/Netflix/RxJava/issues/282", "NaN"], ["289", "Fixes on #284 (groupBy)", "Gerben", "Treora", "12/06/13, 01:03:16 AM", "See my previous [comment](https://github.com/Netflix/RxJava/issues/282#issuecomment-19013992).", "NaN"], ["290", "Issue 103", "George Campbell", "abersnaze", "07/05/13, 09:30:02 PM", "Adding the zip operator that works on collection of Observables and a FuncN.\n\nhttps://github.com/Netflix/RxJava/issues/103", "NaN"], ["292", "Kotlin Language Adaptor", "Mario Arias", "MarioAriasC", "09/03/13, 10:11:10 PM", "Langauge adaptor for kotlin", "NaN"], ["294", "Make ScheduledSubscription public, expose scheduler field", "Matthias K\u00e4ppler", "mttkay", "07/05/13, 09:28:54 PM", "As proposed in issue #293\n\nThis will make it easier to verify proper scheduling behavior of services implemented using rx.", "NaN"], ["300", "Type-safety in rxjava-core, dynamic language support via compile-time code generation, and Scala support via implicits", "Matt Jacobs", "mattrjacobs", "07/05/13, 11:43:43 PM", "Implementation of ideas here: https://groups.google.com/forum/#!topic/rxjava/g6Z9KyMM8zs\n\nThis addresses #204 and #208 .", "NaN"], ["302", "Update Observable.isInternalImplementation, get rid of NullPointerExcept...", "Roman", "nj4x", "07/05/13, 09:15:35 PM", "...ion\n\nNullPointerException has been encountered during my tests. It is because java.lang.Class.getPackage() may return null \"... if no package information is available from the archive or codebase\" (documented feature).", "NaN"], ["303", "Pull 267 - Merge combineLatest", "Ben Christensen", "benjchristensen", "07/05/13, 10:03:20 PM", "Spent some time reviewing it and it seems good. Any bugs can be dealt with as people start playing with it instead of me holding this up as a pull request any longer since this exposes `combineLatest` in `Observable` for I believe the first time and is thus a low risk to breaking any existing users.", "NaN"], ["304", "Version 0.10.0 - Static Language Support", "Ben Christensen", "benjchristensen", "08/20/13, 09:07:20 PM", "Manual merge of pull https://github.com/Netflix/RxJava/pull/300 from @mattrjacobs \n\nThis will make RxJava completely static by removing all Object overloads (see https://github.com/Netflix/RxJava/issues/208 and https://github.com/Netflix/RxJava/issues/204).\n\nI'm submitting this before it being 100% ready so people can review and provide feedback.\n\nOpen items to append to this pull request before merging:\n\n**1) subscribe with map is not handled yet**\n\nThe following signature needs to be made static. Right now the lack of this combined with removal of Functions.from dynamic language functionality has broken this.\n\n``` java\npublic Subscription subscribe(final Map<String, Object> callbacks)\n```\n\n**2) Core artifact naming convention**\n\nShould rxjava-core-x.y.x.jar become rxjava-x.y.z.jar since the concept of core+language no longer applies?\n\nI think I'd prefer this:\n- rxjava-x.y.z.jar \n- rxjava-groovy-x.y.z.jar \n- rxjava-clojure-x.y.z.jar \n- rxjava-scala-x.y.z.jar \n- rxjava-jruby-x.y.z.jar \n- rxjava-kotlin-x.y.z.jar \n- rxjava-dynamic-x.y.z.jar (object overload for any language)\n- rxjava-groovy-clojure-x.y.z.jar (multi-language jar)\n\nOnly one of those jars is needed hence the reason why I think the 'core' term is no longer needed as it communicated the fact it was always needed.\n\nAny contrib modules would be: rxjava-contrib-module-name-x.y.x.jar\n\n**3) Dependencies from languages to core still exist**\n\nThe build still will result in Maven Central POM files requires rxjava-core from the language version despite that not being the case. Need to eliminate this dependency in the artifact.\n\n---\n\nImplementation notes originally posted at https://github.com/Netflix/RxJava/issues/204#issuecomment-20396621:\n\nAfter implementing and throwing away a few different approaches we have landed on a solution we feel will balance the various competing priorities. \n\nOur goals are:\n- support static typing for Java/Scala/Kotlin etc by removing the Object overloads\n- support any JVM language, static or dynamically typed\n- allow all languages to use the same `rx.Observable` class so that we don't divide libraries with helpers such as `GroovyObservable`, `ClojureObservable` etc that then need to be converted back and forth when doing interop\n- do not require special classloaders or agents to enable runtime bytecode generation\n- do not remove static operators to enable proxying\n- small jars and limited or no dependencies\n\nThe solution we have arrived at will work as follows:\n- The rxjava-core source code will delete all Object overload methods and be pure static java.\n  - Any language that supports functional interfaces directly (such as Java 8 and XTend) can use the Java core version directly.\n- Languages needing specific lambda/clojure type mapping to the Func_/Action_ types will have language specific Jars created via build-time bytecode generation.\n  - Any method with a Func_/Action_ argument will be overloaded with a version supporting the language requirements.\n\nFor example:\n\nThe default Java version:\n\n``` java\npublic static <T> Observable<T> filter(Observable<T> that, Func1<T, Boolean> predicate)\n```\n\nA Groovy version:\n\n``` java\npublic static <T> Observable<T> filter(Observable<T> that, groovy.lang.Closure predicate)\n```\n- A jar per language will be created as follows:\n  - rxjava-x.y.z.jar \n  - rxjava-groovy-x.y.z.jar \n  - rxjava-clojure-x.y.z.jar \n  - rxjava-scala-x.y.z.jar \n  - rxjava-jruby-x.y.z.jar \n  - rxjava-kotlin-x.y.z.jar \n\nA project will include just the jar that meets their language needs, there will no longer be a \"core\" jar plus the language adaptor.\n\nThe drawback of this is that mixing two of these in a classpath will result in non-deterministic loading (whichever is loaded last wins) and that is the version that will be used. This means if a library depends on rxjava.jar but is using Groovy and needs rxjava-groovy.jar it is up to the developer of that project to make sure they have only the rxjava-groovy.jar version. This is not ideal but is a one-time pain setting up a build and is better than the constant pain of missing static typing or converting to/from different Observable implementations for different languages.\n- At this time we are optimizing for projects using a single language or Java + another language. If there are use cases where people are trying to mix multiple languages in a very polyglot manner we have two options:\n  - include an rxjava-dynamic.jar version that re-adds the Object overloads\n  - include build configs for common combinations of languages such as rxjava-groovy-clojure.jar\n- Language adaptations (such as clojure which has preferred idioms that necessitate wrapping) will still be possible through the language-adaptor projects and be included in the appropriate language jars.\n\nThis should not break any code but will require a slight change to the build dependencies in your project when we release this. \n\nWe hope that this enables the RxJava project to better achieve its goal of being polyglot and targeting the JVM in general and not any specific languages without sacrificing interop or idiomatic usage in each of the languages.", "NaN"], ["305", "Getting rid of one of the Gradle 1.6 deprecation warnings", "Joachim Hofer", "jmhofer", "07/22/13, 04:35:58 PM", "This PR addresses one of Gradle's new deprecation warnings.\n\n(The other warning is caused by the LicensePlugin, as far as I can see.)", "NaN"], ["308", "Ensure now() is always updated in TestScheduler.advanceTo/By", "Nick North", "NorthNick", "07/22/13, 04:35:26 PM", "The TestScheduler advanceTimeTo() and advanceTimeBy() methods only update now() correctly if there is a scheduled event in the work queue after the target time. If the queue is empty, now() is not updated at all. If it has no items after the target time, then now() is updated to the time of the last event on the queue.\n\nThe pull request ensures now() is always updated to the target time. There is no check to make sure time always moves forwards, but then that check is not in the current implementation either.", "NaN"], ["309", "A little typo in a comment in the Clojure examples", "Joseph Wilk", "josephwilk", "07/22/13, 04:33:11 PM", "NaN", "NaN"], ["311", "Various Javadoc improvements and corrections.", "Dave Ray", "daveray", "07/31/13, 08:53:46 PM", "I've been exploring the rxjava source code for the last week or two in my spare time and along the way I cleaned up and made minor corrections and improvements to the Javadocs. Here's the changes if they're of interest.", "NaN"], ["312", "Fix for OperatorOnErrorResumeNextViaObservable and async Resume", "Peter McDonnell", "petermd", "07/31/13, 09:01:02 PM", "This patch is to ensure that OnErrorResumeNextViaObservable handles source Observables that emit invalid sequences of onNext/onError/onCompleted.\n\nPlease see #306 for a more detailed description of how this can occur (and what other fixes might be needed)\n\nTo re-create the issue the provided resume Observable itself must be async. Because it does not complete immediately there is a window where the source Observable can produce additional events which are then propogated into the output. \n\nThe fix ensures the operator only propogates onNext/onCompleted as long as the original subscription is valid. It also prevents the resume subscription happening more than once even if multiple onError events being received.", "NaN"], ["314", "Map Error Handling", "Ben Christensen", "benjchristensen", "07/31/13, 10:37:46 PM", "While reviewing pull request https://github.com/Netflix/RxJava/pull/312 I noticed that the behavior of Map didn't seem right in how it continued emitting values and necessitated the changes to onErrorResumeNext. \n\nDigging in it seems the onNext was manually doing error handling but in a non-comprehensive manner whereas now I am letting the `SafeObserver` (previously called `AtomicObserver`) handle it which does unsubscribes and ignores subsequent events if it doesn't unsubscribe correctly.\n\nThis is also related to https://github.com/Netflix/RxJava/issues/216.", "NaN"], ["315", "Change onError(Exception) to onError(Throwable) - Issue #296", "Ben Christensen", "benjchristensen", "08/01/13, 05:25:08 PM", "This changes `Observer#onError(Exception e)` to `Observer#onError(Throwable e)`\n\nSee \"Observer#onError should use Throwable\" https://github.com/Netflix/RxJava/issues/296 for discussion that led to this change.\n\nThis is a breaking change and will result in a version bump from 0.9.x to 0.10.x. ", "NaN"], ["316", "Remove thread.sleep from unit test to speed it up", "Ben Christensen", "benjchristensen", "08/01/13, 05:33:40 PM", ".. and apparently formatting and imports changed a bunch ...", "NaN"], ["317", "AndroidScheduler.java", "Prabir Shrestha", "prabirshrestha", "08/15/13, 02:26:34 PM", "Initial spike for AndroidScheduler.java.\n\nBeen using this for quite some time. But I don't like the concept using calling `observer.observeOn(AndroidScheduler.getInstance())` as it sort of puts Android specific stuffs. Should RxJava support some concept of `Schedulers.mainScheduler()`? We can then set the default main schedulers using `Schedulers.setMainScheduler(AndroidScheduler.getInstance())` when app starts.", "NaN"], ["318", "Initial support for scheduling on Android Handler threads", "Matthias K\u00e4ppler", "mttkay", "08/23/13, 05:56:26 AM", "To add to the discussion in https://github.com/Netflix/RxJava/pull/317, this is pretty much what we're using in our production app since a few weeks now. It used to live in our app project, but since we've already started talking about adding to rxjava-contrib, I've pulled out the code in question and integrated it into RxJava under rxjava-android.\n\nThis comprises:\n- [x] a `Scheduler` implementation which schedules work on Android's `Handler` threads, including the main UI thread.\n- [x] an `AndroidSchedulers` class which provides factory methods to instantiate Handler schedulers, especially the main thread scheduler\n- [x] unit test support via Robolectric\n- [x] build integration\n\nThere is some discussion needed around both test support and build integration. @mustafasezgin will want to weigh in on this. In order to write Android unit tests, you're unfortunately required to take a few obstacles, so we had to add some cruft to the production code (an empty Android `R` class and a custom test runner.)", "NaN"], ["319", "typesafe-core", "Matt Jacobs", "mattrjacobs", "08/29/13, 07:17:52 PM", "Here's another attempt at making rx-core typesafe and still supporting dynamic languages. The previous attempt was https://github.com/Netflix/RxJava/pull/304.  Enough changed (including the 0.10 release) since I submitted #304 that it made more sense to start fresh with this one.  All the comments from that PR still apply, and the 'subscribe on map' issue is now handled.\n\nThis will make RxJava completely static by removing all Object overloads (see https://github.com/Netflix/RxJava/issues/208 and https://github.com/Netflix/RxJava/issues/204).\n\n---\n\nImplementation notes originally posted at https://github.com/Netflix/RxJava/issues/204#issuecomment-20396621:\n\nAfter implementing and throwing away a few different approaches we have landed on a solution we feel will balance the various competing priorities. \n\nOur goals are:\n- support static typing for Java/Scala/Kotlin etc by removing the Object overloads\n- support any JVM language, static or dynamically typed\n- allow all languages to use the same `rx.Observable` class so that we don't divide libraries with helpers such as `GroovyObservable`, `ClojureObservable` etc that then need to be converted back and forth when doing interop\n- do not require special classloaders or agents to enable runtime bytecode generation\n- do not remove static operators to enable proxying\n- small jars and limited or no dependencies\n\nThe solution we have arrived at will work as follows:\n- The rxjava-core source code will delete all Object overload methods and be pure static java.\n  - Any language that supports functional interfaces directly (such as Java 8 and XTend) can use the Java core version directly.\n- Languages needing specific lambda/clojure type mapping to the Func_/Action_ types will have language specific Jars created via build-time bytecode generation.\n  - Any method with a Func_/Action_ argument will be overloaded with a version supporting the language requirements.\n\nFor example:\n\nThe default Java version:\n\n``` java\npublic static <T> Observable<T> filter(Observable<T> that, Func1<T, Boolean> predicate)\n```\n\nA Groovy version:\n\n``` java\npublic static <T> Observable<T> filter(Observable<T> that, groovy.lang.Closure predicate)\n```\n- A jar per language will be created as follows:\n  - rxjava-x.y.z.jar \n  - rxjava-groovy-x.y.z.jar \n  - rxjava-clojure-x.y.z.jar \n  - rxjava-scala-x.y.z.jar \n  - rxjava-jruby-x.y.z.jar \n  - rxjava-kotlin-x.y.z.jar \n\nA project will include just the jar that meets their language needs, there will no longer be a \"core\" jar plus the language adaptor.\n\nThe drawback of this is that mixing two of these in a classpath will result in non-deterministic loading (whichever is loaded last wins) and that is the version that will be used. This means if a library depends on rxjava.jar but is using Groovy and needs rxjava-groovy.jar it is up to the developer of that project to make sure they have only the rxjava-groovy.jar version. This is not ideal but is a one-time pain setting up a build and is better than the constant pain of missing static typing or converting to/from different Observable implementations for different languages.\n- At this time we are optimizing for projects using a single language or Java + another language. If there are use cases where people are trying to mix multiple languages in a very polyglot manner we have two options:\n  - include an rxjava-dynamic.jar version that re-adds the Object overloads\n  - include build configs for common combinations of languages such as rxjava-groovy-clojure.jar\n- Language adaptations (such as clojure which has preferred idioms that necessitate wrapping) will still be possible through the language-adaptor projects and be included in the appropriate language jars.\n\nThis should not break any code but will require a slight change to the build dependencies in your project when we release this. \n\nWe hope that this enables the RxJava project to better achieve its goal of being polyglot and targeting the JVM in general and not any specific languages without sacrificing interop or idiomatic usage in each of the languages.", "NaN"], ["321", "AtomicObservableSubscription to SafeObservableSubscription", "Ben Christensen", "benjchristensen", "08/24/13, 04:00:59 AM", "NaN", "NaN"], ["322", "Update Android README.md", "Matthias K\u00e4ppler", "mttkay", "08/24/13, 05:03:46 PM", "Added sample usage of Android Handler schedulers.", "NaN"], ["323", "Static core", "Matt Jacobs", "mattrjacobs", "08/30/13, 05:35:18 PM", "Another take on Issues #204, #208.  \n- typesafe rxjava-core\n- modular jars\n- Scala support via implicits\n- Groovy support via extension methods\n- No Clojure support in this PR (eventually via macros)\n- Eliminated JRuby support (for now)", "NaN"], ["324", "0.11 Cleanup", "Ben Christensen", "benjchristensen", "08/30/13, 10:27:59 PM", "NaN", "NaN"], ["325", "Preserve metadata on fn and action macros", "Dave Ray", "daveray", "08/31/13, 06:07:39 AM", "Because they're macros, rx/fn and rx/action would lose metadata attached\nto them, in particular type hints which are slightly important to\ndisambiguate overloaded Observable methods. Fixed.", "NaN"], ["330", "Make DummyObservable visible to clojureTest classpath.", "Dave Ray", "daveray", "08/31/13, 08:28:40 PM", "RxJava issue #327. Moved DummyObservable into main so that it's\ncompiled and available when the clojureTest task executes. Perhaps\nsomeone with stronger Gradle skills can figure out how to put this Java\nclass in src/test and get things to work out. Correctly. For the time\nbeing, several clean/build cycles worked fine for me.", "NaN"], ["331", "Adding super/extends so that Observable is covariant", "Joachim Hofer", "jmhofer", "09/04/13, 10:43:30 PM", "Ok, so this pull request changes a _lot_ of lines. It's mostly generalizing all the `FuncX`s to be used like `FuncX[-T1, -T2, ..., -TX, +R]` (contravariant parameters, covariant return type) and all the `Observer`s to be used \"in a contravariant way\". A few of the `Observable` uses are covariant, now, too (mostly `zip`).\n\nThis is the pull request for #326.\n\nThis doesn't look very good in the code (thanks Java). Also, it doesn't seem to make Scala interop easier at all (at least not yet).\n\nPlease take a look. I'm not exactly happy with the result. - Maybe I'm doing something wrong here? - I've still got hope that there's an easier way...\n\nThe pull request compiles and tests ok for me (except for the Clojure module, but that's another story and not due to my changes).", "NaN"], ["332", "Issue 329: Fix non-deterministic unit tests", "Ben Christensen", "benjchristensen", "08/31/13, 09:15:47 PM", "I'm sure there are others, but I've tried to fix the ones reported in https://github.com/Netflix/RxJava/issues/329", "NaN"], ["337", "Added the window() operation.", "Bob Cotton", "bcotton", "09/05/13, 06:22:12 AM", "window() returns an Observable<Observable<T>> that will chunk the source observable\nbased on several criteria; counts, time etc.\n\nThis differs from buffer() in that the underlying observables will all onComplete()\nindependently from their upstream Observable.", "NaN"], ["338", "Extremely rudimentary auto-generated Clojure wrapper. (DO NOT MERGE)", "Dave Ray", "daveray", "10/31/13, 08:28:52 PM", "Proof(?)-of-concept for rxjava issue #334. Please do not merge.", "NaN"], ["341", "Update gradle wrapper to latest", "Justin Ryan", "quidryan", "09/03/13, 08:51:23 PM", "NaN", "NaN"], ["343", "Covariant Support with super/extends and OnSubscribeFunc", "Ben Christensen", "benjchristensen", "09/04/13, 10:43:29 PM", "Merging and adding to work by @jmhofer in https://github.com/Netflix/RxJava/pull/331\n\nIn particular this adds the following change to the previous pull request:\n\n``` java\npublic static <T> Observable<T> create(Func1<? super Observer<? super T>, ? extends Subscription> func)\n```\n\nto\n\n``` java\npublic static <T> Observable<T> create(OnSubscribeFunc<T> func)\n```", "NaN"], ["344", "Update Clojure interop to support new OnSubscribeFunc with rx/fn.", "Dave Ray", "daveray", "09/04/13, 11:14:56 PM", "NaN", "NaN"], ["345", "Remove unnecessary Observable constructor", "Ben Christensen", "benjchristensen", "09/04/13, 11:14:45 PM", "- fixed unit tests that relied on it", "NaN"], ["346", "BlockingObservable Refactor", "Ben Christensen", "benjchristensen", "09/05/13, 01:10:01 AM", "- No longer extends from Observable. If someone chooses to use BlockingObservable the intent is to leave the Observable so it shouldn't show the non-blocking operators.\n- Remove duplicate static methods, similar to how done on Observable in earlier commit.", "NaN"], ["347", "Fixing Scala unit tests after previous commits accidentally broke them", "Ben Christensen", "benjchristensen", "09/05/13, 01:27:08 AM", "NaN", "NaN"], ["348", "switchDo to switchOnNext", "Ben Christensen", "benjchristensen", "09/05/13, 06:44:08 AM", "See https://github.com/Netflix/RxJava/issues/342 for original question.\n\nDoes anyone have an opinion on this?", "NaN"], ["349", "Window Operator", "Ben Christensen", "benjchristensen", "09/05/13, 10:14:03 PM", "Manual merge of https://github.com/Netflix/RxJava/pull/337\n\nSince this pull request was submitted there were significant changes to the `create` operator and generics, so I manually merged into master. I have not actually reviewed for behavior, but unit tests are passing and code structure looked good.\n\nThis is for issue https://github.com/Netflix/RxJava/issues/102?source=c", "NaN"], ["350", "A little Swing wrap-up", "Joachim Hofer", "jmhofer", "09/06/13, 04:34:12 PM", "These are some old changes in the Swing contrib library that wrap up a few loose endings (javadoc warnings, slightly inconsistent behavior for `KEY_TYPED` events, an additional helper for computing relative mouse motion).\n\nI updated this to work with the current master (and fixed a few warnings concerning unused imports and double semicolons). I also checked whether this needs some variance generalizations, but it seems that it doesn't.", "NaN"], ["351", "Fix Observable.window static/instance bug", "Ben Christensen", "benjchristensen", "09/06/13, 04:29:38 PM", "- reported at https://github.com/Netflix/RxJava/pull/349#issuecomment-23946707", "NaN"], ["352", "Adding Func5-9 and N to the wrapper", "George Campbell", "abersnaze", "09/06/13, 07:02:36 PM", "the zip(Collection, FuncN) isn't working in groovy because the function wrapper doesn't implement FuncN", "NaN"], ["353", "Take Operator Error Handling", "Ben Christensen", "benjchristensen", "09/07/13, 07:05:51 AM", "Unit test for https://github.com/Netflix/RxJava/issues/217", "NaN"], ["354", "Count, Sum, Average implementations", "Joachim Hofer", "jmhofer", "09/09/13, 04:52:15 PM", "I implemented three easy  operations here simply using `reduce`.\n\nTwo things were tricky however:\n1. How to name the various \"overloads\" (have to use different names due to identical erasure). I propose `sum`, `sumLongs`, `sumFloats`, `sumDoubles` here (and the same for the averages).\n2. How to handle empty source observables when averaging. I propose throwing an `ArithmeticException` here.\n\nAny other opinions?", "NaN"], ["355", "implemented skipWhile and skipWhileWithIndex (#80)", "Joachim Hofer", "jmhofer", "09/09/13, 04:53:07 PM", "The title says it all already.", "NaN"], ["356", "Added interval methods to Observable, where they were still missing", "Joachim Hofer", "jmhofer", "09/09/13, 04:53:56 PM", "This was simply missing and forgotten in #55.", "NaN"], ["357", "Implemented \"First\" and \"FirstOrDefault\" operations", "Joachim Hofer", "jmhofer", "09/10/13, 01:06:10 AM", "This PR builds upon the `skipWhile`  PR (#355) which makes implementing the two `first` variants extremely easy.\n\nI changed `firstOrDefault` slightly from what Rx.NET does by explicitly requiring a default value as parameter of the function call. I don't know what default value I should return otherwise, except `null` (and imho this would be pretty useless).\n\nThis PR addresses issue #44.", "NaN"], ["361", "Fix vararg issues reported in https://github.com/Netflix/RxJava/issues/359", "Ben Christensen", "benjchristensen", "09/10/13, 12:54:16 AM", "Branch working on https://github.com/Netflix/RxJava/issues/359\n\nI'll continue committing to this until all the varargs are replaced.", "NaN"], ["362", "Merge 'first' Operator", "Ben Christensen", "benjchristensen", "09/10/13, 01:05:58 AM", "Merge pull request https://github.com/Netflix/RxJava/pull/357 with `first` and `firstOrDefault` operators.", "NaN"], ["363", "unit tests for covariance", "Ben Christensen", "benjchristensen", "09/10/13, 01:47:55 AM", "- refactoring so not everything for the entire Observable ends up in a single class", "NaN"], ["364", "additions to tests", "Ben Christensen", "benjchristensen", "09/10/13, 02:39:26 AM", "NaN", "NaN"], ["365", "Operation throttleLast", "Ben Christensen", "benjchristensen", "09/10/13, 08:04:30 PM", "Merge of https://github.com/Netflix/RxJava/pull/258", "NaN"], ["366", "Operator: throttleWithTimeout", "Ben Christensen", "benjchristensen", "09/10/13, 08:04:38 PM", "Another take on `throttle` \u2026 I believe this matches Rx.Net behavior.\n\nThis will wait until timeout value has passed without any further values before emitting the received value.", "NaN"], ["367", "Operator: throttleFirst", "Ben Christensen", "benjchristensen", "09/10/13, 08:04:21 PM", "Another take on `throttle` \u2026 this delivers the first value in each window.", "NaN"], ["368", "Operators: Throttle and Debounce", "Ben Christensen", "benjchristensen", "09/11/13, 04:53:16 PM", "This adds `throttleFirst`, `throttleLast` (alias of `sample`) and `debounce` (aliased with `throttleWithTimeout`).\n\nThis merges pull request https://github.com/Netflix/RxJava/pull/258.\n\nUnfortunately the Rx `throttle` operator behavior is actually `debounce`, not `throttle`. This pull request tries to address that.\n\nHere is a good place to get a description of `throttle` versus `debounce`: http://drupalmotion.com/article/debounce-and-throttle-visual-explanation\n\n> Debounce: Think of it as \"grouping multiple events in one\". Imagine that you go home, enter in the elevator, doors are closing... and suddenly your neighbor appears in the hall and tries to jump on the elevator. Be polite! and open the doors for him: you are debouncing the elevator departure. Consider that the same situation can happen again with a third person, and so on... probably delaying the departure several minutes.\n> \n> Throttle: Think of it as a valve, it regulates the flow of the executions. We can determine the maximum number of times a function can be called in certain time. So in the elevator analogy.. you are polite enough to let people in for 10 secs, but once that delay passes, you must go!\n\nOther links includes:\n- http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n- http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/\n\nI feel we need some kind of `throttle*` operator name as an alias to `debounce` to help people discover it, especially those coming from Rx.Net or RxJS. I'm not fond of `throttleWithTimeout` which is what I have it as right now. Perhaps `throttleViaDebounce` even though that doesn't actually make sense? \n\nI do not want to use `throttle` because it's not actually the definition of `throttle`. To confirm this I have asked over a dozen server-side engineers what their definition of `throttle` is and their expectations of an operator is. It never matches the Rx definition and they are always surprised by the `debounce` behavior.\n\nI have included `throttleLast` as an alias to `sample` so that as people start typing `throttle...` it prompts them for the different options and discoverability will be improved instead of knowing to go look for `sample`.\n\nThe `throttleFirst` operator is included as an efficient approach to throttling tht does not involve ticking time, intervals or buffering in any way. It simply allows an `onNext` value through if the last `onNext` event was greater than X time units ago. All others are discarded. This matches server-side throttling expectations and is limited overhead.\n\nQuestions:\n\n1) Is there a better name for `throttleWithTimeout` as an alias to `debounce`?\n2) Does the documentation sufficiently explain the different strategies?\n3) If ambitious in your review, does anyone see concurrency bugs?", "NaN"], ["369", "Remove covariance of scan/reduce", "Ben Christensen", "benjchristensen", "09/11/13, 04:52:56 PM", "Remove covariance of scan/reduce since consumer/producer are the same <T, T, T>\n\nSee https://github.com/Netflix/RxJava/issues/360#issuecomment-24203016", "NaN"], ["370", "Change zip method signature from Collection to Iterable", "Ben Christensen", "benjchristensen", "09/11/13, 04:52:23 AM", "Fix javadoc typos.", "NaN"], ["371", "Operator: Retry", "Ben Christensen", "benjchristensen", "09/11/13, 06:18:58 AM", "https://github.com/Netflix/RxJava/issues/72", "NaN"], ["373", "a few warnings, javadoc, and one missing scheduler parameter", "Joachim Hofer", "jmhofer", "09/13/13, 03:20:09 AM", "This is just a quick fix for #368 according to @samuelgruetter's comments.\n\nI also removed a few unnecessary `@SuppressWarnings(\"unchecked\")` and one unnecessary semicolon.", "NaN"], ["374", "Implemented distinctUntilChanged operation", "Joachim Hofer", "jmhofer", "09/13/13, 03:22:34 AM", "This is the implementation for `distinctUntilChanged` as described in #39.\n\nI haven't implemented the two methods from .NET that are using an `IEqualityComparator` because I don't think it would be idiomatic Java to define an interface like this and use that here. - Or does somebody want that?", "NaN"], ["375", "Implemented `distinct` operator", "Joachim Hofer", "jmhofer", "09/13/13, 03:35:35 AM", "This PR implements `distinct`, as speficied by #38. \n\nAgain, I haven't implemented the .NET methods taking an `IEqualityComparator` (see #374).", "NaN"], ["376", "Idiomatic Scala Adaptor", "Samuel Gruetter", "samuelgruetter", "09/13/13, 03:19:17 AM", "This is a first pull request for https://github.com/Netflix/RxJava/issues/336 . The Scala Adaptor is still far from being finished (see TODOs in `language-adaptors/rxjava-scala/TODO.md`), but I think it's in a state where it can be merged in so that people can try it out and give feedback.", "NaN"], ["377", "Distinct operator", "Ben Christensen", "benjchristensen", "09/13/13, 03:35:34 AM", "Merging https://github.com/Netflix/RxJava/pull/375", "NaN"], ["378", "UnitTests while working on EventStream use cases", "Ben Christensen", "benjchristensen", "09/13/13, 03:42:01 AM", "NaN", "NaN"], ["379", "Make `interval` work with multiple subscribers", "Joachim Hofer", "jmhofer", "09/13/13, 04:39:10 PM", "As per @samuelgruetter's comments in #55, I added some tests against `interval` together with multiple subscribers, and then proceeded to fix the behavior by wrapping it in another subscription function.\n\nI hope it's ok now.", "NaN"], ["380", "Implemented `distinct` and `distinctUntilChanged` variants using a comparator", "Joachim Hofer", "jmhofer", "09/13/13, 04:44:09 PM", "As @abersnaze and @benjchristensen both agreed (see the #374 discussion) that they'd like the comparator versions of these two operations, too, I implemented them here.", "NaN"], ["381", "Implemented `mapWithIndex`", "Joachim Hofer", "jmhofer", "09/14/13, 03:37:10 PM", "As requested by @samuelgruetter in #372.", "NaN"], ["382", "Removing deprecated RxImplicits from rxjava-scala", "Matt Jacobs", "mattrjacobs", "09/18/13, 05:31:32 AM", "Now that @samuelgruetter's work on a value class implementation of Scala Observable has been merged, no need for the standalone `RxImplicits`", "NaN"], ["384", "Implemented the `delay` operator", "Joachim Hofer", "jmhofer", "12/11/13, 06:09:11 AM", "This implements the operator from #36 in all four variants.\n\nThe tests also found a bug in `interval` that I fixed.\n\nMaybe this is a bug of `map` though - `map` throws exceptions in `onNext`, not sure if it should be allowed to do that - the `SafeObserver` that it relies on comes too late for scheduled actions. However, this can be discussed and fixed independently.", "NaN"], ["385", "Implemented the 'any' operator", "Shixiong Zhu", "zsxwing", "09/21/13, 08:31:37 PM", "This implements the operator `Any` from #24 in all two variants.\n\nHowever, I encountered two problems.\n\nUpdated: the online document http://msdn.microsoft.com/en-us/library/hh211993(v=vs.103).aspx is wrong. See my later discussion.\n\nAnother question is if I add the `any` method to `rx.Observable<T>`, some unit tests will fail as the method `any` in  `rx.Observable<T>` overrides the method `org.mockito.Matchers.any(java.lang.Class<T>)` in some unit tests (e.g., `rx.subjects.ReplaySubject<T>`). Do I need to use another method name, or just modify the unit tests? Now the `any` methods in `rx.Observable<T>` are commented out.\n\nThanks.", "NaN"], ["389", "Scala Adaptor Improvements", "Samuel Gruetter", "samuelgruetter", "09/18/13, 05:27:48 AM", "Includes groupBy, scala README, examples, moving ImplicitFunctionConversions out of internal package, multicast, publish, replay, and methods for BlockingObservable.\n\nNote that the commit https://github.com/samuelgruetter/RxJava/commit/ac26e42d1e85deac0b7bfa50c3ca3e5298493dd4 modifies core by making the Java `Subject<T, R>` used as contravariant in `T` and covariant in `R`, which allows me to write Scala's multicast without typecasting.", "NaN"], ["390", "Implemented the 'elementAt' and 'elementAtOrDefault' operators. see #41", "Shixiong Zhu", "zsxwing", "09/21/13, 08:40:00 PM", "Hi,\n\nThis implements the `ElementAt` and `ElementAtOrDefault` operators from #41.\n\nFor `ElementAt`, if the index is less than 0, or greater than or equal to the number of elements in the source sequence, an IndexOutOfBoundsException will be threw.\n\nFor `ElementAtOrDefault`,  if the index is less than 0, an IndexOutOfBoundsException will be threw. What's more, I added a `defaultValue` parameter. I can not get the element type in the source observable due to type erasure. So I can not determine the default value automatically. That's why `ElementAtOrDefault` needs  a `defaultValue` parameter.", "NaN"], ["391", "remove scalatest packages from OSGI imports", "Brad", "brad-uk", "09/19/13, 04:54:33 AM", "NaN", "NaN"], ["393", "Parallel Operator & ObserveOn/ScheduledObserver Fixes", "Ben Christensen", "benjchristensen", "09/19/13, 05:07:06 AM", "#### Parallel Operator\n\nThis operator came out of discussions and work with @headinthebox to allow explicit and composable declaration of blocks of work that can be scheduled for parallel execution.\n\nAn Observable event stream will be sharded using groupBy using a value from Scheduler. degreeOfParallelism() (defaulting to number of CPU cores) and perform the defined work in parallel.\n\nInstead of having various parallel operators like parallelMap, parallelFilter parallelScan etc this can work generically for any operators or sequence of operators.\n#### Fix ObserveOn, NewThreadScheduler and ScheduledObserver bugs\n\n@headinthebox and I were working on some code and found differences in behavior between Rx.Net and RxJava with observeOn. This commit should fix that.", "NaN"], ["394", "Change Interval and Sample default Scheduler", "Ben Christensen", "benjchristensen", "09/19/13, 05:07:51 AM", "Change to use built-in thread-pools rather than creating a new Executor on each invocation.\nThe built-in ones are shared across all operators, have threads ready, are marked as daemon threads so don't prevent system shutdown, and are named for clarity when looking at thread dumps and debuggers.\n\nThis fixes https://github.com/Netflix/RxJava/issues/388", "NaN"], ["396", "Add missing methods to Scala Adaptor", "Samuel Gruetter", "samuelgruetter", "09/21/13, 07:05:18 AM", "This pull request adds a method to the Scala Observable for each method in the Java Observable. Some were renamed, have a different signature, or were left out intentionally. A comparison can be found [here](https://github.com/samuelgruetter/rx-playground/wiki/Comparison-of-Scala-Observable-and-Java-Observable). \n\nThe Scala Observable should now be complete, but there are still some [TODOs](https://github.com/samuelgruetter/RxJava/blob/a2ab731ce1a867e1a2902c27062bcea2923ef303/language-adaptors/rxjava-scala/TODO.md).\n\nThere should be no breaking changes, but only additions.\n\nThere's also an automatic completeness test (`rx.lang.scala.CompletenessTest`). If methods are missing, it still succeeds, but it prints the missing methods to stdout.", "NaN"], ["397", "Observable API for Apache HttpAsyncClient 4.0", "Ben Christensen", "benjchristensen", "09/21/13, 09:05:36 PM", "This is still experimental, I have not used it for any significant load or production traffic.", "NaN"], ["398", "Merge 'any' Pull Request", "Ben Christensen", "benjchristensen", "09/21/13, 08:31:36 PM", "Merges pull https://github.com/Netflix/RxJava/pull/385\n\nI changed `any` to `isEmpty` and `exists` as I agree with @samuelgruetter comment at https://github.com/Netflix/RxJava/pull/385#issuecomment-24568332. These names feel more idiomatic to Java languages.", "NaN"], ["399", "Merge Pull #390 - elementAt", "Ben Christensen", "benjchristensen", "09/21/13, 08:39:59 PM", "Merge pull https://github.com/Netflix/RxJava/pull/390", "NaN"], ["400", "Removing 'comparator` overloads of `distinct`", "Ben Christensen", "benjchristensen", "09/21/13, 09:11:02 PM", "Removing these fairly recently added overloads as they turn out to not be the best approach.\n\nDiscussion ongoing as to how to implement them at https://github.com/Netflix/RxJava/issues/395", "NaN"], ["401", "Implemented the 'DefaultIfEmpty' operator. See #34", "Shixiong Zhu", "zsxwing", "09/25/13, 06:24:32 PM", "Hi,\n\nThis implements the `DefaultIfEmpty` operator from #34.\n\nThere are two variants. However, I can not get the element type in the source observable due to type erasure. So I only implemented the variant with a default value: http://msdn.microsoft.com/en-us/library/hh229624(v=vs.103).aspx\n\nPlease take a look. Thanks.", "NaN"], ["402", "Fixes to rxjava-apache-http", "Ben Christensen", "benjchristensen", "09/22/13, 04:27:26 AM", "- made Content-Type inspection more reliable\n- other small improvments", "NaN"], ["403", "Implemented the 'cast' and 'ofType' operators", "Shixiong Zhu", "zsxwing", "09/25/13, 06:28:55 PM", "Hi,\n\nI used 'map' to implement the 'cast' operator #26. I also used 'cast' to implement the 'ofType' operator #67.\nPlease take a look. Thanks!", "NaN"], ["404", "Add fromChangeEvents methods to SwingObservable", "Samuel Gruetter", "samuelgruetter", "11/22/13, 08:38:54 PM", "For swing components which fire `ChangeEvent`s, I added a method `SwingObservable.fromChangeEvents`, similar to the other methods of `SwingObservable`. \n\nUnfortunately, there is no common base interface for all components which fire `ChangeEvents`s, so I created one myself: `ChangeEventSource.ChangeEventComponentWrapper`.\n\nThen, each component which fires `ChangeEvents`s needs its own overload in `SwingObservable`.\n\nAn other approach would be to use reflection, but then we loose typesafety.", "NaN"], ["407", "Implemented RefCount Operator", "John Marks", "johnhmarks", "10/09/13, 05:45:15 AM", "Please note that I placed the unit tests under the test root rather than inline with the implementation as has been done for other operators.  This is due to a bug in IDEA that prohibits running unit tests in folders designated as source rather than test.  I can see that a bunch of other operators follow this convention so hopefully that's okay.", "NaN"], ["408", "Do not run RxScalaDemo on each build", "Samuel Gruetter", "samuelgruetter", "09/25/13, 06:04:42 PM", "On my last pull request, I forgot to uncomment the line which ignores `RxScalaDemo`, so currently it is executed on each build, even though it does no automatic testing. And since `RxScalaDemo` takes about 48 seconds, this significantly increases build time. Sorry for this...\n\nAfter this change, the complete build took 3 mins 33.932 secs on my 3 years old laptop, so if cloudbees can't build it in 10 min, there might be something else not properly working...", "NaN"], ["409", "Implemented 'Synchronize' with 'lock'", "Shixiong Zhu", "zsxwing", "09/25/13, 06:03:16 PM", "Hi,\n\nI implemented #84 to support that sending a lock to the `synchronize` operator.\n\nI also found that there was a issue that `testMultiThreadedWithNPE` and `testMultiThreadedWithNPEinMiddle` might fail in some special situation. When `onError` is invoked before any `onNext`, the last statement `assertEquals(1, busyObserver.maxConcurrentThreads.get());` in these methods will fail. I also fixed this issue in the pull request.", "NaN"], ["410", "Implemented the 'Contains' operator", "Shixiong Zhu", "zsxwing", "10/09/13, 05:46:56 AM", "Hi, I implemented the `Contains` operator #31. I saw the discussion about the `distinct` operator #395, so I did not implement the comparator override. Please take a look. Thanks!", "NaN"], ["411", "update counter before triggering latch", "Peter McDonnell", "petermd", "10/09/13, 05:47:27 AM", "as mentioned in #383\n\nrx.concurrency.TestSchedulers.testSchedulingWithDueTime\n\nis flaky because there is a race-condition where the test can assert the counter value before it is updated. fix is just to update the counter before releasing the latch.", "NaN"], ["413", "Fixed the issues of takeLast(items, 0) and null values", "Shixiong Zhu", "zsxwing", "10/09/13, 05:50:01 AM", "Hi,\n\nThere are two issues about `takeLast` #85 #140. The essential cause is `LinkedBlockingDeque`.\n1. count == 0\n   `takeLast` in RxJava will throw an exception when count == 0, as `LinkedBlockingDeque` rejects count <= 0. However, in c#, TakeLast with 0 count is valid. The following codes is OK in C# (no exception and do nothing):\n\n``` c#\n            var source = Observable.Return(1).TakeLast(0);\n            source.Subscribe(\n                x => \n                    Console.WriteLine(\"subscriber got \" + x)\n            );\n            Console.ReadLine();\n```\n1. null values\n   LinkedBlockingDeque requires the elements can not be null but an observable can emit a null value.\n\nI used `ReentrantLock` and `LinkedList` to replace `LinkedBlockingDeque`. Please take a look. Thanks.", "NaN"], ["414", "Implemented the 'SkipLast' operator", "Shixiong Zhu", "zsxwing", "10/09/13, 05:54:28 AM", "Hi,\n\nI implemented the `skipLast` operator #78.  I used `ReentrantLock` and `LinkedList` to implement it rather than `LinkedBlockingDeque` like `takeLast` #85 #140 for two reasons.\n- LinkedBlockingDeque requires that count is greater than 0 but `skipLast` can accept 0. \n- LinkedBlockingDeque requires the elements can not be null but an observable can emit a null value.\n\nIn summary, `LinkedBlockingDeque` will cause issues like #413.\n\nPlease take a look. Thanks.", "NaN"], ["415", "Implemented the 'Empty' operator with scheduler", "Shixiong Zhu", "zsxwing", "10/09/13, 05:55:29 AM", "Hi,\n\nI implemented the 'Empty' operator with scheduler #42. Please take a look. Thanks.", "NaN"], ["416", "Implemented the 'Throw' operator with scheduler", "Shixiong Zhu", "zsxwing", "10/09/13, 08:52:32 PM", "Hi,\n\nI implemented the `Throw` operator #89 with scheduler. I found that RxJava had an `error` method. So I just implemented the scheduler overload.", "NaN"], ["420", "Scala Adaptor", "Samuel Gruetter", "samuelgruetter", "10/09/13, 06:00:36 AM", "Here are more improvements to the Scala adaptor, mostly changes in classes other than `rx.lang.scala.Observable` itself, as well as scaladoc for all classes. And the `MovieLib` example is now part of the `rxjava-scala` project instead of being a seperate project.", "NaN"], ["421", "Adding collect method to Scala Observable", "Marius Danila", "madnl", "10/31/13, 08:30:51 PM", "I think it's a good idea to add a `collect` method analogous with the one in the Scala collection library. It was simplest to implement it using a combination of `filter` & `map`.\n\nIf you find any major disadvantages with this please chime in.", "NaN"], ["422", "JRuby function wrapping support", "Mike Ragalie", "ragalie", "10/09/13, 06:08:47 AM", "This PR fixes #320 by implementing JRuby wrappers for RxJava-specific function interfaces. Given a set of method signatures for a Java method, JRuby will select the signature that best matches the Ruby arguments provided and wrap each argument in a proxy that implements the correct Java interface.\n\nOccasionally JRuby will be unable to unambiguously select one method signature over another, and will either a) select the correct signature, but report that there was ambiguity in the method signatures or b) select the wrong signature and fail.\n\nBy explicitly wrapping `Proc` arguments into wrappers that implement the correct RxJava interface, JRuby will always select the correct method signature and will not need to wrap the argument in a proxy, increasing both correctness and performance.", "NaN"], ["424", "Implemented the 'IgnoreElements' operator", "Shixiong Zhu", "zsxwing", "10/09/13, 08:11:05 PM", "Hi,\n\nI implemented the `IgnoreElements` operator #54. Please take a look. Thanks.", "NaN"], ["425", "Manual Merge of Pull Request #407", "Ben Christensen", "benjchristensen", "10/09/13, 05:45:14 AM", "Added a unit test to #407 while testing it. ", "NaN"], ["426", "PublishSubject ReSubscribe for publish().refCount() Behavior", "Ben Christensen", "benjchristensen", "10/09/13, 08:52:53 PM", "Allow `publish` + `refCount` to support re-subscribing to the origin after decrementing the count to 0 then adding new Observers which increment count to 1+.\n\nThe PublishSubject implementation was performing onError/onCompleted unsubscribe logic that was put in place long ago and I am now pretty sure it was wrong.\n\nThis was revealed while playing with `refCount` which intends on allowing a re-subscription to the source once new Observers arrive. PublishSubject was preventing that.\n\nThe one use case that I'm still wondering about though is if someone subscribes to a PublishSubject after it has emitted onCompleted and isn't \"restarted\". That Observer would wait forever if it is a \"single-shot\" PublishSubject use case. I'm not sure if that's just a bad use and fits into the \"don't do that\" scenario, or if it's a legit issue that has a solution.\n\nRight now this code is \"thread-safe\" in the visibility sense, but it's not atomic and could have race conditions between adding/removing Observers and event notifications. I don't think that's an issue as if someone is concurrently adding/removing it's always a race, but am not 100% sure if there's a use case I'm missing. This also assumes (as it always did) that someone is not invoking onNext concurrently as that would break the Rx contract.", "NaN"], ["427", "[RFC] Initial implementation of OperationObserveInForeground (Android)", "Matthias K\u00e4ppler", "mttkay", "10/09/13, 08:49:36 PM", "In reference to the discussion in [0] and our work with RxJava on Android, here is an initial attempt at providing an Rx operator which wraps the boilerplate required to observe sequences on Android UI components like Fragments and Activities (although I should mention that I haven't added support for the latter yet but focused on Fragments from the support-v4 library.)\n\nHere's what I did:\n- provide an operator which accepts a specialized observer type that is able to expose a Fragment reference. This is essential for us to decide whether it's safe to forward messages to that fragment, and we can only ask the fragment itself to make that decision\n- schedule observer callbacks on the Android UI thread by default\n\nThere is some discussions to be had around this. I would really appreciate if everyone with and without Android experience could weigh in. Specific questions I think need discussing:\n- I am terminating the sequence early if the caller does not subscribe using one of the specialized Observer types I provide (`FragmentObserver` or `SupportFragmentObserver` for native and back-compat fragments respectively). As mentioned above, I must force the caller to give me a reference to the fragment, since otherwise callbacks cannot be executed in a safe manner (safe w.r.t. not calling back in case Android decided to remove the fragment from the window; this is a life-cycle event in Android which cannot be intercepted other than asking the fragment whether it's still attached or not). I realize this has a smell to it, but I don't see another option.\n- the specialized observer class keeps weak references to the source observer and the fragment (both can be the same object, but then again, could also not if e.g. you use inner classes as observers). In case the references got cleared, messages will be dropped\n- Naming: observeInForeground is the best I could come up with, which doesn't mean much :-) Feel free to submit better naming suggestions\n\nTODO:\n- Implement native `FragmentObserver` in the same manner as `SupportFragmentObserver` (the latter is what we need so I built that one first)\n- Add `ActivityObserver` in the same manner\n- Think about auto-unsubscribing from the source sequence in case the references got cleared\n\n[0] https://groups.google.com/forum/?fromgroups=#!topic/rxjava/7o_NJw36Enw", "NaN"], ["430", "Fixed issue #428", "Shixiong Zhu", "zsxwing", "10/16/13, 05:29:43 AM", "I fixed the issue #428. This issus is because the wrong order of `unsubscribe` and `emitChunk`.\n\n`unsubscribe` will cancel the Future, and the currrent thread's interrupt status will be set. If `unsubscribe` is called before `emitChunk`, the currrent thread's interrupt status has already set before `emitChunk`. It may confuse users when they have some codes depending on the interrupt status.\n\nI put `emitChunk` before `unsubscribe` and added a unit test for it.", "NaN"], ["432", "Fixed path to RxScalaDemo.scala", null, "codecurve", "10/16/13, 05:21:46 AM", "NaN", "NaN"], ["433", "Fixed testOnErrorViaHasNext in issue #383", "Shixiong Zhu", "zsxwing", "10/31/13, 08:28:23 PM", "Hi,\n\nThis PR fixed the issue that `testOnErrorViaHasNext` fails sometimes. It only tries to avoid the failure of unit tests.\nHowever, there is still an issue in the `next` operator. The `hasNext` may return true, but the later `next` throws `IllegalStateException(\"Observable is completed\")`. An example unit test throws `IllegalStateException`:\n\n``` java\n        @Test\n        public void test() {\n            Subject<String, String> obs = PublishSubject.create();\n            Iterator<String> it = next(obs).iterator();\n            assertTrue(it.hasNext());\n            obs.onCompleted();\n            it.next();\n        }\n```\n\nI think @abersnaze is right. \n\n> hasNext should block until either the onNext or onComplete has been called.", "NaN"], ["434", "Implemented SerialSubscription and Timeout operator", "John Marks", "johnhmarks", "10/22/13, 07:38:33 PM", "Implemented Timeout operator and SerialSubscription upon which it is based.", "NaN"], ["435", "rx-apache-http recognizes \"Transfer-Encoding: chunked\" as an HTTP stream", "Matt Jacobs", "mattrjacobs", "10/16/13, 05:59:28 AM", "Uses the same infrastructure already in place for \"Content-Type: text/event-stream\" for HTTP response with chunked encoding.  Works with Twitter Streaming API", "NaN"], ["436", "Reimplemented the 'reduce' operator", "Shixiong Zhu", "zsxwing", "11/08/13, 03:19:15 AM", "Hi,\n\nI reimplemented the 'reduce' operator. The improvements are as follow:\n- As I mentioned in #423, 'reduce' should throw an exception when applying on an empty sequence without an initial value.\n- Now 'reduce' does not need a 'takeLast' operator, and should be more efficient.", "NaN"], ["437", "Fixes: Scheduler and Merge", "Ben Christensen", "benjchristensen", "10/16/13, 06:23:16 AM", "1) Scheduler overload with recursive support\n\nFixed while working with @headinthebox \n\n2) unsubscribe was not propagating to parent Observable on merge(Observable<Observable<T>>)\n\nFound and fixed while working with infinite streams. Merge was correctly unsubscribing from all children which means it was always working when doing something like `merge(a, b)`, but it wasn't correctly unsubscribing if given a single `Observable<Observable<T>>`", "NaN"], ["438", "Kotlin Language Adaptor", "Mario Arias", "MarioAriasC", "10/17/13, 02:20:27 AM", "Kotlin could be used with RxJava without language adaptors.\n\nThis language adaptor just provide a set of extension functions to enable a more idiomatic usage.  \n\nThere are two test classes:\n- BasicKotlinTest is just plain Kotlin\n- ExtensionTest is Kotlin with the extensions provided by this adaptor  ", "NaN"], ["440", "libGDX support", "Joachim Hofer", "jmhofer", "10/31/13, 08:27:09 PM", "This is the start of a new contrib project that lays the foundation for RxJava support for **[libGDX](http://libgdx.badlogicgames.com/)**.\n\nThis is still missing tests because it's very difficult to unit test this properly due to the nature of libGDX. However, I'll be using this a lot in my own Android projects.\n\nI'm not sure whether this should be a contrib subproject of RxJava or maybe a separate repo. If you think this should be separate, just decline the PR.", "NaN"], ["441", "Fixed the issue that 'take' does not call 'onError'", "Shixiong Zhu", "zsxwing", "10/22/13, 07:35:14 PM", "I fixed one of the issues in #417: `System.out.println(Observable.from(1, 2, 3).take(1).map(f).toBlockingObservable().single());` is never terminated.\n\nThis issues is because `take` does not handle the exception throwing from `onNext` correctly.", "NaN"], ["443", "OperationSwitch notify onComplete() too early.", "Yannick Lecaillez", "ylecaillez", "10/22/13, 07:36:17 PM", "OperationSwitch has to wait that both parent and child complete before complete itself.", "NaN"], ["446", "Implemented the 'Timeout' operator", "Shixiong Zhu", "zsxwing", "10/31/13, 08:26:30 PM", "Hi, I used `SynchronizedObserver` to implement the `Timeout` operator #91. It may be simpler than #434. Considering DateTimeOffset and TimeSpan in C# have the same meaning, RxJava only needs 4 overrides. I have already implemented all of them.\n\nPlease take a look. Thanks.", "NaN"], ["447", "Caching the result of 'isInternalImplementation'", "Matt Jacobs", "mattrjacobs", "10/22/13, 07:52:54 PM", "Currently, reflective getPackage() call happens on every subscribe() invocation.  This PR sets up a Concurrent HashMap to cache the result of this call per-class.", "NaN"], ["449", "Removing println from OperationMerge", "Matt Jacobs", "mattrjacobs", "10/23/13, 11:36:09 PM", "NaN", "NaN"], ["450", "Implemented the 'TimeInterval' operator", "Shixiong Zhu", "zsxwing", "10/31/13, 07:19:24 PM", "Hi, this PR implemented the `TimeInterval` operator #90. Please take a look. Thanks.", "NaN"], ["452", "Implemented the scheduler version of the 'Return' operator", "Shixiong Zhu", "zsxwing", "10/31/13, 08:26:19 PM", "Hi, this is the scheduler version of the 'Return' operator #73.", "NaN"], ["453", "Fixed issue #417", "Shixiong Zhu", "zsxwing", "10/31/13, 07:17:48 PM", "``` java\npublic static void main(String[] args) {\n    System.out.println(\"started\");\n    System.out.println(Observable.from(1).observeOn(Schedulers.threadPoolForComputation())\n        .map(f).toBlockingObservable().single());\n    System.out.println(\"done\");\n}\n```\n\nThis issue in #417 is because current `map` implementation violates the design guild:\n\n> 6.4. Protect calls to user code from within an operator\n\nNow current `map` does not handle the error from the `func` param which may be user codes. When the thread pool scheduler is involved, the error from `func` will throw to the outside and be handled by `java.util.concurrent.FutureTask`. The error will be dropped so the observer will not see it.\n\nThis PR used `SafeObserver` to protect `map` from user codes.", "NaN"], ["455", "Scala Adaptor: TODO list and documentation", "Samuel Gruetter", "samuelgruetter", "10/31/13, 07:16:26 PM", "More complete TODO list for Scala Adaptor and some documentation for [CompletenessTest](https://github.com/samuelgruetter/RxJava/blob/scalaadaptor/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala).", "NaN"], ["457", "Adding utility functions for observables of strings useful for processing non blocking IO.", "George Campbell", "abersnaze", "11/22/13, 11:51:07 PM", "I started developing this for use with the rxjava-apache-http contrib module to safely and scalable decode infinite observables of byte arrays into strings but thought it should live in core because it could be useful for non blocking disk IO.\n\nI did not make this part of rx.Observable because these operators only work on observables of string.  The drawback is that discoverability will be harder.", "NaN"], ["458", "[rxjava-android] OperationObserveFromAndroidComponent", "Matthias K\u00e4ppler", "mttkay", "10/31/13, 07:16:04 PM", "This is in reference to https://github.com/soundcloud/RxJava/issues/1\n\nAndroid applications can use this operator to safely observe a source sequence on the main user interface thread. As long as the subscription is unsubscribed from in `onDestroy` or `onDetach`, no resource leaks will occur.\n\nI have also added an `AndroidObservable` class which acts as an entry point for instantiating Android specific observer instances.", "NaN"], ["459", "Fixed issue #454", "Shixiong Zhu", "zsxwing", "10/31/13, 07:14:33 PM", "Hi, I used SafeObservableSubscription to fix the issue #454.", "NaN"], ["460", "Implemented the 'Amb' operator", "Shixiong Zhu", "zsxwing", "11/05/13, 04:17:33 AM", "Hi, this PR implemented the `Amb` operator #22. I used varargs to support the array version and first-second version in one method. So in my PR, there are only two variants.", "NaN"], ["461", "Added 'sleep' to avoid 'testMapWithErrorInFuncAndThreadPoolScheduler' fails", "Shixiong Zhu", "zsxwing", "11/08/13, 03:17:45 AM", "Hi, due to my mistake, `testMapWithErrorInFuncAndThreadPoolScheduler` may fail in some situation. Sorry for that. I fixed it in this PR.", "NaN"], ["463", "Added the rest overloads of Timeout operator", "Shixiong Zhu", "zsxwing", "11/12/13, 11:00:18 PM", "Hi, this PR implemented the rest overloads of `Timeout` operator #91. Please take a look. Thanks.", "NaN"], ["465", "Moving unit tests to test source folders #439", "Pedro Antonio Souza Viegas", "pasviegas", "11/05/13, 04:10:49 AM", "NaN", "NaN"], ["466", "Refactor Unit Tests from Inner Classes to /src/test", "Ben Christensen", "benjchristensen", "11/05/13, 04:10:49 AM", "Manual merge of and additions to pull request https://github.com/Netflix/RxJava/pull/465 to refactor unit tests from inner classes to separate /src/test/ folder to accomplish issue https://github.com/Netflix/RxJava/issues/439  \"minimize library size\".\n\nGreat work by @pasviegas on this pull request!", "NaN"], ["467", "Merge Amb Operator in PR https://github.com/Netflix/RxJava/pull/460", "Ben Christensen", "benjchristensen", "11/05/13, 04:17:32 AM", "Split unit tests out while merging.", "NaN"], ["470", "Operator: Last", "Ben Christensen", "benjchristensen", "11/07/13, 03:27:28 AM", "Adds `Observable.last` and fixes behavior of `BlockingObservable.last` based on email discussion with @headinthebox ", "NaN"], ["471", "Unit Test Tweaks", "Ben Christensen", "benjchristensen", "11/07/13, 04:12:45 AM", "NaN", "NaN"], ["472", "BugFix: Issue 431 Unsubscribe with Schedulers.newThread", "Ben Christensen", "benjchristensen", "11/07/13, 04:49:36 AM", "Fix bug => Unsubscribing does not work when using subscribeOn(Schedulers.newThread())\n\nI believe this fixes https://github.com/Netflix/RxJava/issues/431\n\nThe NewThreadScheduler was not using DiscardableAction that supports being unsubscribed.", "NaN"], ["473", "Fix non-deterministic unit test", "Ben Christensen", "benjchristensen", "11/07/13, 11:14:19 PM", "- the latch was before onError is called\n- use BlockingObservable and expect the IllegalArgumentException to be thrown", "NaN"], ["474", "BugFix: Reduce an empty observable", "Ben Christensen", "benjchristensen", "11/07/13, 11:27:15 PM", "This fixes issue https://github.com/Netflix/RxJava/issues/423\n\nThe fix is based on this comment by @headinthebox: https://github.com/Netflix/RxJava/issues/423#issuecomment-27642532\n\nThank you @zsxwing  for your involvement on this.\n\nIf I have mis-interpreted the results of the discussion and this is still wrong ... please correct me.\n\nHere is the unit test asserting the behavior:\n\n``` java\n    /**\n     * A reduce should fail with an IllegalArgumentException if done on an empty Observable.\n     */\n    @Test(expected = IllegalArgumentException.class)\n    public void testReduceWithEmptyObservable() {\n        Observable<Integer> observable = Observable.range(1, 0);\n        observable.reduce(new Func2<Integer, Integer, Integer>() {\n\n            @Override\n            public Integer call(Integer t1, Integer t2) {\n                return t1 + t2;\n            }\n\n        }).toBlockingObservable().forEach(new Action1<Integer>() {\n\n            @Override\n            public void call(Integer t1) {\n                // do nothing ... we expect an exception instead\n            }\n        });\n\n        fail(\"Expected an exception to be thrown\");\n    }\n```", "NaN"], ["475", "Additional unit test for reduce", "Ben Christensen", "benjchristensen", "11/07/13, 11:32:05 PM", "NaN", "NaN"], ["476", "Don't emit null onComplete when no onNext received in AsyncSubject", "Ben Christensen", "benjchristensen", "11/07/13, 11:45:22 PM", "Reported via email by @axel22 and @headinthebox ", "NaN"], ["477", "CompositeSubscription bugfixes", "Ben Christensen", "benjchristensen", "11/07/13, 11:59:50 PM", "- remove now also unsubscribes the removed subscription\n- added clear method", "NaN"], ["478", "Implemented the \"Operator: Min and MinBy\" and \"Operator: Max and MaxBy\"", "Shixiong Zhu", "zsxwing", "11/12/13, 11:05:37 PM", "Hi, this PR implemented the `Operator: Min and MinBy` #63 and `Operator: Max and MaxBy` #61. Every operator has 2 variants, one for `Comparable`, another for `Comparator`. Please take a look. Thanks!", "NaN"], ["479", "Adds doOnEach operator", "Scott Fleckenstein", "nullstyle", "11/12/13, 11:09:04 PM", "I thought this would be a good and simple way to start getting my feet wet with RxJava.  This implements #40.\n\nAny feedback would be great.\n\nThanks,\nScott", "NaN"], ["480", "BugFix: Emit an IllegalArgumentException instead of ArithmeticException if the observable is empty", "Shixiong Zhu", "zsxwing", "11/12/13, 11:09:57 PM", "This PR fixed the `average` issue in #423. If an observable is empty, `average` will emit an `IllegalArgumentException` instead of `ArithmeticException`. Thanks!", "NaN"], ["481", "Implement the 'Using' operator", "Shixiong Zhu", "zsxwing", "11/12/13, 11:16:12 PM", "Hi, this PR implemented the `Using` operator #99. Please take a look. Thanks! ", "NaN"], ["483", "DoOn Tweaks", "Ben Christensen", "benjchristensen", "11/13/13, 11:36:08 PM", "- do not have 2 method overloads with similar method signatures, dynamic languages can not negotiate method dispatch using function arity\n- add doOnCompleted and doOnError methods instead of different doOnEach overloads\n\nThis is a very slight breaking change by deleting a method added in the last release. I did not catch this when I did the code review.", "NaN"], ["485", "Added  aliases and objects for concrete subject types in Scala.", "Rob Emanuele", "lossyrob", "11/16/13, 05:50:18 AM", "-AsyncSubject[T]\n-BehaviorSubject[T]\n-PublishSubject[T]\n-ReplaySubject[T]", "NaN"], ["486", "BugFix: AsyncSubject", "Ben Christensen", "benjchristensen", "11/16/13, 02:55:45 AM", "- it was not emitting values to observers that subscribed after onCompleted/onError", "NaN"], ["487", "Javadoc improvements", "David Gross", "DavidMGross", "11/20/13, 04:49:06 PM", "Adding marble diagrams, making the javadocs more consistent in their terminology & formatting.", "NaN"], ["490", "Scala Adaptor: Inheritance, subscriptions and subjects", "Samuel Gruetter", "samuelgruetter", "11/19/13, 05:47:01 AM", "I tried to add subscriptions and subjects using the value class trick, and came to the conclusion that it won't work. The problem is that inheritance and value classes don't work together, because value classes cannot be extended. We want Observable to be a value class, and at the same time, we want Subject to extend Observable, so that doesn't work.\n\nThis PR is very similar to [Erik's code](https://github.com/headinthebox/ScalaBindingsRecent), but I added a trait\n\n``` scala\ntrait JavaWrapper[+W] {\n  def asJava: W\n}\n```\n\nwhich all classes extend. This allows us to have an `asJava` method everywhere (instead of `asJavaSubject` / `asJavaObserver` etc). The main challenge was to get the double inheritance Subject extends Observer and Observable working.\nNow all wrappers are done the same way. For instance, Observable looks as follows:\n\n``` scala\ntrait Observable[+T] extends JavaWrapper[rx.Observable[_ <: T]] { \n  ... \n}\n\nobject Observable {\n  private[Observable] class ObservableWrapper[+T](val asJava: rx.Observable[_ <: T]) extends Observable[T] {}\n\n  def apply[T](asJava: rx.Observable[_ <: T]): Observable[T] = {\n    new ObservableWrapper[T](asJava)\n  }\n\n  ...\n}\n```\n\nIn Scala code, to convert from Scala types to Java types, there's the `asJava` method, and to convert from Java types to Scala types, there's an `apply` method in each companion object.\n\nWhen we used value classes, such conversions were not necessary in Java, because Scala types appeared as Java types for the Java compiler. Now, they become necessary, but note that this PR does not yet contain such conversions, but that should be no big problem.", "NaN"], ["491", "Baseline checkin for Android sample app", "Greg Benson", "gbenson-nflx", "11/22/13, 08:28:26 PM", "Began work on a sample Android app to help myself understand Rx as applied to a Java client.  Thought it would be useful for others to see, comment on, improve, and add to.\n\nHave discussed with @mttkay, he has offered to review and possibly contribute as well.\n\n-Greg", "NaN"], ["492", "Implement the scheduler overloads for Range, From, StartWith", "Shixiong Zhu", "zsxwing", "11/19/13, 05:22:22 PM", "Hi, this PR implemented the scheduler overloads for Range #68, From #98 , StartWith #82. Please take a look. Thanks!", "NaN"], ["493", "Zip many from scratch, missing concat of iterable.", "David Karnok", "akarnokd", "11/18/13, 08:16:54 PM", "NaN", "NaN"], ["495", "Zip many rewritten, Concat with iterable, Merge with Iterable.", "David Karnok", "akarnokd", "11/19/13, 05:23:25 PM", "I've rewritten the Zip method to terminate as soon as possible. In addition, the concat(Iterable<Observable<T>> and merge(Iterable<Observable<T>>) where missing from Observable.", "NaN"], ["496", "Add contravariant for min and max", "Shixiong Zhu", "zsxwing", "11/19/13, 04:37:45 AM", "Hi, this PR added  contravariant for min and max mentioned in #494.", "NaN"], ["497", "Zip rewritten from scratch", "David Karnok", "akarnokd", "11/22/13, 08:25:24 PM", "(I hope I managed a clean branch this time...)", "NaN"], ["498", "Implement the 'Repeat' operator", "Shixiong Zhu", "zsxwing", "12/27/13, 09:34:07 PM", "Hi, this PR implemented the `Repeat` operator #70. Please take a look. Thanks!", "NaN"], ["499", "ObserveOn Refactor", "Ben Christensen", "benjchristensen", "11/19/13, 08:24:55 PM", "Refactor and small fixes of ObserveOn with @headinthebox ", "NaN"], ["500", "concat with iterable overload, merge with iterable overload", "David Karnok", "akarnokd", "11/20/13, 07:26:46 AM", "NaN", "NaN"], ["501", "ParallelMerge Operator", "Ben Christensen", "benjchristensen", "11/19/13, 10:07:30 PM", "NaN", "NaN"], ["502", "Fix ObserveOn and add ParallelMerge Scheduler overload", "Ben Christensen", "benjchristensen", "11/20/13, 12:31:38 AM", "- ObserveOn was not correctly recursing when the source was async. It would create a new scheduler (i.e. a new thread) each time.\n- Also added unit tests to ParallelMerge", "NaN"], ["503", "New Scala Bindings", null, "headinthebox", "11/20/13, 01:19:48 AM", "# Alternative Rx bindings for Scala\n\nThe previous RxScala binding attempt to optimize for seamless interop between Scala and Java.\nThe intended interop is illustrated by the following example where in Scala a class is defined that takes\nan `Observable[Movie]` that is transformed using RxScala operators:\n\n``` scala\nclass MovieLib(val moviesStream: Observable[Movie]) {\n   val threshold = 1200\n   def shortMovies: Observable[Movie] = ???\n   def longMovies: Observable[Movie] = ???\n}\n```\n\nwhich is then called in Java, passing a Java `Observable<Movie>` to the constructor\n\n``` java\npublic void test() {\n   MovieLib lib = new MovieLib(Observable.from(...));\n\n   lib.longMovies().subscribe(moviePrinter);\n}\n```\n\nThe technique used to obtain this transparency is to use a value class with a private constructor that implements\nthe Rx operators in an idiomatic Scala way, and a companion object that is used to construct instances in Scala\n\n``` scala\nobject Observable {\n   def apply[T](asJava: rx.Observable[_ <: T]): Observable[T] = { new Observable[T](asJava) }\n}\n\nclass Observable[+T] private[scala] (val asJava: rx.Observable[_ <: T])  extends AnyVal {\n   // Idiomatic Scala friendly definitions of Rx operators\n}\n```\n\nSince `rx.lang.scala.Observable[T] extends AnyVal`, the underlying representation of `rx.lang.scala.Observable[T]`\nis the same as `rx.Observable<T>`. Because `rx.lang.scala.Observable[T]` is an opaque type in Scala,\nthe Scala programmer only sees the Scala-friendly operators.\n\nHowever, in the current the illusion of interop is quickly lost when going beyond this simple example.\nFor example but type `Notification[T]` and `Scheduler[T]` are defined using wrappers,\nand hence they are not compatible with `Notification<T>` respectively `Scheduler<T>`.\nFor instance, when materializing an `Observable[T]` in Scala to an `Observable[Notification[T]]`,\nwe lost the seamless interop with `Observable<Notification<T>>` on the Java side.\n\nHowever, the real problems with seamless interop show up when we try to creating bindings for other Rx types.\nIn particular types that have inheritance or more structure.\n\nFor example, RxScala currently defines a type synonym `type Observer[-T] = rx.Observer[_ >: T]`,\nbut no further bindings for observers.\nSimilarly, for subjects RxScala defines `type Subject[-T, +R] = rx.subjects.Subject[_ >: T, _ <: R]`.\nThe problem with these definitions is that on the Java side, subjects are defined as:\n\n``` scala\npublic abstract class Subject<T, R> extends Observable<R> implements Observer<T> { \u2026}\n```\n\nwithout binding any of the Rx subjects.\n\nThe consequence is that `Subject[S,T]` in Scala is unrelated to `rx.lang.scala.Observable[T]` in Scala,\nbut shows up as a `rx.Observable[T]`. The problem however is that if we want to expose subjects in Scala\nsuch that they derive from both `Observable[S]` and `Observer[T]` we cannot use the `extend AnyVal` trick\nwe used for `Observable[T]` and immediately lose transparent interop with Java.\n\nThe problem is even worse because `AsyncSubject<T>`, `BehaviorSubject<T>`, \u2026 all derive from `Subject<T,T>`,\nso if we want them to derive from a common base `Subject[T,T]` type in Scala we lose transparency for those as well.\nAnd again, if we expose the various subjects by extending `AnyVal`, they are useless in Scala because they do not inherit\nfrom a common base type. To avoid implementing all methods of observable and observer on each specific subject\nwe might add implicit conversions to `Observable[T]` and `Observer[T]` but that still does not give Scala users\na native `Subject[S,T]` type.\n\n``` scala\nobject AsyncSubject {\n    def apply[T](): AsyncSubject[T] =\n      new AsyncSubject[T](rx.subjects.AsyncSubject.create())\n}\n\nclass AsyncSubject[T] private [scala] (val inner: rx.subjects.AsyncSubject[T])\n    extends AnyVal\n{ \u2026 }\n\nimplicit final def asObservable[T](subject: AsyncSubject[T]): Observable[T] =\n  Observable(subject.inner)\n\nimplicit final def asObserver[T](subject: AsyncSubject[T]): Observer[T] =\n  subject.inner\n```\n\nThe inheritance problem is not just limited to subjects, but also surfaces for subscriptions.\nRx scala currently defines `type Subscription = rx.Subscription` using a type synonym as well,\nand we run into exactly the same problems as with subjects when we try to bind the\nvarious Rx subscriptions `BooleanSubscription`, `SerialSubscription`,  etc.\n\nSince we cannot wrap Rx types in Scala such that they are both (a) transparently interoperable with Java,\nand (b) feel native and idiomatic to Scala, we should decide in favor of optimizing RxScala for Scala\nand consumption of Rx values from Java but not for Scala as a producer.\n\nThe new bindings feel like a completely native Scala library, without needing any complications of the Scala side.\n\n``` scala\nobject Observer { \u2026}\ntrait Observable[+T] {\n   def asJavaObservable: rx.Observable[_ <: T]\n}\n\nobject Observer {\u2026}\ntrait Observer[-T] {\n  def asJavaObserver: rx.Observer[_ >: T]\n}\n\nobject Subject {\u2026}\ntrait Subject[-T, +R] extends Observable[R] with Observer[T] {\n  val asJavaSubject: rx.subjects.Subject[_ >: T, _<: R]\n}\n\nobject Scheduler {\u2026}\ntrait Scheduler {\n   def asJavaScheduler: rx.Scheduler;\n}\n\nobject Notification {\u2026}\ntrait Notification[+T] {\n  def asJavaNotification: rx.Notification[_ <: T]\n}\n\nobject Subscription {\u2026}\ntrait Subscription {\n   def asJavaSubscription: rx.Subscription\n}\n```\n\nYou pay the price when crossing the Scala/Java interop boundary, which is where it should be.\nThe proper way is to put the burden of interop on the Scala side, in case you want to create\na reusable Rx-based library in Scala, or wrap and unwrap on the Java side.\n\n``` java\npublic static void main(String[] args) {\n\n   Observable<Movie> movies = Observable.from(new Movie(3000), new Movie(1000), new Movie(2000));\n   MovieLib lib = new MovieLib(toScalaObservable(movies));\n   lib.longMovies().asJavaObservable().subscribe(m ->\n      System.out.println(\"A movie of length \" + m.lengthInSeconds() + \"s\")\n   );\n}\n```\n## Delegation versus Inheritance\n\nThe obvious thought is that using delegation instead of inheritance (http://c2.com/cgi/wiki?DelegationIsInheritance)\nwill lead to excessive wrapping, since all Scala types wrap and delegate to an underlying RxJava implementation.\nNote however, that the wrapping happens at query generation time and incurs no overhead when messages are flowing\nthrough the pipeline. Say we have a query `xs.map(f).filter(p).subscribe(o)`. Even though the Scala types are wrappers,\nthe callback that is registered with xs is something like `x => { val y = f(x); if(p(y)){ o.asJavaObserver.onNext(y) }}`\nand hence there is no additional runtime penalty.", "NaN"], ["504", "Operator: toMap (ToDictionary) and toMultimap (ToLookup)", "David Karnok", "akarnokd", "11/22/13, 09:01:40 PM", "Operators toMap and toMultimap.\n\nI've tried my best to describe them in the Javadoc.", "NaN"], ["505", "ToAsync implemented: Issue #95", "David Karnok", "akarnokd", "11/27/13, 10:28:49 AM", "Added 44 overloads of toAsync.", "NaN"], ["506", "Operators: And, Then, When", "David Karnok", "akarnokd", "11/22/13, 09:00:31 PM", "Issue #23, Issue #88, Issue #100\n\nCan be extended to Plan4..Plan9 and Pattern4..Pattern9 if Action4..Action9 is available. Not sure about the ActionN version.", "NaN"], ["507", "Operation join", "David Karnok", "akarnokd", "11/22/13, 09:30:56 PM", "Issue #56", "NaN"], ["508", "Empty subscribe", "Ben Christensen", "benjchristensen", "11/21/13, 10:21:19 PM", "NaN", "NaN"], ["509", "Operator: Generate", "David Karnok", "akarnokd", "11/26/13, 06:26:35 AM", "Operator Generate (6 variants) for Issue #49.", "NaN"], ["510", "BugFix: Zip", "Ben Christensen", "benjchristensen", "11/22/13, 08:25:23 PM", "This is a manual merge of https://github.com/Netflix/RxJava/pull/495 where I added some unit tests and suppressed warnings while reviewing the refactor done by @akarnokd\n\nI believe this fixes issue https://github.com/Netflix/RxJava/issues/387", "NaN"], ["511", "Operation GroupByUntil", "David Karnok", "akarnokd", "11/22/13, 09:34:08 PM", "Issue #52\n\nNote that Rx.NET's Subject<T> once onCompleted() or onError()'d, any subsequent subscriptions from observers will immediately receive onCompleted() or onError(). RxJava's PublishSubject however doesn't seem to do that, leaving future observers never do anything. Since the Rx.NET.GroupByUntil relied on the described behavior to handle escaped groups, the proposed implementation inside the GroupSubject will do this manually.", "NaN"], ["512", "Scala Adaptor Details", "Samuel Gruetter", "samuelgruetter", "11/26/13, 12:23:27 AM", "With https://github.com/Netflix/RxJava/pull/503, some files were lost, so I added them again, and I also fixed many other details. There are no changes in functionality/inheritance, only \"cosmetics\". Except https://github.com/samuelgruetter/RxJava/commit/8567fcbaff20859c68ce4c30c7f347be34581fa4 : @headinthebox could you please confirm this one-line change?", "NaN"], ["513", "Operators toMap and toMultimap again", "David Karnok", "akarnokd", "11/26/13, 06:05:04 AM", "Issue #96 and Issue #97\n\ntoMap: 3 overloads\ntoMultimap: 4 overloads\nAdded groovy test to verify overloading", "NaN"], ["514", "Operation Join again", "David Karnok", "akarnokd", "11/26/13, 12:30:31 AM", "Issue #56", "NaN"], ["515", "Operation GroupByUntil again", "David Karnok", "akarnokd", "11/26/13, 07:12:07 AM", "Issue #52", "NaN"], ["516", "Adding utility functions for observables of strings useful for processing non blocking IO.", "George Campbell", "abersnaze", "12/03/13, 10:25:50 PM", "I started developing this for use with the rxjava-apache-http contrib module to safely and scalable decode infinite observables of byte arrays into strings but thought it should live in core because it could be useful for non blocking disk IO.\n\nI did not make this part of rx.Observable because these operators only work on observables of string. The drawback is that discoverability will be harder.", "NaN"], ["518", "Rx java repeat", null, "headinthebox", "12/27/13, 09:33:49 PM", "Implementation of repeat. \n\nThere is an issue with toBlockingObservable when using currentThread(). ", "NaN"], ["519", "Operator Generate again", "David Karnok", "akarnokd", "11/26/13, 06:25:55 AM", "Issue #49\n- Updated tests to use TestScheduler\n- Removed class TimeSpan and the timeSelectors are expected to return a nanosecond-resolution value.", "NaN"], ["520", "Fixed the blocking/non-blocking first", "Shixiong Zhu", "zsxwing", "12/23/13, 08:51:09 PM", "Hi, this PR fixed the last problem in #423.\n- `Observable.first` in RxJava is same as `Observable.FirstAsync` in Rx.Net, which is a non-blocking operator. When the source sequence is empty, it will emit an `IllegalArgumentException`.\n- `Observable.takeFirst` is an alias of `take(1)`. If the source sequence is empty, it will return an empty sequence.\n- `BlockingObservable.first` in RxJava is same as `Observable.First` in Rx.Net, which is a blocking operator. When the source sequence is empty, it will emit an `IllegalArgumentException`.\n- also added `BlockingObservable.firstOrDefault`.\n\nHere I attached my test codes for Rx.Net.\n\n``` c#\n            Console.WriteLine(\"===Test FirstAsync\");\n            {\n                IObservable<int> obs = Observable.Range(1, 4).FirstAsync();\n                obs.Subscribe(\n                    x => Console.WriteLine(\"FirstAsync: \" + x),\n                    e => Console.WriteLine(\"FirstAsync: \" + e),\n                    () => Console.WriteLine(\"FirstAsync completed\")\n                    );\n            }\n            {\n                IObservable<int> obs = Observable.Empty<int>().FirstAsync();\n                obs.Subscribe(\n                    x => Console.WriteLine(\"FirstAsync with empty: \" + x),\n                    e => Console.WriteLine(\"FirstAsync with empty: \" + e),\n                    () => Console.WriteLine(\"FirstAsync with empty completed\")\n                    );\n            }\n            Console.WriteLine(\"===Test Take(1)\");\n            {\n                IObservable<int> obs = Observable.Range(1, 4).Take(1);\n                obs.Subscribe(\n                    x => Console.WriteLine(\"Take(1): \" + x),\n                    e => Console.WriteLine(\"Take(1): \" + e),\n                    () => Console.WriteLine(\"Take(1) completed\")\n                    );\n            }\n            {\n                IObservable<int> obs = Observable.Empty<int>().Take(1);\n                obs.Subscribe(\n                    x => Console.WriteLine(\"Take(1) with empty: \" + x),\n                    e => Console.WriteLine(\"Take(1) with empty: \" + e),\n                    () => Console.WriteLine(\"Take(1) with empty completed\")\n                    );\n            }\n            Console.WriteLine(\"===Test First(1)\");\n            {\n                int value = Observable.Range(1, 4).First();\n                Console.WriteLine(\"First: \" + value);\n            }\n            {\n                try\n                {\n                    int value = Observable.Empty<int>().First();\n                }\n                catch(Exception e) {\n                    Console.WriteLine(\"First with empty: \" + e);\n                }\n            }\n```\n\nThe output is:\n\n<pre>\n===Test FirstAsync\nFirstAsync: 1\nFirstAsync completed\nFirstAsync with empty: System.InvalidOperationException: Sequence contains no elements.\n===Test Take(1)\nTake(1): 1\nTake(1) completed\nTake(1) with empty completed\n===Test First(1)\nFirst: 1\nFirst with empty: System.InvalidOperationException: Sequence contains no elements.\n...\n</pre>", "NaN"], ["522", "Fixed the issue #521", "Shixiong Zhu", "zsxwing", "11/26/13, 12:27:26 AM", "Hi, this PR fixed the issue #521. Please take a look. Thanks!", "NaN"], ["525", "BugFix: Handling of Terminal State for Behavior/Publish Subjects", "Ben Christensen", "benjchristensen", "11/26/13, 05:41:42 AM", "- They were not correctly emitting onCompleted when new Observers subscribed after the Subject was terminated.\n- Added same logic that already existed on AsyncSubject", "NaN"], ["526", "Manual Merge of toMap/toMultiMap", "Ben Christensen", "benjchristensen", "11/26/13, 06:05:02 AM", "Manual merge of https://github.com/Netflix/RxJava/pull/513", "NaN"], ["527", "Docs", "David Gross", "DavidMGross", "11/26/13, 07:30:06 PM", "Javadoc improvements, including diagrams & wiki links for new operators.", "NaN"], ["528", "Operation GroupByUntil", "David Karnok", "akarnokd", "12/04/13, 09:19:38 PM", "Issue #52\n- Added variance to \"lambda\" parameters\n- Using PublishSubject as it now properly handles subscriptions after its terminal state\n\nCan't do much about the scala tests failing.", "NaN"], ["529", "Scala Tweaks", "Ben Christensen", "benjchristensen", "11/26/13, 07:29:07 PM", "Some cleanup from Erik, unit test fixes, adding license headers.", "NaN"], ["531", "visually distinguish operators that use schedulers, etc.", "David Gross", "DavidMGross", "12/03/13, 10:41:43 PM", "visually distinguish operators that use schedulers; add distinct doOnEach diagrams", "NaN"], ["533", "Async conversions", "David Karnok", "akarnokd", "12/03/13, 10:42:49 PM", "Issue #95\n- Moved to Async class and into the rx.util.functions\n- Added variances to \"lambdas\"\n- Unfortunately, the code looks almost the same as Rx.Net.", "NaN"], ["535", "Fix compilation errors due to referencing the Android support library directly", "Matthias K\u00e4ppler", "mttkay", "12/03/13, 10:43:43 PM", "This is to prevent compilation failures in projects that do not link the support-v4 library. The only other option I saw to fix this would have been to split up the android module into one for native fragments and one for support fragments, which I found would come with unjustified overhead. Hence I settled for the cheap way, which is to sacrifice type safety here.\n\nRefs https://github.com/soundcloud/RxJava/issues/2\n\n/cc @gbenson-nflx ", "NaN"], ["536", "Rebased version of jmhofer's delay() implementation", "Jon Nolen", "jonnolen", "11/27/13, 07:03:49 PM", "This is in response to the request in #384, to rebase the delay() implementation on top of master.", "NaN"], ["537", "Add scala adapters for doOnEach operator.", "Landon Fuller", "landonf", "12/04/13, 09:06:45 PM", "This re-integrates support for doOnEach that was lost in the Scala refactor.", "NaN"], ["538", "Operation GroupJoin", "David Karnok", "akarnokd", "12/05/13, 07:33:39 AM", "Issue #53\n\nSteps taken:\n- Started out from scratch based on the join() operator's pattern\n- Consulted with Rx.NET sources to match the data types of left&right maps; and behavior\n- Added RefCountSubscription class and consulted Rx.NET on the unsubscription behavior\n- Looked at WindowObservable and AddRef in the Rx.NET sources for their behavior.\n- Took a test inspiration from http://rxwiki.wikidot.com/101samples#toc39\n\n@headinthebox While writing the test for the operator, I've noticed that when both duration selectors are never(), Rx.NET never calls onCompleted on the group subjects, even though the left and right sources onComplete(). I haven't seen Rx.NET test for this scenario. This comes into play when I want to emulate join() with groupJoin(): the outer merge never onCompletes(). If I understand the behavior corretly, when both left and right sources get depleted, there is no way a new group or new group value would arrive, and all the open groups and the main observer can be onCompleted(). This is somewhat similar to join() and groupByUntil() behavior.", "NaN"], ["539", "Zipping a finite and an infinite Observable", "Samuel Gruetter", "samuelgruetter", "12/03/13, 10:47:04 PM", "Here are 4 tests testing that zipping a finite and an infinite Observable results in a finite Observable. The third of them fails...", "NaN"], ["541", "Operation SkipUntil", "David Karnok", "akarnokd", "12/03/13, 10:48:38 PM", "Issue #79\n- Written from scratch\n- Consulted Rx.NET sources to verify the behavior; there is one difference: I've implemented the OtherObserver such a way that if it is empty, it calls onCompleted() on the client observer and terminates the whole setup, in other words, the client observer won't be held up just to skip all elements of the source Observable (what if infinite stream is in play?!). ", "NaN"], ["542", "Support creating Observable from Android's Sensor.", "Alexandre Mazari", "amazari", "11/29/13, 04:49:19 PM", "Very early PR to get some guidance over API, style and error handling.", "NaN"], ["543", "Support creating Observable from Android's Sensor.", "Alexandre Mazari", "amazari", "12/27/13, 09:42:11 PM", "Very early PR to get some guidance over API, testing, style and error handling.", "NaN"], ["545", "Fixed Zip issue with infinite streams.", "David Karnok", "akarnokd", "12/03/13, 10:46:26 PM", "Issue #539", "NaN"], ["546", "Opening closing", "David Karnok", "akarnokd", "12/06/13, 08:56:06 AM", "Issue #540\n\nRemoved Opening and Closing interfaces and updated method signatures accordingly.\nMoved ObserverBase to rx.operators for now and added static methods to wrap or construct one. If usefull, it and other default implementations may be moved to a new public rx.observers package.", "NaN"], ["548", "Changes to allow the initiating of work on an Observable to be done after the Subscription is available.", "George Campbell", "abersnaze", "12/27/13, 09:41:25 PM", "See issue #547 for more details and discussion on this.", "NaN"], ["553", "Don't call plugin's handler if handler is given", "Logan Johnson", "loganj", "12/03/13, 08:27:16 PM", "When an error handler is explicitly supplied, don't delegate to the\nplugin's error handler.\n\nThis looks like a mistake, but I'm not certain.  I wasn't able to find documentation on the error handler plugin that describes when it's called.  My assumption here is that it's a default error handler, called when no onError() implementation is supplied.", "NaN"], ["555", "skipUntil() marble diagram and wiki link in javadoc", "David Gross", "DavidMGross", "12/04/13, 12:26:49 AM", "NaN", "NaN"], ["557", "ObserveOn: Moved queue into a per-observer instance.", "David Karnok", "akarnokd", "12/06/13, 08:34:15 AM", "I don't fully understand why the original didn't work properly. My guess is either the shared queue between observers or a race condition on the recursiveScheduler field. My implementation seems to work correctly with the test case in #551\n\n``` java\npublic class ObserveOnTest {\n    static class PrintObserver<T> implements Observer<T> {\n        private final String prefix;\n        public PrintObserver(String prefix) {\n            this.prefix = prefix;\n        }\n        void printPrefix() {\n            System.out.print(prefix);\n            System.out.print(\": \");\n        }\n        @Override\n        public void onNext(T args) {\n            synchronized (PrintObserver.class) {\n                printPrefix();\n                System.out.println(args);\n            }\n        }\n\n        @Override\n        public void onError(Throwable e) {\n            synchronized (PrintObserver.class) {\n                printPrefix();\n                System.out.println(e);\n            }\n        }\n\n        @Override\n        public void onCompleted() {\n            synchronized (PrintObserver.class) {\n                printPrefix();\n                System.out.println(\"done\");\n            }\n        }\n\n    }\n    public static void main(String[] args) throws Exception {\n        Observable<Integer> o = Observable.from(1, 2, 3);\n        Observable<Integer> o2 = o.observeOn(Schedulers.threadPoolForComputation());\n\n        System.out.println(\"Subscribe A\");\n        o2.subscribe(new PrintObserver<>(\"a\"));\n        System.out.println(\"Subscribe B\");\n        o2.subscribe(new PrintObserver<>(\"b\"));\n        System.out.println(\"Waiting\");\n        Thread.sleep(1000);\n        System.out.println(\"Done\");\n    }\n}\n```", "NaN"], ["560", "Add type variances for doOnEach actions.", "Landon Fuller", "landonf", "12/04/13, 09:09:52 PM", "This fixes the use of contravariant actions (issue #532)", "NaN"], ["561", "Creating Observables in Scala: Approach04", "Samuel Gruetter", "samuelgruetter", "12/05/13, 11:32:02 AM", "This implements **approach04** from https://github.com/Netflix/RxJava/issues/549 .\nI also moved the `toScalaXxx`/`toJavaXxx` methods into a separate file, so that one can import only these without importing the implicit function conversions. \nThere's now also `Observable.from(Future)` and to test it, some tweaks in `Notification` were necessary.\nNote that this is a breaking change.", "NaN"], ["562", "Scala Adaptor Improvements by Erik", "Samuel Gruetter", "samuelgruetter", "12/04/13, 11:12:47 PM", "There are many important improvements by Erik on the branch https://github.com/Applied-Duality/RxJava/tree/RxJavaBugFixes , and I'd like to have them on Netflix:master, so that everyone works on the same code, and that we can avoid duplicate work, since some changes I'd like to do require changes that Erik has already made. @headinthebox hope you're ok with this.", "NaN"], ["563", "Operation GroupByUntil", "David Karnok", "akarnokd", "12/05/13, 12:29:08 AM", "Issue #52\n\nRebased.", "NaN"], ["565", "Operator GroupJoin v2", "David Karnok", "akarnokd", "12/05/13, 11:33:21 AM", "Issue #53\n\nRebased.\n\nStill: @headinthebox While writing the test for the operator, I've noticed that when both duration selectors are never(), Rx.NET never calls onCompleted on the group subjects, even though the left and right sources onComplete(). I haven't seen Rx.NET test for this scenario. This comes into play when I want to emulate join() with groupJoin(): the outer merge never onCompletes(). If I understand the behavior corretly, when both left and right sources get depleted, there is no way a new group or new group value would arrive, and all the open groups and the main observer can be onCompleted(). This is somewhat similar to join() and groupByUntil() behavior.", "NaN"], ["566", "Operation Sample with another Observable", "David Karnok", "akarnokd", "12/06/13, 08:07:25 AM", "Issue #74\n\nAdded missing `Observable.sample(Observable<U> sampler)`.", "NaN"], ["567", "Operation Timestamp with Scheduler", "David Karnok", "akarnokd", "12/05/13, 11:35:34 AM", "Issue #93", "NaN"], ["568", "Use lock free strategy for several Subscription implementations", "Vanadium", "jloisel", "12/08/13, 11:27:32 PM", "Reduce contention by using CAS (Compare And Swap) operations to replace\nsubscription in several subscription implementations.", "NaN"], ["569", "javadoc improvements (groupJoin, groupByUntil, timestamp w/scheduler)", "David Gross", "DavidMGross", "12/06/13, 12:53:08 AM", "adding marble diagrams and links to the RxJava wiki, standardizing javadoc comment formatting", "NaN"], ["571", "Operation Sample with Observable v2", "David Karnok", "akarnokd", "12/08/13, 11:28:11 PM", "Issue #74\n- Sample will terminate if either the source or the sampler terminates or throws an error.\n- The sampler now emits values only in its onNext() method. Therefore, if the sampler completes and there is a sampled value available (`valueTaken == false`), it won't emit the value before terminating.", "NaN"], ["572", "ObserveOn fix for observing the same source on the same scheduler by two...", "David Karnok", "akarnokd", "12/08/13, 11:33:31 PM", "... different observers.\n\nIssue #551\n- cleaned up\n- added test cases", "NaN"], ["573", "Removed Opening and Closing historical artifacts.", "David Karnok", "akarnokd", "12/08/13, 11:35:03 PM", "Issue #540\n\nThe build fails due Scala compiler error I don't understand:\n\n```\n[ant:scalac] RxJava\\language-adaptors\\rxjava-scala\\src\\main\\s\ncala\\rx\\lang\\scala\\Observable.scala:531: error: type mismatch;\n[ant:scalac]  found   : x2.type (with underlying type rx.Observable[_ <: T])\n[ant:scalac]  required: T\n[ant:scalac]       Observable[T](x2)\n[ant:scalac]                     ^\n[ant:scalac] one error found\n```\n\n``` scala\n  def window[Closing](closings: () => Observable[Closing]): Observable[Observable[T]] = {\n    val func : Func0[_ <: rx.Observable[_ <: Closing]] = closings().asJavaObservable\n    val o1: rx.Observable[_ <: rx.Observable[_]] = asJavaObservable.window[Closing](func)\n    val o2 = Observable[rx.Observable[_]](o1).map((x: rx.Observable[_]) => {\n      val x2 = x.asInstanceOf[rx.Observable[_ <: T]]\n      Observable[T](x2)\n    })\n    o2\n  }\n```\n\nCould someone help me with this?", "NaN"], ["574", "clarify documentation on cache()", "Samuel Gruetter", "samuelgruetter", "12/08/13, 11:35:57 PM", "I lost some time because I didn't read the documentation of `cache()` carefully enough. To make it easier for others, I tried to make the documentation more explicit here.", "NaN"], ["575", "Reimplement the 'SequenceEqual' operator", "Shixiong Zhu", "zsxwing", "12/08/13, 11:38:50 PM", "Hi, this PR reimplemented the `SequenceEqual` operator #76 and should fix the issue #564.\n\nThe wiki page https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#sequenceequal still needs to be updated. @DavidMGross could you help update the marble diagram of `SequenceEqual`? Thanks!", "NaN"], ["576", "Timer and Delay", "Samuel Gruetter", "samuelgruetter", "12/10/13, 10:59:02 PM", "As [pointed out](https://github.com/Netflix/RxJava/pull/384#issuecomment-26843865) by @headinthebox, it's possible to implement `delay` in terms of `timer`, `map` and `concat`. \n\nHowever, there were some tricky points:\n-    In order to start the timers right after they're created (and not just when `concat` subscribes to them), I had to use `replay`.\n-    There is bug https://github.com/Netflix/RxJava/issues/552 which also affects `delay`.\n\nI hope that there aren't too many further tricky points that I missed, especially since https://github.com/Netflix/RxJava/issues/552 adds confusion. So this will need another review once https://github.com/Netflix/RxJava/issues/552 is fixed.\n\nThanks @jmhofer for your previous work on `delay`, I reused it where possible (see commit messages).", "NaN"], ["578", "A bug in apply(u:=>Unit) method of Subscription companion object fixed w...", "Ugur ZONGUR", "ugur-zongur", "12/23/13, 08:54:26 PM", "...hich may cause multiple invocations of u, in a multithreaded, multi-unsubscribe situation.\n\nThreads may be pre-empted after evaluation of condition (!unsubscribed.get()) which may result in two or more threads executing the consequent block more than once. A code that relies on single evaluation of u will fail if that case happens.", "NaN"], ["580", "CRLF fixes", "David Karnok", "akarnokd", "12/08/13, 11:58:58 PM", "Issue #579\n\nIn case the manual mode is chosen.", "NaN"], ["582", "Fix: Unsubscribe while not holding a lock.", "David Karnok", "akarnokd", "12/09/13, 08:43:25 AM", "For Issue #577", "NaN"], ["584", "Fixes OnCompleted.unapply result type", "Szabolcs Berecz", "khernyo", "12/23/13, 08:56:54 PM", "The Scala spec says that an extractor matches a pattern with zero\nargument pattern if the result type of unapply is Boolean. The result\ntype of Option[T] means that the extractor has exactly one argument\npattern of type T.\n\nThe \"Option[Unit]\" result type does work, but it's probably a compiler\nbug. Based on the result type, the pattern match \"case OnCompleted() =>\"\nshould not compile and \"case OnCompleted(()) =>\" should be used instead.\nUsing the latter one crashes the compiler... Changing the result type of\nunapply to Boolean does _not_ change any of this, so using the pattern\n\"case OnCompleted(()) =>\" still crashes the compiler, but at least the\npattern is not suggested by the unapply result type and the pattern\nmatch results in one less object allocation.\n\nThe included test does _not_ check for this problem, it simply makes\nsure that it still works correctly when using the correct pattern.", "NaN"], ["585", "Operation Timer", "David Karnok", "akarnokd", "12/09/13, 08:55:47 AM", "Enhancement: #92\n\nI've omitted the absolute time variants because of the earlier comments on Generate.\n\nRelated issue: #530 ", "NaN"], ["586", "Fix Concat to allow multiple observers", "David Karnok", "akarnokd", "12/08/13, 11:48:23 PM", "Issues #552 and #583", "NaN"], ["587", "Operation LongCount", "David Karnok", "akarnokd", "12/08/13, 11:47:01 PM", "Issue #60\n\nStraightforward version of the regular count(). \n\n(However, I would have implemented it differently so the constant boxing-unboxing could be avoided.)", "NaN"], ["593", "Lock-free subscriptions", "David Karnok", "akarnokd", "12/10/13, 11:03:28 PM", "- Uniform naming of inner components: Issue #592\n- Lock-free approach to avoid deadlocks: Issue #577\n- SerialSubscription.isUnsubscribe added: Issue #590\n\nRemarks:\n- IMO, an unsubscribed Single/Serial/Multiple subscription return Subscriptions.empty() instead of null. So unless the user put a null in there he/she shouldn't worry about null.\n- There was a concurrency bug in @jloisel 's reimplementation of CompositeSubscription. It allowed multiple threads to enter the mutation part if the current state was already MUTATE. I've added the necessary checks to allow only NORMAL -> MUTATE transitions.", "NaN"], ["594", "Implement the 'Start' operator", "Shixiong Zhu", "zsxwing", "12/11/13, 06:08:04 AM", "Hi, this PR implemented the `Start` operator #81. Please take a look.", "NaN"], ["596", "Fix for buffer not stopping when unsubscribed.", "David Karnok", "akarnokd", "12/10/13, 10:57:10 PM", "Issue #559", "NaN"], ["597", "Javadoc updates (longCount, sample(sampler))", "David Gross", "DavidMGross", "12/10/13, 10:57:39 PM", "NaN", "NaN"], ["598", "New Scala Bindings", null, "headinthebox", "12/10/13, 04:51:00 AM", "(copied from release notes)\n# RxScala Release Notes\n\nThis release of the RxScala bindings builds on the previous 0.15 release to make the Rx bindings for Scala\ninclude all Rx types. In particular this release focuses on fleshing out the bindings for the `Subject` and `Scheduler`\ntypes, as well as aligning the constructor functions for `Observable` with those in the RxJava.\n\nExpect to see ongoing additions to make the Scala binding match the equivalent underlying Java API,\nas well as minor changes in the existing API as we keep fine-tuning the experience on our way to a V1.0 release.\n## Observer\n\nIn this release we have made the `asJavaObserver` property in `Observable[T]`as well the the factory method in the\ncompanion object that takes an `rx.Observer` private to the Scala bindings package, thus properly hiding irrelevant\nimplementation details from the user-facing API. The `Observer[T]` trait now looks like a clean, native Scala type:\n\n``` scala\ntrait Observer[-T] {\n  def onNext(value: T): Unit\n  def onError(error: Throwable): Unit\n  def onCompleted(): Unit\n}\n\nobject Observer {...}\n```\n\nTo create an instance of a specific `Observer`, say  `Observer[SensorEvent]` in user code, you can create a new instance\nof the `Observer` trait by implementing any of the methods that you care about:\n\n``` scala\n   val printObserver = new Observer[SensorEvent] {\n      override def onNext(value: SensorEvent): Unit = {...value.toString...}\n   }\n```\n\n or you can use one of the overloads of the companion `Observer` object by passing in implementations of the `onNext`,\n `onError` or `onCompleted` methods.\n\nNote that typically you do not need to create an `Observer` since all of the methods that accept an `Observer[T]`\n(for instance `subscribe`) usually come with overloads that accept the individual methods\n`onNext`, `onError`, and `onCompleted` and will automatically create an `Observer` for you under the covers.\n\nWhile _technically_ it is a breaking change make the `asJavaObserver` property private, you should probably not have\ntouched `asJavaObserver` in the first place. If you really feel you need to access the underlying `rx.Observer`\ncall `toJava`.\n## Observable\n\nJust like for `Observer`, the `Observable` trait now also hides its `asJavaObservable` property and makes the constructor\nfunction in the companion object that takes an `rx.Observable` private (but leaves the companion object itself public).\nAgain, while _technically_ this is a breaking change, this should not have any influence on user code.\n\n``` scala\ntrait Observable[+T] {\n    def subscribe(observer: Observer[T]): Subscription = {...}\n    def apply(observer: Observer[T]): Subscription = {...}\n    ...\n}\nobject Observable {\n   def create[T](func: Observer[T] => Subscription): Observable[T] = {...}\n   ...\n}\n```\n\nThe major changes in `Observable` are wrt to the factory methods where too libral use of overloading of the `apply`\nmethod hindered type inference and made Scala code look unnecessarily different than that in other language bindings.\nAll factory methods now have their own name corresponding to the Java and .NET operators\n(plus overloads that take a `Scheduler`).\n- `def from[T](future: Future[T]): Observable[T]`,\n- `def from[T](iterable: Iterable[T]): Observable[T]`,\n- `def error[T](exception: Throwable): Observable[T]`,\n- `def empty[T]: Observable[T]`,\n- `def items[T](items: T*): Observable[T],\n- Extension method on `toObservable: Observable[T]` on `List[T]`.\n\nIn the _pre-release_ of this version, we expose both `apply` and `create` for the mother of all creation functions.\nWe would like to solicit feedback which of these two names is preferred\n(or both, but there is a high probability that only one will be chosen).\n- `def apply[T](subscribe: Observer[T]=>Subscription): Observable[T]`\n- `def create[T](subscribe: Observer[T] => Subscription): Observable[T]`\n## Subject\n\nThe `Subject` trait now also hides the underlying Java `asJavaSubject: rx.subjects.Subject[_ >: T, _<: T]`\nand takes only a single _invariant_ type parameter `T`. all existing implementations of `Subject` are parametrized\nby a single type, and this reflects that reality.\n\n``` scala\ntrait Subject[T] extends Observable[T] with Observer[T] {}\nobject Subject {\n   def apply(): Subject[T] = {...}\n}\n```\n\nFor each kind of subject, there is a class with a private constructor and a companion object that you should use\nto create a new kind of subject. The subjects that are available are:\n- `AsyncSubject[T]()`,\n- `BehaviorSubject[T](value)`,\n- `Subject[T]()`,\n- `ReplaySubject[T]()`.\n\nThe latter is still missing various overloads http://msdn.microsoft.com/en-us/library/hh211810(v=vs.103).aspx which\nyou can expect to appear once they are added to the underlying RxJava implementation.\n\nCompared with release 0.15.1, the breaking changes in `Subject` for this release are\nmaking `asJavaSubject` private, and collapsing its type parameters, neither of these should cause trouble,\nand renaming `PublishSubject` to `Subject`.\n## Schedulers\n\nThe biggest breaking change compared to the 0.15.1 release is giving `Scheduler` the same structure as the other types.\nThe trait itself remains unchanged, except that we made the underlying Java representation hidden as above.\nas part of this reshuffling, the scheduler package has been renamed from `rx.lang.scala.concurrency`\nto `rx.lang.scala.schedulers`. There is a high probability that this package renaming will also happen in RxJava.\n\n``` scala\ntrait Scheduler {...}\n```\n\nIn the previous release, you created schedulers by selecting them from the `Schedulers` object,\nas in `Schedulers.immediate` or `Schedulers.newThread` where each would return an instance of the `Scheduler` trait.\nHowever, several of the scheduler implementations have additional methods, such as the `TestScheduler`,\nwhich already deviated from the pattern.\n\nIn this release, we changed this to make scheduler more like `Subject` and provide a family of schedulers\nthat you create using their factory function:\n- `CurrentThreadScheduler()`,\n- `ExecutorScheduler(executor)`,\n- `ImmediateScheduler()`,\n- `NewThreadScheduler()`,\n- `ScheduledExecutorServiceScheduler(scheduledExecutorService)`,\n- `TestScheduler()`,\n- `ThreadPoolForComputationScheduler()`,\n- `ThreadPoolForIOScheduler()`.\n\nIn the future we expect that this list will grow further with new schedulers as they are imported from .NET\n(http://msdn.microsoft.com/en-us/library/system.reactive.concurrency(v=vs.103).aspx).\n\nTo make your code compile in the new release you will have to change all occurrences of `Schedulers.xxx`\ninto `XxxScheduler()`, and import `rx.lang.scala.schedulers` instead of `rx.lang.scala.schedulers`.\n## Subscriptions\n\nThe `Subscription` trait in Scala now has `isUnsubscribed` as a member, effectively collapsing the old `Subscription`\nand `BooleanSubscription`, and the latter has been removed from the public surface. Pending a bug fix in RxJava,\n`SerialSubscription` implements its own `isUnsubscribed`.\n\n``` scala\ntrait Subscription {\n  def unsubscribe(): Unit = { ... }\n  def isUnsubscribed: Boolean = ...\n}\n\nobject Subscription {...}\n```\n\n To create a `Subscription` use one of the following factory methods:\n- `Subscription{...}`, `Subscription()`,\n- `CompositeSubscription(subscriptions)`,\n- `MultipleAssignmentSubscription()`,\n- `SerialSubscription()`.\n  \n  In case you do feel tempted to call `new Subscription{...}` directly make sure you wire up `isUnsubscribed`\n  and `unsubscribe()` properly, but for all practical purposes you should just use one of the factory methods.\n## Notifications\n\nAll underlying wrapped `Java` types in the `Notification` trait are made private like all previous types. The companion\nobjects of `Notification` now have both constructor (`apply`) and extractor (`unapply`) functions:\n\n``` scala\nobject Notification {...}\ntrait Notification[+T] {\n   override def equals(that: Any): Boolean = {...}\n   override def hashCode(): Int = {...}\n   def apply[R](onNext: T=>R, onError: Throwable=>R, onCompleted: ()=>R): R = {...}\n}\n```\n\nThe nested companion objects of `Notification` now have both constructor (`apply`) and extractor (`unapply`) functions:\n\n``` scala\nobject Notification {\n   object OnNext { def apply(...){}; def unapply(...){...} }\n   object OnError { def apply(...){}; def unapply(...){...} }\n   object OnCompleted { def apply(...){}; def unapply(...){...} }\n}\n```\n\nTo construct a `Notification`, you import `rx.lang.scala.Notification._` and use `OnNext(\"hello\")`,\nor `OnError(new Exception(\"Oops!\"))`, or `OnCompleted()`.\n\nTo pattern match on a notification you create a partial function like so: `case Notification.OnNext(v) => { ... v ... }`,\nor you use the `apply` function to pass in functions for each possibility.\n\nThere are no breaking changes for notifications.\n## Java Interop Helpers\n\nSince the Scala traits _wrap_ the underlying Java types, yoo may occasionally will have to wrap an unwrap\nbetween the two representations. The `JavaConversion` object provides helper functions of the form `toJavaXXX` and\n`toScalaXXX` for this purpose, properly hiding how precisely the wrapped types are stored.\nNote the (un)wrap conversions are defined as implicits in Scala, but in the unlikely event that you do need them\nbe kind to the reader of your code and call them explicitly.\n\n``` scala\nobject JavaConversions {\n  import language.implicitConversions\n\n  implicit def toJavaNotification[T](s: Notification[T]): rx.Notification[_ <: T] = {...}\n  implicit def toScalaNotification[T](s: rx.Notification[_ <: T]): Notification[T] = {...}\n  implicit def toJavaSubscription(s: Subscription): rx.Subscription = {...}\n  implicit def toScalaSubscription(s: rx.Subscription): Subscription = {...}\n  implicit def scalaSchedulerToJavaScheduler(s: Scheduler): rx.Scheduler = {...}\n  implicit def javaSchedulerToScalaScheduler(s: rx.Scheduler): Scheduler = {...}\n  implicit def toJavaObserver[T](s: Observer[T]): rx.Observer[_ >: T] = {...}\n  implicit def toScalaObserver[T](s: rx.Observer[_ >: T]): Observer[T] = {...}\n  implicit def toJavaObservable[T](s: Observable[T]): rx.Observable[_ <: T] = {...}\n  implicit def toScalaObservable[T](observable: rx.Observable[_ <: T]): Observable[T] = {...}\n}\n```", "NaN"], ["599", "Refactor rx.concurrency to rx.schedulers", "Ben Christensen", "benjchristensen", "12/10/13, 11:57:53 PM", "To match the naming convention of rx.observables, rx.subjects and rx.subscriptions we have decided to rename rx.concurrency to rx.schedulers prior to the 1.0 release. These commits makes this change.\n\nSince this is a non-trivial breaking change to anyone using Schedulers, this leaves the `rx.concurrency.*` classes in place and deprecates them to give time to migrate. These deprecated classes will be deleted prior to the 1.0 release.", "NaN"], ["600", "BugFix: Replay Subject", "Ben Christensen", "benjchristensen", "12/11/13, 01:51:05 AM", "NaN", "NaN"], ["602", "ObserveOn Fixes", "Ben Christensen", "benjchristensen", "12/13/13, 07:32:32 AM", "- refactor to remove imperative assignment of innerScheduler for clearer concurrency and data access\n- fix subscription leak (Composite+MultipleAssignment instead of just Composite)\n- remove confusing conditional logic for inner/outer scheduler", "NaN"], ["603", "Significant restructuring of subscriptions", "David Karnok", "akarnokd", "12/13/13, 08:31:35 AM", "I've re-abstracted the subscriptions to be more uniform and maintenance friendly.\n- Enhanced BooleanSubscription to support inheritance and single unsubscription action through `onUnsubscribe` (Issue #591).\n- Added `BooleanSubscription.withAction` to allow wrapping a single-time unsubscription action.\n- Created `AbstractAtomicSubscription` which manages the lock-free manipulations through callbacks.\n- Rewritted `MultipleAssignmentSubscription` to have two extension points in its logic, which allows simpler subclass implementations of `SerialSubscription` and `SingleAssignmentSubscription`. `MultipleAssignmentSubscription` does not extend `AbstractAtomicSubscription` because it has a much simpler state-transition logic whereas the `AbstractAtomicSubscription` with its callbacks would be an overkill.\n- Rewritten `CompositeSubscription` and `RefCountSubscription` to use `AbstractAtomicSubscription`.\n- Modified `SafeObservableSubscription` to use `SingleAssignmentSubscription` instead of duplicating its behavior.\n- Extended `Subscriptions` with an `unsubscribeAll` method to capture the exception collection behavior when unsubscribing from multiple subscriptions.\n- Added `empty0()`, `empty1()` and `empty2()` convenience methods to Actions. Haven't checked if such no-op ActionX instances are created manually somewhere.\n- BONUS: `ValuedCompositeSubscription<T>` class where a value can be associated with a `Subscription` key.", "NaN"], ["604", "Added op:join to concat objects with separator between elements.", "David Karnok", "akarnokd", "12/12/13, 12:05:19 AM", "Straightforward. `\"a\", 1, \"c\"` with separator `\", \"` becomes `\"a, 1, c\"`", "NaN"], ["605", "Subjects reimplemented.", "David Karnok", "akarnokd", "12/23/13, 08:58:17 PM", "Reimplemented all 4 kinds of subjects with the following properties:\n- The `onNext`, `onError` and `onCompleted` are fully thread safe against subscription and unsubscription.\n- A terminated subject won't accept any new events; `AsyncSubject`, `PublishSubject` and `BehaviorSubject` will re-emit just the very first exception when an observer subscribes to them.\n- Emitting events to subscribed observers is done while holding the state lock. \n  - In Rx.NET when an event is received, the list of observers is retrieved while holding the lock, then outside the lock, the list is traversed and the events are propagated to the observers. Note however, if an observer unsubscribes right after the unlock and before the event propagation, it will still appear in the list and will receive the event. IMO, this is an undesired behavior.\n  - The drawback of my solution is that it might be possible to deadlock the subjects, i.e., when an observer deliberately passes the source subject to another thread (which sends an event to the subject) and waits for its completion.\n- Added the `Notification.acceptSafe` which will capture the exception of the `onNext` and propagate it through the `onError`. Its return value indicates if the observer can still be used after (i.e., no terminal event was delivered).\n- Added the reusable state classes to `AbstractSubject`, although none of the subjects use this class any more.\n- There is an `UnsubscribeTester` class, which seems to be out-of-place. Can this be moved into the test directory?", "NaN"], ["606", "Operation Timer again", "David Karnok", "akarnokd", "12/12/13, 12:06:59 AM", "Operation Timer readded.\n\nNote that the master version has the timer operator with wrong return type compared to Rx.NET (Void vs Long). I've replaced the the methods and use places.", "NaN"], ["607", "Javadoc improvements:", "David Gross", "DavidMGross", "12/12/13, 12:04:04 AM", "- consistent nomenclature\n- consistent/standard javadoc formatting\n- more-precise descriptions\n- timer() marble digram & wiki link\n- delay() marble diagram & wiki link", "NaN"], ["609", "Operation Timer 3.0", "David Karnok", "akarnokd", "12/12/13, 08:17:32 PM", "Rebased.", "NaN"], ["611", "Serial subscription fix", null, "headinthebox", "12/12/13, 08:11:35 PM", "Changed Scala bindings fro SerialSubscription to use underlying isUnsubscribed implementation", "NaN"], ["612", "Replay additional overloads", "David Karnok", "akarnokd", "12/12/13, 08:19:42 PM", "Issue #71\n- Added several overloads of the `replay` operator: \n  - limited buffer, limited time window, buffer+time, \n  - scheduler overloads; \n  - versions which perform a projection before the replay\n- Added missing `multicast` overload", "NaN"], ["615", "Copied the code from OperationMerge to fix synchronization", "George Campbell", "abersnaze", "12/12/13, 10:28:36 PM", "for #614", "NaN"], ["616", "Combine latest fix", "David Karnok", "akarnokd", "12/30/13, 06:19:03 PM", "Fixes potential issues mentioned in #613\n\nQuestion: it emits a \"row\" while holding a lock. This ensures a FIFO behavior towards the client observer. Do we want such strong guarantee?", "NaN"], ["617", "replay() and timer() javadocs: diagrams & wiki links", "David Gross", "DavidMGross", "12/13/13, 12:59:23 AM", "NaN", "NaN"], ["619", "UnitTest to assert thread safety of Executor Scheduler", "Ben Christensen", "benjchristensen", "12/14/13, 12:15:58 AM", "- The Executor thread-pools hop threads when using observeOn so this tests that it is thread-safe when doing so.\n- The test performs non-thread-safe mutations which should fail (or at least be non-deterministic) if memory visibility problems or concurrency is occurring.", "NaN"], ["620", "Subscription overhaul2", "David Karnok", "akarnokd", "12/23/13, 08:39:13 PM", "Renamed and changed things according to comments in #603", "NaN"], ["621", "SerialSubscription & From", null, "headinthebox", "12/23/13, 09:03:32 PM", "Update scala bindings for SerialSubscription since underlying type now implements isUnsubscribed.\n\nChanged Observable.from to use currentThreadScheduler (principle of least surprise).\nUsed scheduler in create instead of observerOn.\nFixed blocking tests.", "NaN"], ["622", "Operators: Observables from functionals (Action0, Func0, Runnable, Calla...", "David Karnok", "akarnokd", "12/27/13, 06:58:37 PM", "...ble)\n\nI've created 4 operators that turn ordinary action/function calls into Observables, but unlike start and Async, the functions are called on each subscription instead of only once. They can be thought of a more generalized from(T value). Each method is named according to the accepted type to avoid overload issues with Java 8 & various dynamic languages.\n\nThe 4 additional overloads lets the user specify the scheduler where the function is called. By default, the functions are called on the threadPoolForComputation.\n\nI don't know if there are Rx.NET equivalents of these (or they ever existed).", "NaN"], ["626", "Added: BO.Latest, fixed: BO.next, BO.mostRecent, BO.toIterable", "David Karnok", "akarnokd", "12/23/13, 09:15:51 PM", "- Implemented Latest (Issue #59)\n- Fixed Next and MostRecent to connect to the source observable only when the iterator is asked for.\n- Fixed ToIterable.next() not properly handling the completed status (repeated calls to just the next() would simply block on the empty queue).", "NaN"], ["628", "Properly wired up SynchronizedObserver within MergeDelayError operator", "Matt Jacobs", "mattrjacobs", "12/16/13, 08:28:06 PM", "Previous pull request for this issue (https://github.com/Netflix/RxJava/pull/615) missed the step of connecting SynchronizedObserver to ParentObserver", "NaN"], ["631", "Make NewThreadScheduler create Daemon threads", "Ben Christensen", "benjchristensen", "12/17/13, 07:49:04 PM", "This matches the behavior of Schedulers.COMPUTATION_EXECUTOR and Schedulers.IO_EXECUTOR.\n\nSee https://groups.google.com/forum/#!topic/rxjava/Qe1qi0aHtnE and https://github.com/Netflix/RxJava/issues/431#issuecomment-30767610", "NaN"], ["633", "Fixed issue #595 about null in toList operator", "Shixiong Zhu", "zsxwing", "12/23/13, 09:16:33 PM", "just fixed the issue #595 about null values. I suppose that 'toList' does not need to handle the concurrent problem, so I use `ArrayList`.", "NaN"], ["635", "Operators: switchCase (Case), ifThen (If), doWhile (DoWhile), WhileDo (W...", "David Karnok", "akarnokd", "12/23/13, 09:19:03 PM", "...hile)\n\nIssue #634\n\nNo MSDN references available.", "NaN"], ["636", "Operators BO.chunkify, BO.collect, O.forIterable", "David Karnok", "akarnokd", "12/24/13, 12:27:09 AM", "Issue #634\n\nAny suggestions for a name instead of `forIterable`?", "NaN"], ["638", "Operators DelaySubscription, TakeLast w/ time, TakeLastBuffer", "David Karnok", "akarnokd", "12/23/13, 09:40:26 PM", "Issue #634", "NaN"], ["639", "Moved the descriptions of some operators to a new wiki page.", "David Gross", "DavidMGross", "12/19/13, 05:54:17 PM", "\"Conditional and Boolean Operators\"\nadjusting the javadoc links accordingly", "NaN"], ["641", "Operators: AsObservable, GroupBy w/ maxGroups, GroupByUntil w/ maxGroups", "David Karnok", "akarnokd", "12/23/13, 10:35:34 PM", "Issue #634\n\nImplemented both maxGroups variants on top of (my) `groupByUntil` so it won't conflict with any potentially rewritten `groupBy`.", "NaN"], ["642", "TestScheduler infrastructure enhancements", "David Karnok", "akarnokd", "02/11/14, 08:35:06 PM", "Enhanced TestScheduler.\n\nMentioned in issue #634, and in the forum [HistoricalScheduler](https://groups.google.com/forum/#!topic/rxjava/4vmsg5Rs5sU).\n\nNotes:\n- Inspired by Rx.NET.\n- `HistoricalScheduler` appears to be just a variant of the `TestScheduler` where times are absolute `DateTimeOffset`s. Since we don't do `java.util.Date` overloads anywhere, I didn't implement this. If you need to work with real time (i.e., `System.currentTimeMillis()`) just advance the `TestScheduler` by ctm. before doing anything else.\n- The `Recorded` class, the `TestScheduler.scheduleAbsolute` and `TestScheduler.scheduleRelative` methods use millisecond resolution time due to two reasons:\n  - `TestScheduler.now()` is in milliseconds\n  - No real need of higher resolution, as TestScheduler operates on virtual time and aimed for testing purposes only. Virtual time can be scaled up or down as neccessary.\n- Added the package `rx.observers`. I guess we can move the `SafeObserver`, `ObserverBase` and `SynchronizedObserver` into these packages (not done in this PR). The package's JavaDoc visibility can be decided independently.\n- I put the new `ColdObservable`, `HotObservable` and `TestableObservable` types into `rx.observables`. Do we have a main distribution and a test distribution of RxJava (i.e., if someone wants to use these types to test his/her own operators, does he/she need to download a different library)?\n- Added some behavior to `Notification`. In addition, I suggested the deprecation of `new Notification()` to create an OnCompleted kind of notification, since virtually there is no way (or reason) to distinguish between one OnCompleted event from another, I've added a factory method instead which returns a single constant instance. I haven't changed any use place of the old constructor.\n- See `TestSchedulerTest` for the use cases.", "NaN"], ["643", "Fixed OutOfMemoryError with CPU scheduler in recursive mode.", "David Karnok", "akarnokd", "12/20/13, 08:34:39 PM", "Found an [issue in Rx.NET](https://rx.codeplex.com/discussions/431558) regarding an out-of-memory situation due to long chained subscriptions when using recursive scheduling.\n\nThe following test program crashes or just hangs indefinitely:\n\n``` java\npublic class RunRecursiveScheduling {\n    /**\n     * Generates an observable sequence by iterating a state from an initial \n     * state until the condition returns false.\n     */\n    public static <TState, R> OnSubscribeFunc<R> generate(\n            final TState initialState,\n            final Func1<TState, Boolean> condition,\n            final Func1<TState, TState> iterate,\n            final Func1<TState, R> resultSelector,\n            final Scheduler scheduler) {\n        return new OnSubscribeFunc<R>() {\n            @Override\n            public Subscription onSubscribe(final Observer<? super R> observer) {\n                return scheduler.schedule(initialState, new Func2<Scheduler, TState, Subscription>() {\n                    @Override\n                    public Subscription call(Scheduler s, TState state) {\n                        boolean hasNext;\n                        try {\n                            hasNext = condition.call(state);\n                        } catch (Throwable t) {\n                            observer.onError(t);\n                            return Subscriptions.empty();\n                        }\n                        if (hasNext) {\n                            R result;\n                            try {\n                                result = resultSelector.call(state);\n                            } catch (Throwable t) {\n                                observer.onError(t);\n                                return Subscriptions.empty();\n                            }\n                            observer.onNext(result);\n\n                            TState nextState;\n                            try {\n                                nextState = iterate.call(state);\n                            } catch (Throwable t) {\n                                observer.onError(t);\n                                return Subscriptions.empty();\n                            }\n\n                            return s.schedule(nextState, this);\n                        }\n                        observer.onCompleted();\n                        return Subscriptions.empty();\n                    }\n                });\n            }\n        };\n    }\n\n    public static void main(String[] args) throws Exception {\n        Observable<Integer> source = Observable.create(generate(\n                0, a -> true, a -> a + 1, a -> a, Schedulers.threadPoolForComputation()));\n\n        CountDownLatch latch = new CountDownLatch(1);\n        Subscription s = source.subscribe(v -> { \n                    if (v % 100_000 == 0) {\n                        System.out.println(v);\n                    }\n                    if (v >= 10_000_000) { \n                        latch.countDown(); \n                    } \n                }, \n                e -> { e.printStackTrace(); latch.countDown(); }, \n                latch::countDown);\n\n        latch.await();\n\n        System.out.println(\"Wait done.\");\n\n        s.unsubscribe();\n\n        System.out.println(\"Unsubscribe done.\");\n    }\n}\n```\n\nThe issue lies in the fact that CPU scheduler (and perhaps the others) are not really reentrant, therefore, they create new composite subscriptions whenever a recursive scheduling happens. So instead of showing a simple subscription to the outside world, a chain of subscription is extended on every recursive schedule call.\n\nA working solution is to have a different scheduler shown to the `Func2<Scheduler, T, Subscription>` than the actual CPU scheduler. This new scheduler, called `ReentrantScheduler`, maintains internal subscriptions which get replaced if a recursive scheduling is executed.\n\nI found three issues with this new approach and the old tests:\n- In `SchedulersTest.testRecursiveScheduler2`, the logic relied on the expectation that the call on L338 is executed at least once if the outer subscription is unsubscribed. The new logic stops the schedule chain instantly, so it is very unlikely the call on L338 gets executed after this.\n- In `OperationObserveOn.Observation` tries to solve the underlying issue as well with its own subscription replacer logic. I haven't changed the operator as it might not work with non CPU scheduler after that.\n- The `ReentrantSchehduler` maintains two subscriptions. One for the result of the schedule calls, and one for the the `DiscardableAction`s. The former subscriptions can be swapped out without unsubscribing the previous completed schedule, but I'm not sure about the `DiscardableAction`s; if I unsubscribe them, tests hang because it basically cancels itself and no further task is executed. This might be a conceptual error in `ReentrantScheduler`; perhaps it should not return the entire composite on each schedule call, but rather return the content of the `actionSub` only.", "NaN"], ["644", "Throw the checked exception without declaring it.", "George Campbell", "abersnaze", "01/02/14, 08:01:58 PM", "It uses the deprecated method Thread.stop(Throwable) to throw an exception without declaring it.", "NaN"], ["645", "Operators: startFuture (StartAsync) and deferFuture (DeferAsync)", "David Karnok", "akarnokd", "12/27/13, 06:58:47 PM", "Issue #634\n\nThey are basically 1-2 layer deep indirections around Futures and Observables.", "NaN"], ["646", "Operator BO.forEachFuture", "David Karnok", "akarnokd", "12/27/13, 06:58:52 PM", "Issue #634\n\nI tried to find a random place in BO but it is likely this or the other PRs will not merge one after another.", "NaN"], ["647", "Operation Generate + Timed", "David Karnok", "akarnokd", "01/02/14, 08:36:04 PM", "Issue #49\n\nI hope the `Func1<TState, Long>, TimeUnit` will suffice.\n\nI kept the absolute time variant in the `OperationGenerate` and in tests but haven't exposed them in `Observable`.", "NaN"], ["648", "Reentrant scheduling2", "David Karnok", "akarnokd", "01/02/14, 05:12:53 AM", "Revised version of PR #643.\n- Added `scheduleRunnable()` overloads to `Scheduler` directly to avoid constant wrapping between `Runnable` and `Action0`.\n- Removed the helper interface.\n- Reworked `ReentrantScheduler` to work with a parent scheduler directly.\n- Replaced `ForwardSubscription` with `IncrementalSubscription` as the first one didn't correctly managed the orderly nature of swapping subscriptions: an unfortunate thread scheduling could have swapped in an older subscription before a new subscription.\n\nIn my opinion, the `Scheduler` and its implementations should use `Runnable` as the internal unit of work instead of `Action0`. Since the `Executor`s require `Runnable` anyway, less wrapping means less memory and better performance. The `Scheduler` interface can retain the `Action0` overloads but no other implementation should need to deal with them.", "NaN"], ["649", "Refactored BoundedReplaySubject, concurrency enhancements.", "David Karnok", "akarnokd", "12/22/13, 02:23:37 PM", "Refactored the formerly `rx.operators.OperationReplay.CustomReplaySubject` into `rx.subjects.BoundedReplaySubject` with all sorts of `create` factory methods.\n\nAlso mentioned in the [forum](https://groups.google.com/forum/#!topic/rxjava/SqwS5kz-lRA).\n\nChanged to the concurrency logic:\n\nThe former `Lock` is now split into a `ReadWriteLock`. In write phase, the buffer is updated; in read phase, the observers are notified. New subscribers will enter the read phase so replaying can be run in-parallel with the already subscribed observers.\n\nHowever, the source side of the subject is still blocked while replaying. I can't imagine any non-convoluted way to make this less blocking or lock free.", "NaN"], ["651", "Subjects Refactor - Non-Blocking, Common Abstraction, Performance", "Ben Christensen", "benjchristensen", "12/23/13, 06:36:32 PM", "These changes evolved out of reviewing pull request https://github.com/Netflix/RxJava/pull/605 and code reviewing master branch with @headinthebox and validating functionality against .Net. I also spent some time to figure out a non-blocking design that I believe is working.\n\nThe results for `ReplaySubject` is that it performs faster than what is currently in master and does not block in almost all cases. I have not yet perf-tested the other 3 Subjects.\n- Common logic composed inside SubjectSubscriptionManager used by all 4 Subjects\n- ReplaySubject does not block while replaying to new subscribers\n- Added unit tests and fixed behavior while reviewing with @headinthebox compared to Rx.Net\n- Uses mostly non-blocking approach (I believe it\u2019s all correct, unit and long running tests have been used to prove it. The tests found concurrency problems during development and became stable once I got the design correct. As with all concurrent code I may be missing something.)\n  - The only place it blocks is if a new Observer subscribes, completes replay and `onComplete`/`onError` are in process. It will wait for those to complete before applying the terminal state on itself.\n\nAs for performance, for relative comparison my machine gets these numbers for the master branch:\n\n```\n     * ArrayList with raw values & synchronized access\n     * \n     * Run: 10 - 11,993,341 ops/sec\n     * Run: 11 - 11,719,523 ops/sec\n     * Run: 12 - 11,965,214 ops/sec\n     * Run: 13 - 11,814,730 ops/sec\n     * Run: 14 - 11,947,459 ops/sec\n```\n\nThis commit gets these numbers:\n\n```\n     * ArrayList with raw values & non-blocking (no synchronization)\n     * \n     * Run: 10 - 16,069,678 ops/sec\n     * Run: 11 - 15,954,688 ops/sec\n     * Run: 12 - 16,158,874 ops/sec\n     * Run: 13 - 16,209,504 ops/sec\n     * Run: 14 - 16,151,174 ops/sec\n```\n\nI'm curious about adding bounded support and using a circular-array rather than ArrayList and seeing if it performs better.\n\nThe performance tests are inside `SubjectPerformanceTests` and inspired by tests done in the non-blocking code workshop with Martin Thompson. \n\nSome of the code is not as elegant as I'd like but was done for performance reasons. For example, I had a much more elegant version using a simple linked list but it had horrible performance. Another example is that using `Notification` to wrap every `onNext` so we have a single data structure is very inefficient so it maintains `T` without wrapping and then conditional logic to check for terminal state. These and other things have been determined while doing perf tests during development and I have consciously moved towards performance rather than the most elegant code.\n\nI'd appreciate feedback on concurrency problems if any exist or ways of getting more performance out while achieving the same functional requirements.", "NaN"], ["652", "Subjects fixes performance improvements", "David Karnok", "akarnokd", "12/23/13, 06:36:33 PM", "Based on PR #651 \n\nImprovements upon Ben's excellent work:\n- (Original performance for me was 1.662.152 ops/sec on average.)\n- Storing subscriptions and observers in arrays rather than in a Map inside `SubjectSubscriptionManager.`. This adds +2.340.000 ops/sec on average; total ~ 4.000.000 ops/sec so far.\n- `SafeObserver` uses a volatile for the actual Observer which is swapped to a `nopObserver` if a terminal case occurs. This avoids an atomic get and if statement and adds a +100.000 ops/second on average; total ~4.100.000 ops/sec so far.\n- I suggest adding a create option to set the initial buffer size (not done here) which would reduce the number of array-resizes. With 2048 as a sweet spot on my machine, this adds +1.100.000 ops/second; total 5.200.000 so far.\n\n**Bounded version**\nWe have a boundable ReplaySubject in main named `CustomReplaySubject` and PR #649 to improve a bit upon its performance. It might benefit from the changes above as well. It would be more tricky implementation in terms of the replay operation, since the buffer would be in constant virtual index motion (including its start and end), so observers would need to atomically get a value from it whose index could get below the virtual start index of the buffer. Will think about this.", "NaN"], ["654", "Empty, Error and Never overloads with type witness", "David Karnok", "akarnokd", "12/23/13, 10:22:13 PM", "Witness variants for #653.", "NaN"], ["655", "Skip, SkipLast, Take, TakeLast with time", "David Karnok", "akarnokd", "12/23/13, 11:18:47 PM", "Issue #653", "NaN"], ["657", "Operations Aggregate, Average and Sum with selector", "David Karnok", "akarnokd", "12/27/13, 09:13:33 PM", "Issue #653\n\nRemarks:\n- I know we can combine ops to get one of the new aggregate variant, but I think it might be worth having a direct version which avoids nesting several layers of Observables, Observers and Subscriptions.\n- The `averageInteger` and `sumInteger` (and the other types) are handy if we want to use chained operation invocations (with less overhead):\n\n``` java\nObservable.from(\"a\", \"bb\", \"ccc\").sumInteger(s -> s.length())\n    .toBlockingObservable().single();\n```\n\ninstead of\n\n``` java\nObservable.sumIntegers(Observable.from(\"a\", \"bb\", \"ccc\").map(s -> s.length()))\n    .toBlockingObservable().single();\n```", "NaN"], ["659", "Missing fixes from the subject rewrite", "David Karnok", "akarnokd", "12/23/13, 10:47:12 PM", "Two small changes:\n- Prevent overwriting the terminal notification in `BehaviorSubject` so new subscribers to a terminated subject can see the error/completion.\n- Call `Thread.currentThread().interrupt()` if the `terminationLatch.await()` throws.", "NaN"], ["660", "Hopefully fixed missing notifications if part of the subscription is del...", "David Karnok", "akarnokd", "12/27/13, 09:33:57 PM", "...ayed.\n\nFix suggestion to issue #658.\n\nBasically it is a \"spin-lock\" between onNext and the subscription. It has the additional effect of locking out concurrent subscriptions, but these would most likely clash on the state-swap anyway.", "NaN"], ["661", "Subscriptions Rewrite", "Ben Christensen", "benjchristensen", "12/23/13, 08:38:38 PM", "Refactor rewrite of Subscriptions by @headinthebox and myself after reviewing the various different implementations.\n- We removed `SingleAssignmentSubscription` while trying to reduce surface area and simplify code.\n- Moved to a non-blocking state-machine model that does not lock or busy spin during \"mutation states\"", "NaN"], ["663", "BO.collect and BO.chunkify", "David Karnok", "akarnokd", "02/11/14, 08:34:17 PM", "Refactored BO.collect and BO.chunkify out of PR #636\n\nMentioned in issue #634", "NaN"], ["664", "Operation AsObservable", "David Karnok", "akarnokd", "12/27/13, 04:31:56 PM", "Split from PR #641", "NaN"], ["665", "GroupByUntil with maxGroups", "David Karnok", "akarnokd", "12/27/13, 09:34:56 PM", "Split from #641\n\nPurpose: limit the active groups to a certain number. If new group is opened, the oldest group is closed.", "NaN"], ["667", "Operators Skip, SkipLast, Take with time", "David Karnok", "akarnokd", "12/27/13, 08:22:48 PM", "Rebased version, without the drain scheduler variant.\n- Fixes issue mentioned in #666 as well.", "NaN"], ["668", "Operator forIterable 2", "David Karnok", "akarnokd", "12/27/13, 08:07:37 PM", "Split from #636\n\nThis operator behaves differently than `concat(Iterable)`. It allows projecting a potentially infinite sequence onto Observables concatenated one after each other. The input Iterable sequence is not traversed upfront like concat(Iterable) and concat(Observable) would do.", "NaN"], ["669", "Javadoc improvements:", "David Gross", "DavidMGross", "12/24/13, 05:14:09 AM", "- diagrams for switchCase, doWhile, whileDo, ifThen, delaySubscription, single, singleOrDefault, takeFirst, takeLast (and variant forms of these)\n- standardizing javadoc comment formatting\n- standardizing nomenclature", "NaN"], ["670", "API Design Tweaks", "Ben Christensen", "benjchristensen", "12/24/13, 06:25:26 AM", "Some changes resulting from review with @headinthebox and @jhusain\n\nGeneral principles pursued are to simplify the mental model and surface area of the API.", "NaN"], ["688", "Fix SafeObserver handling of onComplete errors", "Ben Christensen", "benjchristensen", "12/24/13, 06:56:27 AM", "Fixes https://github.com/Netflix/RxJava/issues/630", "NaN"], ["689", "Removed ObserverBase", "David Karnok", "akarnokd", "12/27/13, 04:31:10 PM", "For issue #674\n\nRemoved ObserverBase and adapted JoinObserver1.", "NaN"], ["690", "Fixed Scala bindings", null, "headinthebox", "12/24/13, 06:43:03 PM", "NaN", "NaN"], ["691", "javadoc improvements:", "David Gross", "DavidMGross", "12/24/13, 08:37:05 PM", "- diagrams for switchLatest, mergeMap, concatMap, switchMap, mapWithIndex, doOnNext\n- change text to note deprecation of aggregate\n- standardized formatting\n- force image size in ReplaySubject javadoc", "NaN"], ["693", "Kotlin M6.2", "Mario Arias", "MarioAriasC", "12/26/13, 04:15:48 PM", "Version updated for Kotlin M6.2", "NaN"], ["694", "Change page from \"Mathematical Operators\" to \"Mathematical and Aggregate Operators\"", "David Gross", "DavidMGross", "12/27/13, 04:28:40 PM", "- move toList, reduce, concat, toSortedList, toMap, and toMultiMap to that page\n- deprecate aggregate in favor of reduce\n\n[should I move takeLast, last, and takeLastBuffer to the Aggregate operators page? they don't operate on the aggregate, exactly, but they do wait until the source completes before emitting anything]", "NaN"], ["696", "New contrib module: rxjava-async-util", "Ben Christensen", "benjchristensen", "12/27/13, 09:43:19 PM", "Home for async utility functions with juc.Future, Actions, Functions etc that don\u2019t need to be in rxjava-core.\n\nAs per discussions at:\n- https://github.com/Netflix/RxJava/pull/646#issuecomment-31147005\n- https://github.com/Netflix/RxJava/pull/645#issuecomment-31146492\n- https://github.com/Netflix/RxJava/pull/622#issuecomment-31144128\n\n/cc @akarnokd", "NaN"], ["697", "Manual Merge of Pull #667", "Ben Christensen", "benjchristensen", "12/27/13, 08:22:47 PM", "Manual merge of https://github.com/Netflix/RxJava/pull/667", "NaN"], ["698", "Merge of Pull 657: Average and Sum", "Ben Christensen", "benjchristensen", "12/27/13, 09:13:31 PM", "NaN", "NaN"], ["699", "Repeat Operator", "Ben Christensen", "benjchristensen", "12/27/13, 09:33:49 PM", "- merge and slight modification of https://github.com/Netflix/RxJava/pull/518 done with @headinthebox ", "NaN"], ["700", "various javadoc improvements", "David Gross", "DavidMGross", "12/27/13, 11:02:21 PM", "- diagrams for skip(t), single(), take(t), skipLast(t)\n- adding diagrams, improving javadocs for sumFoo/averageFoo operators\n- adding diagram to repeat()", "NaN"], ["701", "Collect Operator", "Ben Christensen", "benjchristensen", "12/27/13, 09:58:02 PM", "Added with @headinthebox while reviewing Java 8 Streams https://github.com/Netflix/RxJava/issues/678", "NaN"], ["703", "Small Tweaks", "Ben Christensen", "benjchristensen", "12/27/13, 11:00:08 PM", "Some small changes while reviewing code.", "NaN"], ["704", "New contrib module: rxjava-async-util", "David Karnok", "akarnokd", "12/30/13, 05:14:58 PM", "- Added startFuture, deferFuture, forEachFuture operators.\n- Left out the CancellationToken resembling overloads as I was in doubt they can be meaningfully used. If a task is cancelled, it is enough to check the Thread.currentThread().isInterrupted() flag.", "NaN"], ["705", "adjust javadocs for new sumFoo()/averageFoo() method names", "David Gross", "DavidMGross", "12/29/13, 03:18:21 AM", "NaN", "NaN"], ["706", "Clean merge of rxjava-async-util", "Ben Christensen", "benjchristensen", "12/30/13, 05:28:12 PM", "Manual merge of https://github.com/Netflix/RxJava/pull/704 by cherry picking relevant changes.", "NaN"], ["707", "Merge of rxjava-async-util", "Ben Christensen", "benjchristensen", "12/30/13, 06:06:49 PM", "Manual merge of https://github.com/Netflix/RxJava/pull/704", "NaN"], ["708", "Combine latest fix", "Ben Christensen", "benjchristensen", "12/30/13, 06:19:01 PM", "Manual merge of https://github.com/Netflix/RxJava/pull/616\n\nI would like to get a version of this that doesn't use a lock in the `onNext` method but have chosen to merge this for now to get the functionality correct and then followup later with a refactor or rewrite when I or someone else has time.", "NaN"], ["709", "Lotsa javadoc improvements", "David Gross", "DavidMGross", "12/30/13, 10:38:11 PM", "- diagrams for previously-undiagram'd methods\n- links to wiki docs where available\n- standardizing format & nomenclature", "NaN"], ["710", "Created new wiki page for the operators in the Async class", "David Gross", "DavidMGross", "12/31/13, 12:57:28 AM", "...adjusted javadoc links accordingly\n...added new sections for previously un-wiki-documented operators in Async\n...added links to those in javadocs", "NaN"], ["712", "Fix Scheduler Memory Leaks", "Ben Christensen", "benjchristensen", "01/02/14, 05:12:31 AM", "The `NewThreadScheduler`, `CurrentThreadScheduler` and `ExecutorScheduler` all had memory leaks when doing recursion with the `Func2` method signature. This pull request fixes that along with improving the unit test coverage.\n\nThe fix involved treating \"outer\" and \"inner\" schedulers differently, with \"inner\" being the place where recursion happens.\n\nThe memory behavior can be tested using `TestRecursionMemoryUsage`.\n\nThis fixes the problems reported in https://github.com/Netflix/RxJava/pull/643 and  https://github.com/Netflix/RxJava/pull/648 but does not change the `Scheduler` or `Subscription` interfaces or public implementation details.", "NaN"], ["714", "rxjava-computation-expressions", "Ben Christensen", "benjchristensen", "01/02/14, 10:49:25 PM", "The conditional operators are going in this contrib module.\n\nSee https://github.com/Netflix/RxJava/issues/683", "NaN"], ["715", "Add missing type hint to clojure example", "Deleted user", "ghost", "01/03/14, 12:23:47 AM", "#623", "NaN"], ["717", "Added ConnectableObservable", null, "headinthebox", "01/03/14, 04:41:12 PM", "Fixed test\nAdded overload for scan\nAdded trivial test for scan", "NaN"], ["718", "Implemented the Merge overloads", "Shixiong Zhu", "zsxwing", "01/14/14, 03:29:04 AM", "Hi, this PR implemented the overloads of `merge` in #62. Please take a look.", "NaN"], ["720", "Added `Observable.timeout` wrappers to scala adapter", null, "hura", "01/09/14, 05:44:38 PM", "Added the four timeout methods on Observable in the Scala adaptor. Note\nfor the java/scala type interop:\nhttp://stackoverflow.com/q/20912151", "NaN"], ["723", "Deprecate multiple arity \u2018from\u2019", "Ben Christensen", "benjchristensen", "01/06/14, 09:06:02 PM", "- added @Deprecated annotations where it was only part of the Javadoc\n- deprecated \u2018where\u2019 which is a duplicate of `filter` kept from early days matching Rx.Net\n\nSee https://github.com/Netflix/RxJava/issues/686", "NaN"], ["724", "Revert use of CurrentThreadScheduler for Observable.from", "Ben Christensen", "benjchristensen", "01/06/14, 10:05:07 PM", "Use ImmediateScheduler as performance is 4x faster and CurrentThreadScheduler currently offers no benefit (it doesn\u2019t solve the unsubscribe problem).\n\nPerformance numbers:\n\n```\n * Observable.from(Arrays.asList(1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L), scheduler);\n *\n * --- Schedulers.immediate() ---\n *\n * Run: 0 - 1,849,947 ops/sec\n * Run: 1 - 2,076,067 ops/sec\n * Run: 2 - 2,114,688 ops/sec\n * Run: 3 - 2,114,301 ops/sec\n * Run: 4 - 2,102,543 ops/sec\n *\n * --- Schedulers.currentThread() ---\n *\n * Run: 0 - 548,862 ops/sec\n * Run: 1 - 559,955 ops/sec\n * Run: 2 - 581,412 ops/sec\n * Run: 3 - 562,187 ops/sec\n * Run: 4 - 565,723 ops/sec\n\n * Observable.from(Arrays.asList(1L), scheduler);\n *\n * --- Schedulers.immediate() ---\n *\n * Run: 10 - 4,113,672 ops/sec\n * Run: 11 - 4,068,351 ops/sec\n * Run: 12 - 4,070,318 ops/sec\n * Run: 13 - 4,161,793 ops/sec\n * Run: 14 - 4,156,725 ops/sec\n *\n * --- Schedulers.currentThread() ---\n *\n * Run: 10 - 1,692,286 ops/sec\n * Run: 11 - 1,765,054 ops/sec\n * Run: 12 - 1,763,100 ops/sec\n * Run: 13 - 1,770,907 ops/sec\n * Run: 14 - 1,732,291 ops/sec\n```", "NaN"], ["725", "Simpler computation/io naming for Schedulers", "Ben Christensen", "benjchristensen", "01/06/14, 10:05:31 PM", "- simpler (no one remembers the current names when talking about them)\n- does not tie naming to a particular implementation involving thread pools versus a pool of event loops or something similar (as we likely will change the implementation, see https://github.com/Netflix/RxJava/issues/713)", "NaN"], ["726", "The test has to wait on each action independently.", "George Campbell", "abersnaze", "01/09/14, 05:43:26 PM", "Reduced the size of the iterable because I think it was blowing through the stack.", "NaN"], ["727", "ImmediateScheduler optimization for toObservableIterable", "Ben Christensen", "benjchristensen", "01/07/14, 02:20:14 AM", "- the ImmediateScheduler no longer schedules itself but uses a loop\n- 10-20x faster to use a loop rather than schedule itself recursively", "NaN"], ["730", "Improve Error Handling and Stacktraces When Unsubscribe Fails", "Ben Christensen", "benjchristensen", "01/09/14, 06:51:04 AM", "The stacktraces were a mess when onError failed or was not implemented and unsubscribe also failed.\nThat is a far edge case and means code is broken and breaking the Rx contracts \u2026 but that\u2019s just when we need clear stacktraces.\nThe CompositeException and SafeObserver class now do a dance and wire together a causal chain to provide a stacktrace that can identity all the points of error.\nAlso standardized and simplified the RxJavaPlugin.onErrorHandler while working in the vicinity.\n\nThis came about after I was asked to help debug a problem and couldn\u2019t do it by looking at the thrown exception, I had to use a debugger and step through.", "NaN"], ["731", "Replaced 'Thread.sleep' with 'CountDownLatch' to fix the flaky test failures", "Shixiong Zhu", "zsxwing", "01/09/14, 05:45:03 PM", "Fixed the test failures in https://github.com/Netflix/RxJava/issues/383#issuecomment-30081304 and #581", "NaN"], ["732", "Ported groupByUntil function to scala-adapter", "Chris Grimm", "chrisgrimm", "01/14/14, 06:51:37 PM", "Ported the groupByUntil function to scala-adapter. This is my first time contributing, please let me know if anything is off.", "NaN"], ["733", "Buffer with Observable boundary.", "David Karnok", "akarnokd", "01/14/14, 03:32:10 AM", "Mentined in Issue #653.\n- 1 overload where the user can specify the capacity of the internal buffer.", "NaN"], ["734", "Delay with subscription and item delaying observables.", "David Karnok", "akarnokd", "01/14/14, 03:35:27 AM", "Listed in #653\n\nNote: onError and onCompleted events of the source are immediately propagated and will prevent emitting any pending values.", "NaN"], ["735", "Window with Observable boundary.", "David Karnok", "akarnokd", "01/14/14, 03:36:06 AM", "Listed in issue #653.", "NaN"], ["736", "MergeMap with Iterable and resultSelector overloads", "David Karnok", "akarnokd", "01/14/14, 03:41:12 AM", "Listed in #653.", "NaN"], ["738", "Publish and PublishLast overloads", "David Karnok", "akarnokd", "01/14/14, 03:43:32 AM", "Listed in #653\n\nThese operators use the existing multicast and subject infrastructure so I omitted any direct tests.", "NaN"], ["739", "Debounce with selector", "David Karnok", "akarnokd", "01/14/14, 03:45:11 AM", "Listed in #653", "NaN"], ["740", "Timeout with selector overloads", "David Karnok", "akarnokd", "01/14/14, 03:46:02 AM", "Listed in #653.", "NaN"], ["741", "Zip with iterable, removed old aggregator version and updated tests", "David Karnok", "akarnokd", "01/14/14, 08:18:51 AM", "Listed in #653.", "NaN"], ["742", "Build with Gradle 1.10.", "Luke Daley", "ldaley", "01/12/14, 12:16:50 AM", "Required that the IDE plugins also be applied to the root, because of the improved Scala support with the IDEA plugin.", "NaN"], ["743", "Replaces AtomicReference with a length 1 array", "Duarte Nunes", "duarten", "02/11/14, 08:36:02 PM", "This patch replaces the usage of an AtomicReference in BlockingObservable::forEach to hold\nan exception set from within a closure with an array of length 1, thus avoiding the cost of\nthe memory barriers issued when the AtomicReference's internal volatile field is accessed.", "NaN"], ["744", "Observable interface", "Rick Warren", "rickbw", "03/13/14, 04:24:04 PM", "The core purposes of the Observable type\u2014visitation of elements, detection of completion, and detection of errors\u2014are currently tangled with a set of fluent utility methods. This tangling makes the core contract of observability harder to understand, and it makes sub-typing less straightforward and less flexible.\n\nTo resolve this situation, I have refactored an interface out of Observable, which I have tentatively dubbed IObservable. (Ideally, the interface itself would be called Observable, and the class FluentObservable. See Guava's FluentIterable alongside the JDK's Iterable for another example of this pattern. However, I did not want to break backward compatibility.) All public methods now accept IObservable instead of Observable in their argument lists, while those that returned Observable continue to do so. This pattern gives the best of both worlds: any IObservable implementation can be used anywhere Observable and its subclasses can, and we don't lose the convenience of the fluent API. In particular, any IObservable can be converted into an Observable via the new method Observable.from(IObservable).\n\nThis change should be 100% backwards-compatible at compile time, though the changed signatures mean that it is not backwards-compatible at the binary level. I have observed a number of breaking API changes on master over the last few weeks, so hopefully that is not a deal breaker. If it is, we can always restore overloads that accept Observable in addition to IObservable, but that seemed like a pretty large amount of duplication and complexity for a small benefit, so I have not done it so far.", "NaN"], ["745", "Fixed issue #737", "Shixiong Zhu", "zsxwing", "01/14/14, 03:51:00 AM", "Fixed issue #737. Moved the `onCompleted` logic under the condition `latest == id`.", "NaN"], ["747", "Organize, Format, Alphabetize and Finalize", "Ben Christensen", "benjchristensen", "01/15/14, 07:42:31 AM", "Code cleanup after the many new operators that have come in over the past 2 months.\n\n1) Organized imports\n2) Formatted all code for standard whitespace, code formatting etc\n3) Sorted methods in `Observable.java` alphabetically\n4) Updated all license headers\n5) Made `Observable` methods final as they are not intended to be overridden in the rare cases when inheritance makes sense for `Observable`. This better communicates the inheritance intent of the class and prevents against accidental misuse (such as overriding `subscribe` which breaks it).\n\nAnyone have issues with any of these changes (I figure (5) will be the most controversial)?", "NaN"], ["749", "Separated Android test code from source.", "Jeffrey Yu", "wehjin", "01/14/14, 08:20:39 AM", "Moved the nested test classes in the android contrib code into a separate test folder.  The unit-test dependencies were making ProGuard sad, causing it to complain about missing libraries.", "NaN"], ["751", "Provide Observable.timestamp(Scheduler) to be used in the tests.", "Eugene Vigdorchik", "vigdorchik", "02/14/14, 08:40:27 PM", "The test could've used toBlockingObservable, but this hangs, even though timestamped observable is completed.", "NaN"], ["752", "Organize, Format, Alphabetize and Finalize", "Ben Christensen", "benjchristensen", "01/15/14, 07:50:35 AM", "Code cleanup after the many new operators that have come in over the past 2 months.\n\n1) Organized imports\n2) Formatted all code for standard whitespace, code formatting etc\n3) Sorted methods in `Observable.java` alphabetically\n4) Updated all license headers\n5) Made `Observable` methods final as they are not intended to be overridden in the rare cases when inheritance makes sense for `Observable`. This better communicates the inheritance intent of the class and prevents against accidental misuse (such as overriding `subscribe` which breaks it).", "NaN"], ["753", "modify ReplaySubject (with specified capacity) to comply with original reactive extensions behaviour", "Sha", "wangsha", "03/13/14, 04:29:45 PM", "modify ReplaySubject (with specified capacity) to comply with original reactive extensions behaviour\n\nthe capacity of ReplaySubject specifies maximum element count of the replay buffer\n\ncode:\nhttps://rx.codeplex.com/SourceControl/latest#Rx.NET/Source/System.Reactive.Linq/Reactive/Subjects/ReplaySubject.cs\ntest:\nhttps://rx.codeplex.com/SourceControl/latest#Rx.NET/Source/Tests.System.Reactive/Tests/Linq/Subjects/ReplaySubjectTest.cs", "NaN"], ["755", "Add marble diagrams to new operators & variants.", "David Gross", "DavidMGross", "01/15/14, 10:16:08 PM", "Add javadoc \"@deprecated use...\" where appropriate.\nSome javadoc comment reformatting (e.g. overlong lines).", "NaN"], ["760", "Performance Tests Source Folder", "Ben Christensen", "benjchristensen", "01/16/14, 07:51:43 PM", "- Create /src/perf for placing performance tests\n- Start some operator tests and move existing perf tests into this folder.\n- Probably want to explore using https://code.google.com/p/caliper/", "NaN"], ["761", "additional buffer tests", null, "Acardiac", "02/11/14, 08:41:22 PM", "see Issue #756", "NaN"], ["762", "adding javadoc marble diagram for the mergeMap(next,completed,error) variety", "David Gross", "DavidMGross", "01/17/14, 03:23:55 AM", "NaN", "NaN"], ["763", "Added support for custom functions in combineLatest.", "Chris Grimm", "chrisgrimm", "02/11/14, 08:42:31 PM", "NaN", "NaN"], ["765", "A variety of improvements to the javadoc text.", "David Gross", "DavidMGross", "01/21/14, 05:28:31 AM", "NaN", "NaN"], ["766", "Fixed the issue that 'zip' calls 'onCompleted' twice", "Shixiong Zhu", "zsxwing", "01/21/14, 05:29:32 AM", "Fixed the issue reported by Vadim Spivak at https://groups.google.com/forum/#!topic/rxjava/79cWTv3TFp0\n\nThe original `zip` implementation may call `onCompleted` more than once but does not wrap the observer with a `SafeObserver`. When the observer is an internal observer, `zip` will break the Rx contract.\n\nThis PR wraps the internal observer with a `SafeObserver`.", "NaN"], ["767", "Zip fix for multiple onCompleted and moved unsubscribe outside the lock.", "David Karnok", "akarnokd", "01/21/14, 05:29:16 AM", "Also added the test case from the issue.\n\nInstead of #766", "NaN"], ["770", "Bind Operator", "Ben Christensen", "benjchristensen", "01/22/14, 04:13:41 AM", "Implementation of `bind` operator along with new `create` and `subscribe` methods and several reimplemented operators: `fromIterable`, `toList`, `toSortedList`, `map`, `cast`, `timestamp`, `merge`, `flatMap`, `mergeMap`, `groupBy`, `parallel`.\n\nThe `bind` signature is:\n\n``` java\npublic <R> Observable<R> bind(final Func1<Operator<? super R>, Operator<? super T>> bind)\n```\n\nThe new `Operator` class signature is:\n\n``` java\npublic abstract class Operator<T> implements Observer<T>, Subscription\n```\n\nThe `create` method now looks like:\n\n``` java\npublic final static <T> Observable<T> create(final Action1<Operator<? super T>> f)\n```\n\nA new `subscribe` signature is:\n\n``` java\npublic final void subscribe(Operator<? super T> o)\n```\n\nThe use of these three new methods allows for chaining operators together and supporting unsubscription on both synchronous and asynchronous sources.\n##### Status and Plan\n- I have temporarily disabled Scala and Kotlin builds until they are fixed. \n- The Groovy module has been retrofitted with an extension module to intercept and disambiguate the new `create` method from the deprecated one.\n- I have not yet tested Clojure or JRuby\n- I am pretty certain I have the generics wrong on `OperatorMerge` so am using it in non-typesafe manner right now\n\nThis design has been reviewed with several people on Github and in person. Besides resolving the items listed above, my intention is as follows:\n- invite feedback and review on this pull request in the next 12-24 hours\n- merge into trunk if nothing major comes up\n- work towards resolving issues with the language adaptors and polishing any rough edges of the new changes\n- finalize `bind` signatures\n- consider deprecating or eliminating `CurrentThreadScheduler` (if it needs to exist at all, perhaps rename to `TrampolineScheduler` to remove confusion between `Immediate` and `CurrentThread`)\n- release as 0.17.0 (along with some unrelated `Scheduler` changes)\n- continue working in the future migrating operators to this new design\n\nSee https://github.com/Netflix/RxJava/issues/746 for background on the proposal, reasons and design discussion.", "NaN"], ["772", "Various buildscript cleanup.", "Luke Daley", "ldaley", "02/11/14, 08:41:54 PM", "There's a lot of changes here, but I tried to keep them small and incremental.\n\nLet me know if there's anything you're unhappy with and I'll recraft this.", "NaN"], ["774", "Bind pre release", null, "headinthebox", "01/21/14, 11:29:06 PM", "Fixed scala issue (map with index was removed)", "NaN"], ["777", "Fixed testSingleSourceManyIterators", "David Karnok", "akarnokd", "02/11/14, 08:26:06 PM", "Converted to a single-threaded test.", "NaN"], ["778", "Fix zip race condition", "Vadim Spivak", "vadims", "01/22/14, 10:32:07 PM", "The ItemObserver collection logic needs to run in both the OnNext and OnCompleted handlers. \n\nOtherwise, you might have values waiting to be emitted and without seeing an OnCompleted. I couldn't think of an easy unit test for this, it actually took a while to narrow down the example.\n\nThe only way I could reproduce it on my machine was to use Hystrix and it happens somewhat sporadically (10-50 iterations).\n\n``` java\npublic class Test {\n\n  public static class DummyCommand extends HystrixCommand<Integer> {\n\n    protected DummyCommand() {\n      super(HystrixCommandGroupKey.Factory.asKey(\"Dummy\"));\n    }\n\n    @Override\n    protected Integer run() throws Exception {\n      Thread.sleep(1);\n      return 1;\n    }\n  }\n\n  public static void main(String[] args) throws InterruptedException {\n\n    while (true) {\n      Observable.zip(tap(new DummyCommand().observe()), tap(new DummyCommand().observe()), new Func2<Integer, Integer, Integer>() {\n        @Override\n        public Integer call(Integer a, Integer b) {\n          return a + b;\n        }\n      }).toBlockingObservable().single();\n      System.out.println(\"\\n\\n\\n\");\n      Thread.sleep(5);\n    }\n\n  }\n\n  public static Observable<Integer> tap(Observable<Integer> observable) {\n    return observable.doOnEach(new Action1<Notification<? super Integer>>() {\n      @Override\n      public void call(Notification<? super Integer> notification) {\n        System.out.println(\"notification = \" + notification);\n      }\n    });\n  }\n\n}\n```", "NaN"], ["779", "Make operator writing a little less error prone.", "George Campbell", "abersnaze", "01/26/14, 05:38:27 AM", "NaN", "NaN"], ["780", "Added join", null, "headinthebox", "01/23/14, 07:39:53 PM", "Added support for join in the Scala bindings", "NaN"], ["781", "Fixed buglet in join binding, simplified types", null, "headinthebox", "02/06/14, 12:33:06 AM", "Txs to @samuelgruetter for pointing out a small bug involving implicit conversions.\n\nSimplified some of the types of empty, buffer, window, groupBy until to leverage Scala's top and bottom type (we could not do this in C#).", "NaN"], ["783", "Implement some Android UI related operators", "Vladimir Mironov", "nsk-mironov", "02/06/14, 12:33:59 AM", "1. OperatorViewClick\n2. OperatorEditTextInput\n3. OperatorCompoundButtonInput", "NaN"], ["784", "Lift and Observer+Subscription", "Ben Christensen", "benjchristensen", "01/26/14, 05:17:48 AM", "Make `Observer` implement `Subscription` and rename `bind` to `lift` as per decisions in https://github.com/Netflix/RxJava/issues/775\n\nSignatures are now:\n\n``` java\n// Observable.create\npublic final static <T> Observable<T> create(OnSubscribe<T> f)\n\n// Observable.OnSubscribe typed function interface\npublic static interface OnSubscribe<T> extends Action1<Observer<? super T>>\n\n// lift function\npublic <R> Observable<R> lift(final Func1<Observer<? super R>, Observer<? super T>> bind)\n\n// Observer\npublic abstract class Observer<T> implements Subscription {\n     public abstract void onNext(T t);\n     public abstract void onError(Throwable e);\n     public abstract void onCompleted();\n     public final void add(Subscription s)\n     public final void unsubscribe()\n     public final boolean isUnsubscribed()\n}\n\n// Subject\npublic abstract class Subject<T, R> extends Observer<T> {\n    public abstract Observable<R> toObservable();\n}\n```\n\nThis is a major set of changes to the internals, particularly the unit tests because Mockito has issues with abstract classes as opposed to `Observer` being an interface.\n\nThere are still some unit tests failing that I haven't yet figured out:\n- OperationJoinsTest.whenComplicated in rxjava-core\n- OperationConditionalsTest.testDoWhileManyTimes in rxjava-computation-expressions\n- OperationConditionalsTest.testWhileDoManyTimes in rxjava-computation-expressions\n\nI intend on merging this sooner rather than later so everyone can be working off the same codebase, even though I do not consider this code ready for release, even once those unit tests are fixed.\n\nInterestingly, these performance tests on my machine are much better:\n\n``` java\n// OperatorFromIterablePerformance.timeTenLongs()\nv0.16\n     * Run: 10 - 8,096,667 ops/sec\n     * Run: 11 - 8,382,131 ops/sec\n     * Run: 12 - 8,256,288 ops/sec\n     * Run: 13 - 8,139,703 ops/sec\n     * Run: 14 - 8,011,023 ops/sec\n\n... after v0.17 work:\n\n     * Run: 10 - 31,296,553 ops/sec\n     * Run: 11 - 30,080,435 ops/sec\n     * Run: 12 - 31,886,941 ops/sec\n     * Run: 13 - 32,281,807 ops/sec\n     * Run: 14 - 33,519,028 ops/sec\n\n\n// OperatorMapPerformance.timeMapPlusOne();\n\nv0.16\n\n     * Run: 10 - 11,375,632 ops/sec\n     * Run: 11 - 11,390,325 ops/sec\n     * Run: 12 - 11,655,527 ops/sec\n     * Run: 13 - 11,528,440 ops/sec\n     * Run: 14 - 11,321,181 ops/sec\n\n... after v0.17 work:\n\n     * Run: 10 - 17,674,464 ops/sec\n     * Run: 11 - 17,890,239 ops/sec\n     * Run: 12 - 17,919,155 ops/sec\n     * Run: 13 - 16,356,974 ops/sec\n     * Run: 14 - 16,723,414 ops/sec\n\n// OperatorMergePerformance.timeRepetitionsEmissionSynchronous()\n\nv0.16\n\n     * Run: 10 - 32,609,617 ops/sec\n     * Run: 11 - 33,511,839 ops/sec\n     * Run: 12 - 34,768,096 ops/sec\n     * Run: 13 - 32,376,499 ops/sec\n     * Run: 14 - 33,166,835 ops/sec\n\n... after v0.17 work:\n\n     * Run: 10 - 45,945,747 ops/sec\n     * Run: 11 - 46,342,209 ops/sec\n     * Run: 12 - 44,493,090 ops/sec\n     * Run: 13 - 44,999,640 ops/sec\n     * Run: 14 - 47,389,771 ops/sec\n\n```", "NaN"], ["785", "Reimplement Zip Operator Using Lift [Preview]", "Ben Christensen", "benjchristensen", "02/05/14, 03:53:18 AM", "A preview of a re-implementation of the `zip` operator.\n\nThis re-implements the `zip` operator but not yet the `zipIterable` so those unit tests are still failing. I'm submitting early to get a code review and will finish the `zipIterable` sometime early next week.\n\nI have already had the concurrency model reviewed by two others and all unit tests are passing but further review is justified and welcome.\n\nThe performance of this implementation (without doing any profiling) has risen from 1.42m ops/second on v0.16 to 1.67m ops/second as measured on my machine for the simple test `Observable.zip(from(1), from(1), {a, b -> a+b})` and 31k ops/second to 63k ops/second for `Observable.zip(range(0, 100), range(100, 200), {a, b -> a+b})`.", "NaN"], ["786", "Careful With That Global Search And Replace, Eugene.", "David Gross", "DavidMGross", "01/27/14, 06:05:20 PM", "restoring the working URLs of RxJava wiki pages and marble diagrams in the javadocs\nhttp://www.youtube.com/watch?v=AYMyxTFwuz8", "NaN"], ["787", "Fix problem with Observable.create()", "Mario Arias", "MarioAriasC", "01/27/14, 06:05:55 PM", "- Fix problem with Obserable.create()\n- Avoid the use of deprecated methods ", "NaN"], ["788", "Performance benchmark with caliper", "George Campbell", "abersnaze", "02/09/14, 12:29:37 AM", "Minimal changes to get a `./gradlew time` task to accurately benchmark performance changes for #776.\n\nI'm still looking into JHM but I'm not sure how well it will integrate with Rx's gradle build.", "NaN"], ["790", "Convert to scan to use lift", "George Campbell", "abersnaze", "02/12/14, 08:37:07 PM", "I switched the scan to an operator and cleaned up what looked like a lot of unnecessary code from the summing operations.", "NaN"], ["791", "improve switchOnNext description in javadocs", "David Gross", "DavidMGross", "01/30/14, 06:12:32 AM", "also: repair anchors in links to RxJava wiki in javadocs", "NaN"], ["793", "Observer + Subscriber", "Ben Christensen", "benjchristensen", "01/31/14, 06:58:33 AM", "As per discussion in https://github.com/Netflix/RxJava/issues/792 the `abstract class Observer` has been returned to `interface Observer` and there is now `abstract class Subscriber implements Observer<T>, Subscription` to fill that role.\n\nSignatures are now:\n\n``` java\n// Observable.create\npublic final static <T> Observable<T> create(OnSubscribe<T> f)\n\n// Observable.OnSubscribe typed function interface\npublic static interface OnSubscribe<T> extends Action1<Subscriber<? super T>>\n\n// Observable.subscribe\npublic final Subscription subscribe(Subscriber<? super T> subscriber)\npublic final Subscription subscribe(Observer<? super T> observer)\n\n// lift function\npublic <R> Observable<R> lift(final Func1<Subscriber<? super R>, Subscriber<? super T>> bind)\n\n// Observer\npublic interface Observer<T> {\n     public abstract void onNext(T t);\n     public abstract void onError(Throwable e);\n     public abstract void onCompleted();\n}\n\n// Subscriber\npublic abstract class Subscriber<T> implements Observer<T>, Subscription {\n     public final void add(Subscription s)\n     public final void unsubscribe()\n     public final boolean isUnsubscribed()\n}\n\n// Subject \npublic abstract class Subject<T, R> extends Observable<R> implements Observer<T>\n```", "NaN"], ["796", "Add Subscription.isUnsubscribed()", "Ben Christensen", "benjchristensen", "02/01/14, 12:56:52 AM", "With the new model of injecting `Subscription` into functions for synchronous loops to check `isUnsubscribed()` it now makes sense for this to be on the interface of all `Subscription` implementations.", "NaN"], ["797", "Scheduler Outer/Inner [Preview]", "Ben Christensen", "benjchristensen", "02/04/14, 05:19:18 PM", "Following are proposed changes to the `Scheduler` signature based on discussions between @headinthebox and I intended to simplify scheduling and make it easier to do the right thing.\n\nThis originates from three findings:\n\n1) It was very easy to cause memory leaks or inadvertent parallel execution since the distinction between outer and inner scheduling was not obvious.\n\nTo solve this the new design explicitly has the outer `Scheduler` and then `Scheduler.Inner` for recursion.\n\n2) The passing of state is not useful since scheduling over network boundaries with this model does not work.\n\nIn this new design all state passing signatures have been removed. This was determined while implementing a `RemoteScheduler` that attempted to use `observeOn` to transition execution from one machine to another. This does not work because of the requirement for serializing/deserializing the state of the entire execution stack. Migration of work over the network has been bound to be better suited to explicit boundaries established by Subjects. Thus, the complications within the Schedulers are unnecessary.\n\n3) The number of overloads with different ways of doing the same things were confusing.\n\nThis new design removes all but the essential and simplest methods.\n\nThis is the new signature for `Scheduler`:\n\n``` java\npublic abstract class Scheduler {\n\n     // the primary entry point, it immediately schedulers work on a new thread and executes it\n     // the return subscription will shut down the Inner scheduler when unsubscribed\n     public abstract <T> Subscription schedule(Action1<Scheduler.Inner> action);\n     public <T> Subscription schedule(final Action1<Scheduler.Inner> action, final long delayTime, final TimeUnit unit);\n     public int degreeOfParallelism();\n     public long now();\n\n     public abstract class Inner implements Subscription {\n\n         public abstract void schedule(Action1<Scheduler.Inner> action);\n         public abstract void schedule(Action1<Scheduler.Inner> action, long delayTime, TimeUnit unit);\n         public void schedulePeriodically(final Action1<Scheduler.Inner> action, long initialDelay, long period, TimeUnit unit);\n            // I question having schedulePeriodically here, since recursion allow the same behavior, and with conditional logic\n         public void schedule(Action1<Scheduler.Inner> action, Date dueTime);\n      }\n}\n```\n\nThe simplest execution of a single task is:\n\n``` java\nSchedulers.newThread().schedule(new Action1<Inner>() {\n\n    @Override\n    public void call(Inner inner) {\n        doWork();\n    }\n\n});\n```\n\nRecursion is easily invoked:\n\n``` java\nSchedulers.newThread().schedule(new Action1<Inner>() {\n\n    @Override\n    public void call(Inner inner) {\n        doWork();\n        // recurse until unsubscribed (the schedule will do nothing if unsubscribed)\n        inner.schedule(this);\n    }\n\n});\n```\n\nThe use of `Action1<Inner>` on both the outer and inner levels makes it so recursion that refer to `this` and it works easily. \n\nSimilar to the new `lift`/`create` pattern with `Subscriber` the `Inner` is also a `Subscription` so it allows efficient loops with `unsubscribe` support:\n\n``` java\nSchedulers.newThread().schedule(new Action1<Inner>() {\n\n    @Override\n    public void call(Inner inner) {\n        while(!inner.isUnsubscribed()) {\n            doWork();\n        }\n    }\n\n});\n```\n\nAn action can now `unsubscribe` the `Scheduler.Inner`:\n\n``` java\nSchedulers.newThread().schedule(new Action1<Inner>() {\n\n    @Override\n    public void call(Inner inner) {\n        while(!inner.isUnsubscribed()) {\n            int i = doOtherWork();\n            if(i > 100) {\n                // an Action can cause the Scheduler to unsubscribe and stop\n                inner.unsubscribe();\n            }\n        }\n    }\n\n});\n```\n\nTypically just stopping is sufficient:\n\n``` java\nSchedulers.newThread().schedule(new Action1<Inner>() {\n\n    @Override\n    public void call(Inner inner) {\n        int i = doOtherWork();\n        if (i < 10) {\n            // recurse until done 10\n            inner.schedule(this);\n        }\n    }\n\n});\n```\n\nbut if other work in other tasks is being done and you want to unsubscribe conditionally you could:\n\n``` java\nSchedulers.newThread().schedule(new Action1<Inner>() {\n\n    @Override\n    public void call(Inner inner) {\n        int i = doOtherWork();\n        if (i < 10) {\n            // recurse until done 10\n            inner.schedule(this);\n        } else {\n            inner.unsubscribe();\n        }\n    }\n\n});\n```\n\nand the recursion can be delayed:\n\n``` java\nSchedulers.newThread().schedule(new Action1<Inner>() {\n\n    @Override\n    public void call(Inner inner) {\n        doWork();\n        // recurse until unsubscribed ... but delay the recursion\n        inner.schedule(this, 500, TimeUnit.MILLISECONDS);\n    }\n\n});\n```\n\nThe methods on the `Inner` never return a `Subscription` because they are always a single thread/event-loop/actor/etc and controlled by the `Subscription` returned by the initial `Scheduler.schedule` method. This is part of clarifying the contract.\n\nThus an `unsubscribe` controlled from the outside would be done like this:\n\n``` java\nSubscription s = Schedulers.newThread().schedule(new Action1<Inner>() {\n\n    @Override\n    public void call(Inner inner) {\n        while(!inner.isUnsubscribed()) {\n            doWork();\n        }\n    }\n\n});\n\n// unsubscribe from outside\ns.unsubscribe();\n```\n\nI'd appreciate feedback on this design direction.\n\n---\n\nNOTE: This pull request is not yet complete. I have not modified the language adaptors or other modules, and there are 3 unit tests in core failing (related to `buffer` and `window`).", "NaN"], ["800", "issue-799", "Matt Jacobs", "mattrjacobs", "03/13/14, 04:29:53 PM", "This PR is targeted at the 0.16.1 tag, but can be applied cleanly to master as well.  I wanted to have the ability to launch a bugfix 0.16.2 release that's not gated on the large number of changes in master.\n\nFixes #799", "NaN"], ["804", "Operator repeat", "David Karnok", "akarnokd", "02/04/14, 05:27:12 PM", "I've reimplemented repeat() with the new lift/subscriber semantics, but run into a few problems:\n- The previous `observeOn` implementation didn't work for some reason with some of the repeat tests. Haven't really looked into them, but instead reimplemented observeOn with the new semantics and with queue/drain method, which brought up some further issues.\n- Changed the TestScheduler a bit as I've run into cases where the internal queue's order was not of the order of the schedule (typically when using 0 as delay) which caused tests to get rearranged events. Adding a monotonic id helps distinguish between tasks scheduled for the same time.\n- GroupBy had some problem where it duplicated `childObserver.onCompleted` when run with staggered groups. It broke merge. I've added a once-check to it to make it work. Might need to utilize the same completeInner() logic than the groups.\n- Broke `OperationParallelMergeTest`. I'm not sure why they don't work. Maybe it gets 3 parallelism but the thread Ids keep changing underneath. I never understood the expectations in those tests.", "NaN"], ["805", "Fix CompositeException", "Ben Christensen", "benjchristensen", "02/04/14, 05:31:26 PM", "This fixes possible issues where infinite loops could be created if the right combination of Exceptions and causal chains were composed together.", "NaN"], ["806", "Operator repeat", "David Karnok", "akarnokd", "02/04/14, 05:44:57 PM", "I've reimplemented repeat() with the new lift/subscriber semantics, but run into a few problems:\n- The previous `observeOn` implementation didn't work for some reason with some of the repeat tests. Haven't really looked into them, but instead reimplemented observeOn with the new semantics and with queue/drain method, which brought up some further issues.\n- Changed the TestScheduler a bit as I've run into cases where the internal queue's order was not of the order of the schedule (typically when using 0 as delay) which caused tests to get rearranged events. Adding a monotonic id helps distinguish between tasks scheduled for the same time.\n- GroupBy had some problem where it duplicated `childObserver.onCompleted` when run with staggered groups. It broke merge. I've added a once-check to it to make it work. Might need to utilize the same completeInner() logic than the groups.\n- Broke `OperationParallelMergeTest`. I'm not sure why they don't work. Maybe it gets 3 parallelism but the thread Ids keep changing underneath. I never understood the expectations in those tests.", "NaN"], ["807", "Operator Repeat and other operator fixes", "David Karnok", "akarnokd", "02/06/14, 08:46:15 PM", "Reimplemented repeat() which exposed some other problems.\n- Added `QueueDrain` based on [this](http://twistedoakstudios.com/blog/Post8424_deadlocks-in-practice-dont-hold-locks-while-notifying).\n- Added overload of repeat(long n) to repeat a source n times (which is not the same as repeat().take(n) generally). Note that Ben's prototype was not working correctly because it run the re-subscription code in a loop: if subscribeOn was used, it was constantly resubscribing before the old even finished.\n- For some reason, observeOn+take didn't work as expected, causing repeat tests to fail as well. I couldn't determine the cause. I've noticed that `take` was unable to unsubscribe the upstream as there was nothing in its `cs`. \n- To fix the problem above, I've reimplemented observeOn as well. It does not use recursive scheduling but the QueueDrain. \n- This exposed another problem with GroupBy: in some cases, childObserver.onCompleted was sent out twice, breaking merge/flatMap. I've added a once check, but I'm not 100% certain there isn't anything else wrong with the GroupBy's staggered behavior.\n- Unfortunately, `OperationParallelMergeTest` is broken with this PR. I don't quite understand why it doesn't work nor have a clue how to fix it or the new `observeOn`. Maybe the parallel tests relied on thread timing and not expiring too fast so they could continue one them.\n\nPerformance\n\nfrom+repeat: 3.8MOps/s\nfrom+repeat+observeOn: 1.5MOps/s\nrange: 31.8MOps/s\nfrom+observeOn+repeat: 15 kOps/s", "NaN"], ["812", "Fixed OperationSubscribeOn so OperationConditionalsTest works again.", "David Karnok", "akarnokd", "02/05/14, 05:50:34 PM", "Commenting out the inner makes the `OperationConditionalsTest` pass.\n\nUnfortunately, I'm not sure whether this change affects non-Trampolined schedulers in any way or why was there a need to unsubscribe an inner scheduler. It is possible the actual bug is in TrampolineScheduler.", "NaN"], ["814", "RunAsync method for outputting multiple values", "David Karnok", "akarnokd", "02/05/14, 05:43:47 PM", "Added `runAsync` method to allow producing multiple values while running an action on a scheduler.\n\nThe drawback is that the action is run immediately and observers might not get any or all of the produced values. An overload lets the client specify a subject (such as ReplaySubject) to reliably capture all values and replay them to Observers. Otherwise, it just acts as a cold observable with the additional option to cancel the schedule and/or the action.", "NaN"], ["816", "One global onCompleted object", "Samuel Gruetter", "samuelgruetter", "02/05/14, 06:16:46 PM", "issue https://github.com/Netflix/RxJava/issues/662", "NaN"], ["817", "Scala Scheduler Bindings Fix", null, "headinthebox", "02/05/14, 09:45:19 PM", "- Updated schedulers to reflect 0.17 changes.\n- Add timer bindings", "NaN"], ["818", "CompositeSubscription memory reduction", "David Karnok", "akarnokd", "02/05/14, 09:45:09 PM", "Since CompositeSubscription is now used everywhere with Subscriber, I looked at the code again and tried to reduce memory consumption. I've added CLEAR_STATE_UNSUBSCRIBED singleton to transition into when unsubscribed. Note that the previous version kept the subscription array after the unsubscription, keeping references to other subscriptions alive (although unsubscribed); I'm not certain why unsubscription didn't simply discard the array before.\n\nI've played with changing the `add` and `remove` methods (not included in this PR) to do more direct array manipulation with about 10-40% speed increase for tests like add directly followed by remove. The speed increase comes from:\n- using arraycopy to avoid dynamic array creation in copyOf,\n- handling case where CS contains a single item to be removed and transitions into CLEAR_STATE instead of creating a new empty state.\n\nSimilar memory reduction could be implemented in MAS and SAS.", "NaN"], ["819", "CompositeSubscription performance increase", "David Karnok", "akarnokd", "02/05/14, 10:26:02 PM", "- Optimized the case when the composite holds only a single element.\n- Replaced Arrays.copyOf with regular arraycopy to avoid the cost of reflective array creation\n- Included perf test where I got 32% increase on my i7 4770K", "NaN"], ["820", "Git keeps modifying this file so committing it how it wants it.", "Ben Christensen", "benjchristensen", "02/06/14, 12:11:01 AM", "NaN", "NaN"], ["821", "Update to use Subscriber/Subscriptions.create", "Ben Christensen", "benjchristensen", "02/06/14, 12:38:16 AM", "Master had changed since the pull request.", "NaN"], ["822", "Reimplement 'subscribeOn' using 'lift'", "Shixiong Zhu", "zsxwing", "02/07/14, 04:04:39 AM", "hi, this PR reimplemented the `subscribeOn` using `lift`. However, both the original and current implementation can not guarantee that `unsubscribe` is always called in the `scheduler`. An extreme example is:\n\n``` java\n    public static void main(String[] args) throws InterruptedException {\n        Observable.create(new OnSubscribe<Integer>() {\n\n            @Override\n            public void call(final Subscriber<? super Integer> t1) {\n                final Subscription s = Subscriptions.create(new Action0() {\n\n                    @Override\n                    public void call() {\n                        System.out.println(Thread.currentThread().getName());\n                    }\n                });\n                t1.add(s);\n                new Thread(new Runnable() {\n\n                    @Override\n                    public void run() {\n                        t1.unsubscribe();\n                    }\n\n                }, \"test\").start();\n                try {\n                    Thread.sleep(10000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                t1.onCompleted();\n            }\n        }).subscribeOn(Schedulers.newThread()).subscribe();\n        Thread.sleep(10000);\n    }\n```\n\nwill output \"test\".", "NaN"], ["824", "Set setDaemon on NewThreadScheduler", "David Karnok", "akarnokd", "02/06/14, 07:47:09 PM", "First noticed by @zsxwing.", "NaN"], ["826", "Return wrapped Subscription", "Ben Christensen", "benjchristensen", "02/06/14, 07:45:27 PM", "- make sure the SafeSubscriber is included in what is returned\n- then return as Subscription not Subscriber so it can't be cast back to a Subscriber", "NaN"], ["827", "Fixed cut & paster error in io scheduler", null, "headinthebox", "02/06/14, 08:28:03 PM", "Thanks @samuelgruetter for pointing this out. ", "NaN"], ["828", "Repeat Operator", "Ben Christensen", "benjchristensen", "02/06/14, 08:22:28 PM", "Based on code and discussion in https://github.com/Netflix/RxJava/pull/807/files", "NaN"], ["829", "adding marble diagrams, see-also links to javadocs of new repeat() variants", "David Gross", "DavidMGross", "02/07/14, 03:56:05 AM", "NaN", "NaN"], ["832", "[Issue #831] Fix for OperationJoin race condition", null, "duncani", "02/07/14, 04:09:48 AM", "This is to fix the race condition outlined in issue #831 .\nThe join now grabs a copy of the other side's id in the first critical section then won't go higher than that in the iteration of the other side's values (now using entrySet()).", "NaN"], ["833", "Take operator was breaking the unsubscribe chain", "Ben Christensen", "benjchristensen", "02/07/14, 03:51:58 AM", "Fixes issue https://github.com/Netflix/RxJava/issues/830", "NaN"], ["834", "Update clojure for 0.17", "Dave Ray", "daveray", "02/07/14, 06:32:43 AM", "Updated interop for `OnSubscribe` interface. Updated readme and examples.", "NaN"], ["835", "ObserveOn Operator with Backpressure", "Ben Christensen", "benjchristensen", "02/09/14, 12:26:20 AM", "This is a re-implementation of ObserveOn done for 3 purposes:\n\n1) Migrate to new `lift` style so the `Subscription` flows through correctly\n2) Eliminate the wasted first schedule step (reported by @mttkay  https://github.com/Netflix/RxJava/pull/797#issuecomment-34044956)\n3) Eliminate buffering so it naturally provides back pressure \n\nUnit tests are passing on my machine for a full build, but I'm interested in user experience, particularly from Android users where `observeOn` behavior is mission critical.\n\nThis WILL change behavior and possibly cause problems if `observeOn` was being used to make something async (which is not the purpose of `observeOn`. The `subscribeOn` operator is the one to use for making something ~~async~~ concurrent. [Update: Per discussions below we may want another operator or `observeOn` overload to allow async behavior to use a queue and decouple producer/consumer. The `observeOn` operator however should by default only do what it says - switch threads.]\n\nThis is a complete re-write so I may very well have created nasty bugs that we don't yet have unit tests for so I'd appreciate a thorough review and testing.\n\nOne possible concern is performance. In the case of a synchronous firehose (not the normal use case, but a use case nonetheless), this is far slower because now each `onNext` is sent one-at-a-time across thread boundaries whereas before it would put everything into a queue on one side then read it all from the queue on the other side. \n\nThus, for this code that synchronously firehoses 100000 values it is about 7 times faster on the current code without back-pressure:\n\n``` java\nlong last = Observable.range(0, 100000).observeOn(Schedulers.newThread()).toBlockingObservable().last();\n```\n\nHowever, this code is the same performance:\n\n``` java\nlong last = Observable.interval(1, TimeUnit.MILLISECONDS).take(1000).observeOn(Schedulers.newThread()).toBlockingObservable().last();\n```\n\nThe difference being that we're not just filling up the queue in the second one as it has latency.\n\nI believe this is okay as the intent of `observeOn` is moving across thread boundaries, such as for UI events, and eliminating the bad behavior of buffer-bloat is the right thing. \n\nI'm sure we can find some performance improvements in this code, but it's worth pointing out how the change in behavior can affect it.", "NaN"], ["836", "Setting up the new subproject for debugging observable chains.", "George Campbell", "abersnaze", "02/11/14, 08:31:08 PM", "By creating and registering this plugin you get a complete log of all the events (subscribe, onNext, onError, onCompleted and unsubscribe) that happen in all observables, observers and subscribers. The debug hook also takes a Func1 for transforming data before they are sent to actual onNext functions.\n\nThis pull request is for the raw data.  There isn't any persistence or visualization of the data generated yet.\n\nHere is an example of a simple observable chain\n\n```\nfrom(1, 3).flatMap({ it -> from(it, it + 1) }).take(3).subscribe()\n```\n\nAnd the stream of notifications sent.\n\n```\n{ \"nano\": 1391761208271225000, \"thread\": 1, \"observer\": \"rx.Observable$27@3290a11e\", \"type\": \"Subscribe\", \"source\": \"rx.Observable$2@3541d281\"}\n{ \"nano\": 1391761208272832000, \"thread\": 1, \"observer\": \"rx.operators.OperatorTake$1@f81c4a1\", \"type\": \"Subscribe\", \"source\": \"rx.Observable$2@10942dfb\", \"to\": \"rx.operators.OperatorTake@7056c23d\"}\n{ \"nano\": 1391761208275469000, \"thread\": 1, \"observer\": \"rx.operators.OperatorMerge$1@49c5146e\", \"type\": \"Subscribe\", \"source\": \"rx.Observable$2@29c06798\", \"to\": \"rx.operators.OperatorMerge@16d14192\"}\n{ \"nano\": 1391761208275644000, \"thread\": 1, \"observer\": \"rx.operators.OperatorMap$1@427e3f2\", \"type\": \"Subscribe\", \"source\": \"rx.operators.OperatorFromIterable@56e626ff\", \"to\": \"rx.operators.OperatorMap@200a5beb\"}\n{ \"nano\": 1391761208276707000, \"thread\": 1, \"observer\": \"rx.operators.OperatorMap$1@427e3f2\", \"type\": \"OnNext\", \"value\": \"1\", \"to\": \"rx.operators.OperatorMap@200a5beb\"}\n{ \"nano\": 1391761208276839000, \"thread\": 1, \"observer\": \"rx.operators.OperatorMerge$1@49c5146e\", \"type\": \"OnNext\", \"value\": \"rx.Observable@299b78d4\", \"from\": \"rx.operators.OperatorMap@200a5beb\", \"to\": \"rx.operators.OperatorMerge@16d14192\"}\n{ \"nano\": 1391761208277012000, \"thread\": 1, \"observer\": \"rx.operators.OperatorMerge$1$InnerObserver@2b6dd9c5\", \"type\": \"Subscribe\", \"source\": \"rx.operators.OperatorFromIterable@38f42ac9\"}\n{ \"nano\": 1391761208277075000, \"thread\": 1, \"observer\": \"rx.operators.OperatorMerge$1$InnerObserver@2b6dd9c5\", \"type\": \"OnNext\", \"value\": \"1\"}\n{ \"nano\": 1391761208277166000, \"thread\": 1, \"observer\": \"rx.operators.OperatorTake$1@f81c4a1\", \"type\": \"OnNext\", \"value\": \"1\", \"from\": \"rx.operators.OperatorMerge@16d14192\", \"to\": \"rx.operators.OperatorTake@7056c23d\"}\n{ \"nano\": 1391761208277243000, \"thread\": 1, \"observer\": \"rx.Observable$27@3290a11e\", \"type\": \"OnNext\", \"value\": \"1\", \"from\": \"rx.operators.OperatorTake@7056c23d\"}\n{ \"nano\": 1391761208277338000, \"thread\": 1, \"observer\": \"rx.operators.OperatorMerge$1$InnerObserver@2b6dd9c5\", \"type\": \"OnNext\", \"value\": \"2\"}\n{ \"nano\": 1391761208277397000, \"thread\": 1, \"observer\": \"rx.operators.OperatorTake$1@f81c4a1\", \"type\": \"OnNext\", \"value\": \"2\", \"from\": \"rx.operators.OperatorMerge@16d14192\", \"to\": \"rx.operators.OperatorTake@7056c23d\"}\n{ \"nano\": 1391761208277471000, \"thread\": 1, \"observer\": \"rx.Observable$27@3290a11e\", \"type\": \"OnNext\", \"value\": \"2\", \"from\": \"rx.operators.OperatorTake@7056c23d\"}\n{ \"nano\": 1391761208277557000, \"thread\": 1, \"observer\": \"rx.operators.OperatorMerge$1$InnerObserver@2b6dd9c5\", \"type\": \"OnCompleted\"}\n{ \"nano\": 1391761208279076000, \"thread\": 1, \"observer\": \"rx.operators.OperatorMap$1@427e3f2\", \"type\": \"OnNext\", \"value\": \"3\", \"to\": \"rx.operators.OperatorMap@200a5beb\"}\n{ \"nano\": 1391761208279154000, \"thread\": 1, \"observer\": \"rx.operators.OperatorMerge$1@49c5146e\", \"type\": \"OnNext\", \"value\": \"rx.Observable@24d8116d\", \"from\": \"rx.operators.OperatorMap@200a5beb\", \"to\": \"rx.operators.OperatorMerge@16d14192\"}\n{ \"nano\": 1391761208279252000, \"thread\": 1, \"observer\": \"rx.operators.OperatorMerge$1$InnerObserver@65601e00\", \"type\": \"Subscribe\", \"source\": \"rx.operators.OperatorFromIterable@951c5ff\"}\n{ \"nano\": 1391761208279322000, \"thread\": 1, \"observer\": \"rx.operators.OperatorMerge$1$InnerObserver@65601e00\", \"type\": \"OnNext\", \"value\": \"3\"}\n{ \"nano\": 1391761208279409000, \"thread\": 1, \"observer\": \"rx.operators.OperatorTake$1@f81c4a1\", \"type\": \"OnNext\", \"value\": \"3\", \"from\": \"rx.operators.OperatorMerge@16d14192\", \"to\": \"rx.operators.OperatorTake@7056c23d\"}\n{ \"nano\": 1391761208279483000, \"thread\": 1, \"observer\": \"rx.Observable$27@3290a11e\", \"type\": \"OnNext\", \"value\": \"3\", \"from\": \"rx.operators.OperatorTake@7056c23d\"}\n{ \"nano\": 1391761208279562000, \"thread\": 1, \"observer\": \"rx.Observable$27@3290a11e\", \"type\": \"OnCompleted\", \"from\": \"rx.operators.OperatorTake@7056c23d\"}\n{ \"nano\": 1391761208279692000, \"thread\": 1, \"observer\": \"rx.Observable$27@3290a11e\", \"type\": \"Unsubscribe\", \"from\": \"rx.operators.OperatorTake@7056c23d\"}\n{ \"nano\": 1391761208279756000, \"thread\": 1, \"observer\": \"rx.operators.OperatorTake$1@f81c4a1\", \"type\": \"Unsubscribe\", \"from\": \"rx.operators.OperatorMerge@16d14192\", \"to\": \"rx.operators.OperatorTake@7056c23d\"}\n{ \"nano\": 1391761208279830000, \"thread\": 1, \"observer\": \"rx.operators.OperatorMerge$1@49c5146e\", \"type\": \"Unsubscribe\", \"from\": \"rx.operators.OperatorMap@200a5beb\", \"to\": \"rx.operators.OperatorMerge@16d14192\"}\n{ \"nano\": 1391761208279880000, \"thread\": 1, \"observer\": \"rx.operators.OperatorMap$1@427e3f2\", \"type\": \"Unsubscribe\", \"to\": \"rx.operators.OperatorMap@200a5beb\"}\n{ \"nano\": 1391761208279946000, \"thread\": 1, \"observer\": \"rx.operators.OperatorMerge$1$InnerObserver@2b6dd9c5\", \"type\": \"Unsubscribe\"}\n{ \"nano\": 1391761208280018000, \"thread\": 1, \"observer\": \"rx.operators.OperatorMerge$1$InnerObserver@65601e00\", \"type\": \"Unsubscribe\"}\n{ \"nano\": 1391761208280085000, \"thread\": 1, \"observer\": \"rx.operators.OperatorMap$1@427e3f2\", \"type\": \"OnCompleted\", \"to\": \"rx.operators.OperatorMap@200a5beb\"}\n{ \"nano\": 1391761208280150000, \"thread\": 1, \"observer\": \"rx.operators.OperatorMerge$1@49c5146e\", \"type\": \"OnCompleted\", \"from\": \"rx.operators.OperatorMap@200a5beb\", \"to\": \"rx.operators.OperatorMerge@16d14192\"}\n```", "NaN"], ["837", "Perf with JMH", "George Campbell", "abersnaze", "02/09/14, 12:29:34 AM", "#776 This is a small change on top of perf with Caliper to performance benchmarking with JMH.", "NaN"], ["838", "Make Scala OnCompleted Notification an object", "Samuel Gruetter", "samuelgruetter", "02/09/14, 12:27:25 AM", "This should solve issue https://github.com/Netflix/RxJava/issues/662 and https://github.com/Netflix/RxJava/pull/584 .", "NaN"], ["839", "Error Handling: OnErrorNotImplemented and java.lang.Error", "Ben Christensen", "benjchristensen", "02/08/14, 06:45:40 AM", "Special Handling of java.lang.Error and OnErrorNotImplemented\n- https://github.com/Netflix/RxJava/issues/748#issuecomment-32471495\n- https://github.com/Netflix/RxJava/issues/771\n- https://github.com/Netflix/RxJava/issues/789", "NaN"], ["841", "Range OnSubscribe", "Ben Christensen", "benjchristensen", "02/09/14, 03:25:04 AM", "Reimplemented as a simple loop instead of Iterable. \n\nSimpler code gives a performance bump:\n\n```\n     * -- 0.17\n     * \n     * Run: 10 - 271,147,198 ops/sec\n     * Run: 11 - 274,821,481 ops/sec\n     * Run: 12 - 271,632,295 ops/sec\n     * Run: 13 - 277,876,014 ops/sec\n     * Run: 14 - 274,821,763 ops/sec\n     * \n     * -- 0.16.1\n     * \n     * Run: 10 - 222,104,280 ops/sec\n     * Run: 11 - 224,311,761 ops/sec\n     * Run: 12 - 222,999,339 ops/sec\n     * Run: 13 - 222,344,174 ops/sec\n     * Run: 14 - 225,247,983 ops/sec\n```", "NaN"], ["842", "Test Unsubscribe", "Ben Christensen", "benjchristensen", "02/09/14, 03:32:42 AM", "- also cleaned up some stuff I remembered after merging last commits", "NaN"], ["843", "Updating StringObservable", "George Campbell", "abersnaze", "02/11/14, 08:33:14 PM", "Updating StringObservable to use lift\nAnd added from(InputStream) and from(Reader)", "NaN"], ["845", "Fix problem with Subscription", "Mario Arias", "MarioAriasC", "02/10/14, 11:20:34 PM", "- Fix problem with anonymous implementation of Subscription\n- Enable Kotlin module ", "NaN"], ["846", "Added overloaded createRequest method that takes an HttpContext instance", "Johan Haleby", "johanhaleby", "02/11/14, 08:25:45 PM", "An HttpContext is needed when doing for example preemptive digest authentication with HTTP Client.", "NaN"], ["847", "Various Changes While Fixing GroupBy", "Ben Christensen", "benjchristensen", "02/11/14, 08:07:46 AM", "NaN", "NaN"], ["848", "Attempt at SubscribeOn \"Time Gap\" Issue [Preview]", "Ben Christensen", "benjchristensen", "02/11/14, 10:26:02 PM", "This is an attempt at solving the `subscribeOn` \"time gap\" issue that I found to be affecting unit tests and use cases such as `parallel`. \n\nMore information and discussion is at https://github.com/Netflix/RxJava/issues/844\n\nCurrently I have made this work by having a trigger on `Subscriber.onSubscribe()` that I'm not thrilled with but want to show this for discussion.", "NaN"], ["849", "Add 'Fragment-Host' to rxjava-contrib modules for OSGi", null, "Acardiac", "02/11/14, 08:19:06 PM", "avoid split packages\nhttp://wiki.osgi.org/wiki/Split_Packages\n\nsee also discussion #154", "NaN"], ["850", "Subscribe on gap", "David Karnok", "akarnokd", "02/11/14, 11:07:47 PM", "Changed @benjchristensen code a bit to allow cancelling a delayed async subscription. Fixed up the `testNewSubscriberDoesntBlockExisting` test: the original deadlocked due the synchronous changes to the subscription model.\n\nIn order to let the async subscription work non-disruptively, I had to add a `delete` method to `CompositeSubscription` which removes a subscription without unsubscribing it. This is necessary to not cancel an inner scheduler.\n\nUnfortunately, some Async tests fail due to deadlock now.\n\nThis PR is not really meant for merge but only for demonstration purposes.", "NaN"], ["851", "Reimplement the timeout operator and fix timeout bugs", "Shixiong Zhu", "zsxwing", "02/11/14, 08:24:47 PM", "This PR reimplemented the `timeout` operator. I also fixed the following bugs of `timeout`:\n- The `timeout` can not work on a synchronized Observable. Unit test:\n  https://github.com/zsxwing/RxJava/commit/356a6902a6e96e4d1a131d71521b62d26596fd6c#diff-f181dce6b07869d0daacb404a292ce0cR231\n- The selector variant of Timeout should throw `TimeoutException` when a timeout event happens without an other Observable. Unit test: https://github.com/zsxwing/RxJava/commit/356a6902a6e96e4d1a131d71521b62d26596fd6c#diff-836fc7028db94329e793dcc6075a258dR259\n  and\n  https://github.com/zsxwing/RxJava/commit/356a6902a6e96e4d1a131d71521b62d26596fd6c#diff-836fc7028db94329e793dcc6075a258dR289\n- The selector variant of Timeout has a race condition between `onNext` and `timeout` methods. Unit test: https://github.com/zsxwing/RxJava/commit/356a6902a6e96e4d1a131d71521b62d26596fd6c#diff-836fc7028db94329e793dcc6075a258dR321\n- The method signatures of some selector variants of Timeout are wrong.", "NaN"], ["852", "rxjava-debug", "Ben Christensen", "benjchristensen", "02/11/14, 08:31:07 PM", "Manual merge of https://github.com/Netflix/RxJava/pull/836", "NaN"], ["853", "StringObservable Update", "Ben Christensen", "benjchristensen", "02/11/14, 08:33:13 PM", "Manual merge of https://github.com/Netflix/RxJava/pull/843", "NaN"], ["854", "The onCreate hook disappeared", "George Campbell", "abersnaze", "02/11/14, 10:59:42 PM", "I think in the merging this hook disappeared from the original pull request for the debug hooks.", "NaN"], ["855", "Move InterruptibleBlockingQueue Inside ObserveOn", "Ben Christensen", "benjchristensen", "02/11/14, 10:59:28 PM", "I decided I'm not ready to commit to this in the public API so am leaving it an implementation detail of ObserveOn.\nWhile working on groupBy, parallel and subscribeOn this queue was not the right solution.", "NaN"], ["856", "SchedulePeriodically Signature", "Ben Christensen", "benjchristensen", "02/12/14, 05:56:34 PM", "This pull requests adds `TimeUnit delayUnit` to the signature:\n\n``` java\npublic Subscription schedulePeriodically(final Action1<Scheduler.Inner> action, long initialDelay, TimeUnit delayUnit, long period, TimeUnit periodUnit)\n```\n\nThis was derived from feedback from @headinthebox while writing the Scala APIs.\n\nReason for ... \n- it better matches languages that have a single object that represent both together such as Scala.\n- Java 8 adds `Duration`: http://download.java.net/jdk8/docs/api/java/time/Duration.html \n\nReason against ... \n- Java 7 and earlier doesn't do it this way on their Executor.\n- Java 8 despite adding `Duration` still doesn't use it on their `ScheduledExecutorService`\n\nThoughts, concerns, opinions?", "NaN"], ["857", "Change Lift to use rx.Observable.Operator", "Ben Christensen", "benjchristensen", "02/12/14, 01:05:26 AM", "The generics insanity has to stop.\n\nThis pull request is a result of @abersnaze and I continuing to fail to make generics work with this signature:\n\n``` java\nFunc1<Subscriber<? super R>, Subscriber<? super T>>\n```\n\nIt all fell apart while trying to do things that needed the equivalent of:\n\n``` java\nFunc1<Subscriber<? super R>, Subscriber<? super ? super T>>\n```\n\n... and other such variants.\n\nWith this change I can also finally get the `OperatorMerge` generics to work. \n\nThus, the `Operator` type exists inside `Observable` just like `OnSubscribe` like this:\n\n``` java\n    /**\n     * Operator function for lifting into an Observable.\n     */\n    public interface Operator<R, T> extends Func1<Subscriber<? super R>, Subscriber<? super T>> {\n        // cover for generics insanity\n    }\n```\n\nThis gives us imports like this:\n\n``` java\nimport rx.Observable;\nimport rx.Observable.OnSubscribe;\nimport rx.Observable.Operator;\n```\n\nI know it's not as pure as having `lift(Func1)` but this is far more usable.\n\n``` java\npublic <R> Observable<R> lift(final Operator<R, T> bind)\n```\n\nIf anyone has a different suggestion that still solves the generics issue please let me know.", "NaN"], ["859", "Add 'Fragment-Host' to rxjava-contrib/debug module for OSGi", null, "Acardiac", "02/12/14, 03:41:52 AM", "see #849", "NaN"], ["860", "Fixing the generics for merge and lift", "George Campbell", "abersnaze", "02/12/14, 05:27:17 PM", "I've tracked down to two problems #858 \n\nThe first is that lift wasn't quite right. I changed the lift argument from `Operator<R, T>` to `Operator<? extends R, ? super T>`.  Unfortunately Java won't let us hide that away in the `Operator` class so we have to redeclare that everywhere in the debug hooks but it's still better than the alternative of having to use the full `Func1<? extends Subscriber<? super R>, ? super Subscriber<? super T>>` everywhere.\n\nThe second problem was in the return type of merge `Observable<T>`.  Because of operators like `merge(Observable<? extends T> t1, Observable<? extends T> t2)` the only thing that can be said for the return type is that it is also `Observable<? extends T>` but at the moment it is returning `Observable<T>`.\n\nThis pull request changes all of them and leads to some silly return values like\n\n```\nObservable<String> a, b;\nObservable<? extends String> x = merge(a, b);\n```", "NaN"], ["861", "Proposed solution to the time gap, using unbounded buffering.", "David Karnok", "akarnokd", "02/12/14, 01:20:34 PM", "This is a solution to the time gap problem for #844.\n- Currently, it uses an unbounded buffer. I'll think about a bounded approach later on.\n- I've added an subscribeOn overload where the user can explicitly request a buffering behavior. In addition, SubscribeOn checks the type of the Observable and enters buffering mode for GroupedObservable and PublishSubject. I think these code options should be mutually exclusive: \n  1. either we only check for Observable type, but then new kinds of observables or hidden observables won't work,\n  2. or ask the programmer in the documentation/tutorial to explicitly request buffering in certain operator compositions.\n\nI personally favor option 2).", "NaN"], ["862", "Update the timeout docs", "Shixiong Zhu", "zsxwing", "02/12/14, 05:28:23 PM", "Updated the timeout docs.", "NaN"], ["863", "Optimize SwingMouseEventSource.fromRelativeMouseMotion", null, "Acardiac", "02/12/14, 05:28:08 PM", "do it more functional way\nsee the trick here:\nhttp://www.introtorx.com/Content/v1.0.10621.0/12_CombiningSequences.html#Zip", "NaN"], ["864", "Blocking buffer until experiment", "David Karnok", "akarnokd", "02/14/14, 03:35:28 AM", "This is a solution to the time gap problem for #844.\n\nI've added an subscribeOn overload where the user can explicitly request a buffering behavior. In addition, SubscribeOn checks the type of the Observable and enters buffering mode for GroupedObservable and PublishSubject. I think these code options should be mutually exclusive:\n1. either we only check for Observable type, but then new kinds of observables or hidden observables won't work,\n2. or ask the programmer in the documentation/tutorial to explicitly request buffering in certain operator compositions.\n\nI personally favor option 2).\n\nA drawback is that this blocking subscribeOn deadlocks on pools with a single thread. We can, of course, check for Trampoline, Test and Immediate schedulers, but not schedulers created via `Schedulers.executor`, or the computation scheduler on a single-core machine.", "NaN"], ["866", "Update OperationScan to OperatorScan", "Ben Christensen", "benjchristensen", "02/12/14, 09:21:31 PM", "Migrate to use updated conventions of Operator\\* classes that implement rx.Observable.Operator", "NaN"], ["868", "Zip Bug UnitTest: Never Completes When Zero Observables (Obsolete)", "Todd Nine", "tnine", "02/21/14, 09:37:26 PM", "Hey guys,\n  I discovered this issue today in Rx.  I'm not sure if it's a bug, or as designed.  I've added the test.  Can you let me know if it is in fact a bug, then I'll correct the issue?", "NaN"], ["869", "subscribeOn + groupBy", "Ben Christensen", "benjchristensen", "02/14/14, 08:01:40 PM", "Some changes on top of https://github.com/Netflix/RxJava/pull/864 as part of work on https://github.com/Netflix/RxJava/issues/844.\n\nPrimarily I did two things here:\n- get unsubscribe working again via `subscribeOn` for synchronous `Observable`s\n- leverage new `subscribeOn` behavior to make the `groupBy` unit tests work", "NaN"], ["870", "Add the selector variants of timeout in RxScala", "Shixiong Zhu", "zsxwing", "02/13/14, 05:16:41 PM", "This PR added the selector variants of the `timeout` operator in the Scala and also added two examples.", "NaN"], ["871", "Blocking zip operator", "David Karnok", "akarnokd", "03/04/14, 05:15:38 PM", "Proposed solution to #867\n- Added overloads to zip many and zip 2 only. If my approach is favorable, other overloads can be added.\n  - Javadoc might need some rephrasing.\n- Contains fix for #868 but no test.\n- Overloads take a bufferSize > 0 indicating the queue size, bufferSize <= 0 behaves as the original zip.\n  - Due to the internals of zip, a bufferSize of 0 does not work (i.e., everyone blocks on add and noone can call tick). For that, zip would need different internals with CyclicBarrier and other magic. ~~**Should I work on this case as well?**~~\n- Source completion is blocking as well right now; for example, an empty producer with a slow partner will complete only if the slow partner fires its first event. ~~**Should it terminate as soon as possible?**~~\n\nUpdate:\n- Added 0-length buffering mode, bufferSize < 0 now indicates unlimited buffering.\n- Changed buffered mode to finish as soon as possible", "NaN"], ["874", "Update CompositeSubscriptionTest.java", "Dave Moten", "davidmoten", "02/14/14, 06:31:00 PM", "Fix apparent typo, unsubscription of s2 was not checked and should have been.", "NaN"], ["875", "Bounded replay subject proposal", "David Karnok", "akarnokd", "03/13/14, 04:31:09 PM", "Proposal for #865. (Not really for merging.)\n\nSubscription and unsubscription is serialized with the regular events so this implementation should solve #658 as well. A property of this implementation due to queue/drain approach is that a new subscriber's thread might steal the processing loop. To mitigate this, scheduler overloads are provided to capture the processing loop.\n\nUnfortunately, the performance is 2-3 times worse in unbounded mode compared against current ReplaySubject implementation when run with a simple 1M onNext calls. The replay after completion is about 10% slower.\n\nI would guess the enqueue/dequeue operation adds quite a substantial overhead.", "NaN"], ["876", "Manual Merge of #750", "Ben Christensen", "benjchristensen", "02/14/14, 08:40:27 PM", "Manual merge of https://github.com/Netflix/RxJava/pull/751", "NaN"], ["877", "Correct synchronization guard in groupByUntil", "Pyry Jahkola", "pyrtsa", "02/14/14, 08:46:23 PM", "Can't see how `synchronized (key) { ... }` could have been correct here; `key` will hardly ever be the same instance for different invocations of `keySelector`, and the comment on line 73 clearly states `gate` to be the guard for `map`.", "NaN"], ["878", "Scheduler.scheduleRecursive", "Ben Christensen", "benjchristensen", "02/14/14, 08:45:55 PM", "Make recursive scheduling a first-class citizen without needing to refer to \"this\" which doesn't work inside lambdas (Java8/Scala/etc).\n\n``` java\n        Schedulers.newThread().scheduleRecursive(new Action1<Recurse>() {\n            @Override\n            public void call(Recurse r) {\n                System.out.println(\"do stuff on thread: \" + Thread.currentThread() + \" Time: \" + System.nanoTime());\n                r.schedule(100, TimeUnit.MILLISECONDS);\n            }\n        });\n```", "NaN"], ["880", "Force ViewObservable be subscribed and unsubscribed in the UI thread", "Shixiong Zhu", "zsxwing", "02/15/14, 06:28:48 PM", "According to #869 , `unsubscribe` can run in any thread. However, that will cause some concurrent issues in rxjava-android.\n\nThis PR schedules the `unsubscribe` action to run in the UI thread to solve the problem.", "NaN"], ["881", "Lift Performance", "Ben Christensen", "benjchristensen", "02/17/14, 09:39:09 PM", "Using `f.lift()` directly instead of `subscribe` improves ops/second on the included test from 5,907,721 ops/sec to 10,145,486 ops/sec", "NaN"], ["883", "Make Subscriptions of SwingObservable thread-safe", "Shixiong Zhu", "zsxwing", "02/18/14, 07:42:10 AM", "Updated rxjava-swing according to the discussion in #869. Is it necessary to move the unit tests to src/test/java folder?", "NaN"], ["884", "OperatorRetry", "David Karnok", "akarnokd", "03/13/14, 04:31:50 PM", "Rewritten retry operator for 0.17+ and changed the per-source retry counter to per-subscriber retry counter so each subscriber can retry independently.", "NaN"], ["885", "Fixed an issue with the from(Reader) added a bunch of unit tests.", "George Campbell", "abersnaze", "02/18/14, 12:43:57 AM", "fixed a problem @fommil noticed in #840", "NaN"], ["887", "Remove Bad Filter Logic", "Ben Christensen", "benjchristensen", "02/17/14, 06:25:34 PM", "This code was accidentally committed during exploration of groupBy/subscribeOn.", "NaN"], ["888", "Revert Bounded ObserveOn", "Ben Christensen", "benjchristensen", "02/17/14, 07:02:33 PM", "Reverting to only having unbounded `observeOn` in public API as per comment at https://github.com/Netflix/RxJava/pull/835#issuecomment-35299824\n\nLeaving the bounded implementation as an internal operator implementation for now to be discussed further in v0.18 dev cycle.", "NaN"], ["890", "Split SubscribeOn into SubscribeOn/UnsubscribeOn", "Ben Christensen", "benjchristensen", "02/17/14, 08:33:29 PM", "Working with @headinthebox based on discussions at https://github.com/Netflix/RxJava/pull/869 and https://github.com/Netflix/RxJava/pull/880#issuecomment-35163539 we determined that there are times when `unsubscribeOn` behavior is needed.\n\nThe `subscribeOn` operator can not mix `subscribe` and `unsubscribe` scheduling behavior without breaking the `lift`/`Subscriber` behavior that allows unsubscribing synchronous sources. The newly added `unsubscribeOn` operator will not work with synchronous unsubscribes, but it will work for the targeted use cases such as UI event handlers.", "NaN"], ["891", "Eliminate rx.util.* dumping grounds", "Ben Christensen", "benjchristensen", "02/17/14, 09:36:40 PM", "Move all classes into proper homes rather than having `rx.util` as the miscellaneous dumping grounds.\n\nI have attempted to make rx.util.functions.\\* have deprecated proxies to ease the migration. I'm doing this in 0.17 instead of waiting since 0.17 already has breaking changes. ", "NaN"], ["892", "onErrorFlatMap + OnErrorThrowable", "Ben Christensen", "benjchristensen", "02/18/14, 03:58:41 PM", "I am working on solving a production error handling use case that needs the ability to handle errors on an `Observable` acting like a message-bus. This requires it to ignore errors if they occur.\n\nWith @headinthebox the idea of `onErrorFlatMap` evolved, but we now have a decision to make about the implementation.\n\nIt's pretty easy to solve the first half and allow `onErrorFlatMap` to return `Observables` that are injected into the output `Observable` but don't `onComplete` and thus allow the stream to continue.\n\nHowever, we're looking at whether we can also capture the `T value` that caused the exception to be thrown so we can achieve use cases like this:\n\n``` java\n    @Test\n    public void spliceAndContinueEmitting() {\n        TestSubscriber<String> ts = new TestSubscriber<String>();\n        Observable.from(1, 2, 3, 4, 5, 6).map(new Func1<Integer, String>() {\n\n            @Override\n            public String call(Integer v) {\n                if (v < 2 || v > 5) {\n                    return \"Value=\" + v;\n                }\n                throw new RuntimeException(\"error in map function: \" + v);\n            }\n\n        }).onErrorFlatMap(new Func1<OnErrorThrowable, Observable<String>>() {\n\n            @Override\n            public Observable<String> call(OnErrorThrowable t) {\n                return Observable.from(\"Error=\" + t.getValue());\n            }\n\n        }).subscribe(ts);\n\n        ts.assertTerminalEvent();\n        System.out.println(ts.getOnErrorEvents());\n        assertEquals(0, ts.getOnErrorEvents().size());\n        System.out.println(ts.getOnNextEvents());\n        ts.assertReceivedOnNext(Arrays.asList(\"Value=1\", \"Error=2\", \"Error=3\", \"Error=4\", \"Error=5\", \"Value=6\"));\n    }\n```\n\nThis outputs:\n\n```\n[Value=1, Error=2, Error=3, Error=4, Error=5, Value=6]\n```\n\nTo accomplish this however we must capture the `value` and wrap the `Throwable` in all operators that execute user-provided functions. This results in code like this:\n\n``` java\n            @Override\n            public void onNext(T t) {\n                try {\n                    o.onNext(transformer.call(t));\n                } catch (Throwable e) {\n                    onError(new OnErrorThrowable(e, t));\n                }\n            }\n```\n\ninstead of this:\n\n``` java\n            @Override\n            public void onNext(T t) {\n                try {\n                    o.onNext(transformer.call(t));\n                } catch (Throwable e) {\n                    onError(e);\n                }\n            }\n```\n\nThe drawback to this is that `onError` will now receive an `OnErrorThrowable` if the error comes from a user-provided function. The benefit is that the value associated with the failure is now accessible for debugging, reporting, feedback loops etc.\n\nOperators affected by this are `cast`, `doOnEach`, `filter`, `groupBy`, `map`, `scan`, `zip` (and surely others) as these all take user-provided functions.\n\nAre there reasons we should not wrap these errors inside an `OnErrorThrowable`?", "NaN"], ["893", "Change Parallel to use Long instead of Int", "Ben Christensen", "benjchristensen", "02/18/14, 12:00:42 AM", "NaN", "NaN"], ["894", "Synchronized Operator Check for isTerminated", "Ben Christensen", "benjchristensen", "02/18/14, 12:41:53 AM", "As per https://github.com/Netflix/RxJava/issues/872 make Synchronized reject events after terminal state.\nThis class should not unsubscribe though. That is only for SafeSubscriber at the end.", "NaN"], ["895", "Rewrite OperationObserveFromAndroidComponent to OperatorObserveFromAndro...", "Shixiong Zhu", "zsxwing", "02/18/14, 07:42:46 AM", "This PR did the following things:\n- Rewrite `OperationObserveFromAndroidComponent` to `OperatorObserveAndroidComponent`.\n- Call `unsubscribe` at once if the current thread is the UI thread.\n- Remove `itUnsubscribesFromTheSourceSequence` since it's meaningless in the new design.", "NaN"], ["896", "removing java 7 dep", "George Campbell", "abersnaze", "02/18/14, 06:39:18 AM", "NaN", "NaN"], ["898", "Handle illegal errors thrown from plugin", "Ben Christensen", "benjchristensen", "02/18/14, 04:12:16 PM", "NaN", "NaN"], ["901", "GroupBy Unit Test from #900", "Ben Christensen", "benjchristensen", "02/19/14, 04:50:29 AM", "https://github.com/Netflix/RxJava/issues/900", "NaN"], ["902", "Fixed NullPointerException that may happen on timeout", "Johan Haleby", "johanhaleby", "02/19/14, 02:59:42 PM", "An unhandled NullPointerException is thrown in the releaseResources method in rx.apache.http.consumers.ResponseConsumerDelegate if a timeout occur. If a timeout occur then onResponseReceived is never called and thus consumer is null.", "NaN"], ["903", "Scheduler.Recurse fields should be private", "Ben Christensen", "benjchristensen", "02/19/14, 08:48:07 PM", "NaN", "NaN"], ["904", "Merge: Unsubscribe Completed Inner Observables", "Ben Christensen", "benjchristensen", "02/19/14, 08:48:18 PM", "Fixing bug report from https://github.com/Netflix/RxJava/issues/897", "NaN"], ["905", "RxJavaSchedulers Plugin", "Ben Christensen", "benjchristensen", "02/19/14, 09:33:46 PM", "Allow setting different default schedulers for use by system.", "NaN"], ["906", "Deprecate Direct Access to Scheduler Implementations", "Ben Christensen", "benjchristensen", "02/19/14, 09:44:16 PM", "This enforces the convention of using `Schedulers.*` and then makes the RxJavaDefaultSchedulers plugin more reliable.", "NaN"], ["907", "Deprecate Direct Access to Scheduler Implementations", "Ben Christensen", "benjchristensen", "02/20/14, 05:16:49 PM", "This enforces the convention of using `Schedulers.*` and then makes the RxJavaDefaultSchedulers plugin more reliable.", "NaN"], ["908", "Rxjava clojure bindings", "Dave Ray", "daveray", "02/25/14, 06:56:25 AM", "_PLEASE DON'T MERGE THIS - FOR REVIEW ONLY_\n\nHere's a pull request for Clojure bindings to give people a place to provide feedback.", "NaN"], ["909", "Scheduler Plugin Refactor", "Ben Christensen", "benjchristensen", "02/20/14, 05:25:57 PM", "1) Deprecate Direct Access to Scheduler Implementations\n\nThis enforces the convention of using `Schedulers.*` and then makes the RxJavaDefaultSchedulers plugin more reliable.\n\n2) Scheduler instances should be or behave like singletons\n\nRemove the Func0 factory signature for Scheduler creation.", "NaN"], ["910", "Remove groupBy with selector.", "Ben Christensen", "benjchristensen", "02/20/14, 05:26:45 PM", "I think we can use `groupBy(keySelector).map(elementSelector)` instead. Is there any reason to keep this signature?\n\nRelated to https://github.com/Netflix/RxJava/commit/02ccc4d727a9297f14219549208757c6e0efce2a#commitcomment-5430646", "NaN"], ["915", "Merge pull request #1 from Netflix/master", "Vanadium", "jloisel", "02/21/14, 04:16:57 PM", "Merge with Netflix", "NaN"], ["916", "Merge pull request #1 from Netflix/master", "Vanadium", "jloisel", "02/21/14, 04:20:45 PM", "Merge with Netflix", "NaN"], ["917", "Zip Bug UnitTest: Never Completes When Zero Observables", "Todd Nine", "tnine", "02/21/14, 10:39:41 PM", "Duplicate of #868.  Accidentally submitted the PR from master, not from a test branch.", "NaN"], ["918", "Operator: doOnTerminate", "Ben Christensen", "benjchristensen", "02/21/14, 10:10:11 PM", "Like finallyDo but before emitting the terminal state instead of after.", "NaN"], ["919", "BugFix: Zip Never Completes When Zero Observables", "Ben Christensen", "benjchristensen", "02/21/14, 10:39:25 PM", "Fixes https://github.com/Netflix/RxJava/pull/868 and https://github.com/Netflix/RxJava/pull/917", "NaN"], ["920", "Delete Deprecated onSubscribeStart That Doesn't Work", "Ben Christensen", "benjchristensen", "02/21/14, 10:48:43 PM", "- It's messy to make this work so deleting it instead.\n- Better to move forward in the 0.17 release than try and make this work for the very small percentage (probably only Netflix) that uses it.", "NaN"], ["922", "Changes made while integrating it with our internal system", "George Campbell", "abersnaze", "02/24/14, 07:11:17 PM", "Added complete and error hooks to make the duration of events evident.\nChanged the debug notification to:\nremoved the start nano and thread id to leave that up to the hook writer to decide if they want that.\nadded the source observerable to make linking operators together.", "NaN"], ["923", "Observable creation from Subscriber[T]=>Unit for Scala", "Samuel Gruetter", "samuelgruetter", "03/06/14, 06:04:55 AM", "This PR adds the `Subscriber` type, and `Observable.apply[T](Subscriber[T] => Unit)`.\n\nAdditionally, I made some tweaks in `RxScalaDemo`, and I could remove all comments of the kind `TODO something behaves weirdly here`, because now the weird behavior was gone. Seems like there was some progress in RxJava core :-)\n\nSorry that this PR mixes several topics, let me know if you want me to split it by topic.\n\n/cc @headinthebox @vjovanov", "NaN"], ["924", "Localized Operator Error Handling", "Ben Christensen", "benjchristensen", "02/25/14, 06:44:00 AM", "Do error handling in the `lift` function rather than try/catch in `subscribe` since this catches at the operator level rather than for an entire sequence. This then allows `onErrorResumeNext` and siblings to handle the error instead of it only being emitted to the final `Subscriber`.\n\nI derived this fix while working on Hystrix 1.4.", "NaN"], ["925", "Rxjava clojure bindings final", "Dave Ray", "daveray", "02/25/14, 10:09:50 PM", "Clojure bindings for RxJava. Rebased and cleaned up version of https://github.com/Netflix/RxJava/pull/908 ready for merge. Didn't really get any external feedback, so I'm assuming that means it's perfect :)", "NaN"], ["926", "TestSubscriber: Default onError and Terminal Latch Behavior", "Ben Christensen", "benjchristensen", "02/25/14, 10:12:25 PM", "NaN", "NaN"], ["927", "TestSubscriber lastSeenThread", "Ben Christensen", "benjchristensen", "02/25/14, 10:52:11 PM", "NaN", "NaN"], ["928", "Fix deadlock in SubscribeOnBounded", "David Karnok", "akarnokd", "03/13/14, 04:32:56 PM", "Swap the subscription and the scheduling of pass-through to allow progress of a bounded synchronous source.", "NaN"], ["929", "correct link to maven search", "Volker Leck", "devisnik", "03/06/14, 06:04:28 AM", "Fixes the link for the maven search, now pointing to artifact id `rxjava-android`.", "NaN"], ["930", "Initial commit of the Android samples module", "Matthias K\u00e4ppler", "mttkay", "03/12/14, 04:13:46 PM", "refs https://github.com/soundcloud/RxJava/issues/3\n\nI made it so that the samples project will automatically be pulled in as soon as it detects an Android SDK on the build machine; otherwise it's ignored. It also runs in a sub-gradle so should not be affected by changes to the main project. It does, however, automatically pull in and compile against the current project version.\n\nLet me know what you think. I kept the actual samples minimal for now, I see this more as a tracer bullet for how the samples could fit into the current build setup.", "NaN"], ["931", "A number of improvements to OperatorObserveFromAndroidComponent", "Matthias K\u00e4ppler", "mttkay", "03/06/14, 06:21:50 PM", "Could I get some eyes on this? @tehmou @zsxwing @benjchristensen\n- move the UI thread assert out of the operator and into the helpers; this way, we don't fail the observer anymore with an exception, but the caller.\n- do not loop unsubscribe through the main thread anymore. This unnecessarily defers releasing the references, and might in fact be processed only after Android creates the component after a rotation change. I had to make the references volatile for this to work.\n- immediately unsubscribe in case we detect the componentRef has become invalid. This solves the problem that dangling observers would continue to listen to notifications with no observer alive anymore.\n\nrefs:\nhttps://github.com/Netflix/RxJava/issues/754\nhttps://github.com/Netflix/RxJava/issues/899", "NaN"], ["933", "Implemented Skip using Lift in Observable and OperatorSkip", null, "headinthebox", "02/27/14, 07:37:38 PM", "Deleted non-time part from OperationSkip\nMoved tests to OperatorSkipTest", "NaN"], ["934", "add Observable.startWith(Observable) method and unit test", "Dave Moten", "davidmoten", "03/06/14, 06:01:14 AM", "add Observable.startWith(Observable) method and unit test. \n\nI would like to avoid breaking method chaining when want to startWith an Observable rather than just an Iterator or specific values. This is a very minor change as under the covers startWith uses concat anyway but it is significant in terms of code readability and is a natural completion of the startWith api. ", "NaN"], ["936", "Skip fixed", null, "headinthebox", "03/04/14, 08:05:53 PM", "Fixed state capture bug.\nAdded unit tests.", "NaN"], ["938", "OperatorWeakBinding (deprecates OperatorObserveFromAndroidComponent)", "Matthias K\u00e4ppler", "mttkay", "03/13/14, 04:09:32 PM", "Android UI operator that weakly binds to a fragment or activity. (see discussion in https://github.com/Netflix/RxJava/issues/899)", "NaN"], ["940", "refactor the debug hooks before they become a breaking change.", "George Campbell", "abersnaze", "03/06/14, 05:59:46 AM", "The number of call backs started at one and grew to four and managing them all separately was cumbersome.  This will bring some sanity back to the debug hook API.\n\nI've made one to tiny change to `OnSubscribeFromIterable`. It now checks if the subscriber is unsubscribed before calling `onCompleted()`.", "NaN"], ["942", "MathObservable", "Ben Christensen", "benjchristensen", "03/06/14, 05:45:40 AM", "Moving the average/sum/min/max functionality to the MathObservable similar to StringObservable.\n\nSimilar to the rxjava-string module this is seeking to achieve the goal of keeping rxjava-core focused on core functionality.", "NaN"], ["944", "OperationRetry -> OperatorRetry", "Ben Christensen", "benjchristensen", "03/06/14, 05:54:29 AM", "Updated to use \"lift\" and Subscriber.\nFixes https://github.com/Netflix/RxJava/issues/943 Observable.retry() does not unsubscribe from source", "NaN"], ["945", "Manual Merge 940", "Ben Christensen", "benjchristensen", "03/06/14, 05:59:46 AM", "Fixes https://github.com/Netflix/RxJava/pull/940 via manual merge.", "NaN"], ["946", "Experimenting with Schedulers.currentScheduler()", "Ben Christensen", "benjchristensen", "03/13/14, 04:28:15 PM", "Experimenting based on conversation at https://github.com/Netflix/RxJava/issues/941#issuecomment-36827374", "NaN"], ["948", "OperationAll to OperatorAll", "Mark van der Voort", "MarkVanDerVoort", "04/23/14, 04:01:16 AM", "Replaced the `OperationAll` to an `OperatorAll`.\n\nCaveat: I am a newbie here, hoping to learn, so please do not spare me.\nI saw a remark on performancetests, but noticed they were not applied everywhere, so I left them out.\nI saw no issue yet asking for this work, this is on invitation from Erik Meijer at QCON yesterday.\nIf you want me to I can tackle some other operations as well.", "NaN"], ["949", "HandlerThreadScheduler fix", "Vladimir Mironov", "nsk-mironov", "03/12/14, 03:33:11 AM", "It's a best practice in android to check the current thread before using `Handler.post` and `Handler.postDelayed` because it can help to avoid unwanted UI blinks.", "NaN"], ["950", "Add support for Eclipse PDE", null, "Acardiac", "03/10/14, 04:19:12 PM", "Add support for Eclipse PDE handling OSGi fragments.\nhttp://help.eclipse.org/kepler/index.jsp?topic=%2Forg.eclipse.platform.doc.isv%2Freference%2Fmisc%2Fbundle_manifest.html\n\nsee also #849", "NaN"], ["951", "OperatorTimeoutBase unsubscribe from source", null, "rbramw", "03/14/14, 04:53:55 PM", "If no other observable is supplied to the OperatorTimeout:\n\npublic final Observable<T> timeout(long timeout, java.util.concurrent.TimeUnit timeUnit)\n\nthen, it does not unsubscribe from the source in the event of a timeout.", "NaN"], ["952", "rxjava-scala improvements and reimplemented the `amb` operator", "Shixiong Zhu", "zsxwing", "03/13/14, 04:11:47 PM", "This PR did the following improvements: \n- Added `amb`, `delay`, `delaySubscription` in rxjava-scala. \n- Reimplemented the `amb` operator.", "NaN"], ["953", "Make ObserveOnTest.testNonBlockingOuterWhileBlockingOnNext deterministic", "Ben Christensen", "benjchristensen", "03/10/14, 11:43:13 PM", "reported at https://twitter.com/jaceklaskowski/status/443153927069249536", "NaN"], ["955", "Fixed ReplaySubject leak", "David Karnok", "akarnokd", "03/13/14, 04:15:15 PM", "Fix for issue #939.", "NaN"], ["956", "Fixed byLine test to use line.separator system property instead of \\n.", "David Karnok", "akarnokd", "03/13/14, 04:15:31 PM", "`byLine()` uses the `line.separator` but the test used `\\n`.", "NaN"], ["958", "OperatorSkipWhile", "David Karnok", "akarnokd", "03/13/14, 04:15:55 PM", "Reimplemented OperatorSkipWhile (the OperationSkipWhile has a state-sharing bug with `skipping` and `index`).\n\n+1 test for many subscribers.", "NaN"], ["959", "OperationToFuture must throw CancellationException on get() if cancelled", "Rick Warren", "rickbw", "03/13/14, 04:16:37 PM", "The JDK documentation for Future.get() and its overload requires these methods to throw CancellationException if the Future was cancelled before the task completed. The Futures returned by OperationToFuture.toFuture() did not respect this contract. Now they do.", "NaN"], ["960", "Retry Unit Test from #879", "Ben Christensen", "benjchristensen", "03/13/14, 04:37:33 PM", "From https://github.com/Netflix/RxJava/issues/879", "NaN"], ["962", "Migrate from SynchronizedObserver to SerializedObserver", "Ben Christensen", "benjchristensen", "03/13/14, 06:34:38 PM", "This pull request replaces use of `SynchronizedObserver` with `SerializedObserver`. \n### Why?\n#### 1) Deadlocks\n\nHolding a lock while emitting notifications (`onNext`, `onCompleted`, `onError`) allows for deadlocks if the event results in a cycle back to the parent. \n\nWhile testing RxJava 0.17.0 in Netflix production we ran into one of these. The vulnerability has existed all along but we finally hit it.\n\nThis issue has also been reported before such as: http://twistedoakstudios.com/blog/Post8424_deadlocks-in-practice-dont-hold-locks-while-notifying\n#### 2) Blocking Threads\n\nThe use of `synchronized` can block threads. If it's used in areas such as modifying a data structure this can be okay. When emitting a notification however it is a problem as the result of an `onNext` can take a non-deterministically long time to complete. This means any other thread trying to emit will be blocked.\n\nIf the source threads are event loops (such as Vert.x or Netty) this will block the event loops. \n\nFor example, if two network calls off two Netty event loops are being merged (such as via `flatMap`) and one of them does further slow processing that causes `onNext` to be slow, it will block the other `onNext` which blocks the event loop and prevents any further IO on that thread. This is a significant problem for system scale and breaks the promise of Rx being a non-blocking, reactive library.\n### Solution\n\nThe `synchronize`, `SynchronizedObserver` and `SynchronizedSubscriber` operator and classes have been deprecated. They are replaced by `serialize`, `SerializedObserver` and `SerializedSubscriber`.\n\nThe `SerializedObserver` still ensures only a single thread can emit `onNext`, `onCompleted`, or `onError` at a time but does not hold a lock while doing so. Instead of blocking threads it will accept the incoming events into a buffer. Thus, it becomes an asynchronous operator.\n\nThe `merge` operator (which impacts `flatMap`) now uses `SerializedObserver`, along with any other place in RxJava that needed synchronization.\n### Implementation\n\n3 implementatations were written and tested:\n- [queue and counter](https://github.com/benjchristensen/RxJava/blob/serialize-implementations/rxjava-core/src/main/java/rx/observers/SerializedObserverViaQueueAndCounter.java)\n- [queue and lock](https://github.com/benjchristensen/RxJava/blob/serialize-implementations/rxjava-core/src/main/java/rx/observers/SerializedObserverViaQueueAndLock.java)\n- [atomic state machine](https://github.com/benjchristensen/RxJava/blob/serialize-implementations/rxjava-core/src/main/java/rx/observers/SerializedObserverViaStateMachine.java)\n\nPerformance testing [revealed](https://github.com/benjchristensen/RxJava/blob/serialize-implementations/rxjava-core/src/perf/java/rx/operators/OperatorSerializePerformance.java):\n\n``` java\n    /**\n     * 1 streams emitting in a tight loop. Testing for single-threaded overhead.\n     * \n     * -> blocking synchronization (SynchronizedObserver)\n     * \n     * Run: 10 - 58,186,310 ops/sec\n     * Run: 11 - 60,592,037 ops/sec\n     * Run: 12 - 58,099,263 ops/sec\n     * Run: 13 - 59,034,765 ops/sec\n     * Run: 14 - 58,231,548 ops/sec\n     * \n     * -> state machine technique (SerializedObserverViaStateMachine)\n     * \n     * Run: 10 - 34,668,810 ops/sec\n     * Run: 11 - 32,874,312 ops/sec\n     * Run: 12 - 33,389,339 ops/sec\n     * Run: 13 - 35,269,946 ops/sec\n     * Run: 14 - 34,165,013 ops/sec\n     * \n     * -> using queue and counter technique (SerializedObserverViaQueueAndCounter)\n     * \n     * Run: 10 - 19,548,387 ops/sec\n     * Run: 11 - 19,471,069 ops/sec\n     * Run: 12 - 19,480,112 ops/sec\n     * Run: 13 - 18,720,550 ops/sec\n     * Run: 14 - 19,070,383 ops/sec\n     * \n     * -> using queue and lock technique (SerializedObserverViaQueueAndLock)\n     * \n     * Run: 10 - 51,295,152 ops/sec\n     * Run: 11 - 50,317,937 ops/sec\n     * Run: 12 - 51,126,331 ops/sec\n     * Run: 13 - 52,418,291 ops/sec\n     * Run: 14 - 51,694,710 ops/sec\n     */\n\n    /**\n     * 2 streams emitting in tight loops so very high contention.\n     * \n     * -> blocking synchronization (SynchronizedObserver)\n     * \n     * Run: 10 - 8,361,252 ops/sec\n     * Run: 11 - 7,184,728 ops/sec\n     * Run: 12 - 8,249,685 ops/sec\n     * Run: 13 - 6,831,595 ops/sec\n     * Run: 14 - 8,003,358 ops/sec\n     * \n     * (faster because it allows each thread to be \"single threaded\" while blocking the other)\n     * \n     * -> state machine technique (SerializedObserverViaStateMachine)\n     * \n     * Run: 10 - 4,060,062 ops/sec\n     * Run: 11 - 3,561,131 ops/sec\n     * Run: 12 - 3,721,387 ops/sec\n     * Run: 13 - 3,693,909 ops/sec\n     * Run: 14 - 3,516,324 ops/sec\n     * \n     * -> using queue and counter technique (SerializedObserverViaQueueAndCounter)\n     * \n     * Run: 10 - 4,300,229 ops/sec\n     * Run: 11 - 4,395,995 ops/sec\n     * Run: 12 - 4,551,550 ops/sec\n     * Run: 13 - 4,443,235 ops/sec\n     * Run: 14 - 4,158,475 ops/sec\n     * \n     * -> using queue and lock technique (SerializedObserverViaQueueAndLock)\n     * \n     * Run: 10 - 6,369,781 ops/sec\n     * Run: 11 - 6,933,872 ops/sec\n     * Run: 12 - 5,652,535 ops/sec\n     * Run: 13 - 5,503,716 ops/sec\n     * Run: 14 - 6,219,264 ops/sec\n     */\n\n    /**\n     * 2 streams emitting once a millisecond. Slow emission so little to no contention.\n     * \n     * -> blocking synchronization (SynchronizedObserver)\n     * \n     * Run: 10 - 1,996 ops/sec\n     * Run: 11 - 1,996 ops/sec\n     * Run: 12 - 1,995 ops/sec\n     * Run: 13 - 1,997 ops/sec\n     * Run: 14 - 1,996 ops/sec\n     * \n     * -> state machine technique (SerializedObserverViaStateMachine)\n     * \n     * Run: 10 - 1,996 ops/sec\n     * Run: 11 - 1,996 ops/sec\n     * Run: 12 - 1,996 ops/sec\n     * Run: 13 - 1,996 ops/sec\n     * Run: 14 - 1,996 ops/sec\n     * \n     * -> using queue and counter technique (SerializedObserverViaQueueAndCounter)\n     * \n     * Run: 10 - 1,996 ops/sec\n     * Run: 11 - 1,996 ops/sec\n     * Run: 12 - 1,996 ops/sec\n     * Run: 13 - 1,996 ops/sec\n     * Run: 14 - 1,995 ops/sec\n     * \n     * -> using queue and lock technique (SerializedObserverViaQueueAndLock)\n     * \n     * Run: 10 - 1,996 ops/sec\n     * Run: 11 - 1,996 ops/sec\n     * Run: 12 - 1,997 ops/sec\n     * Run: 13 - 1,996 ops/sec\n     * Run: 14 - 1,995 ops/sec\n     */\n```\n\nThe state machine solution was tested in production but caused performance problems, most likely due to the immense object allocation it needs to do. \n\nThe elegant \"queue and counter\" solution does not perform well enough in the non-contended case.\n\nThe \"queue and lock\" model performs well in the non-contended case and under contention, despite not being a very elegant solution and requiring the use of mutex locks for the state changes (but it does not hold the locks during notification).\n### Considerations\n\nThis does allow unbounded buffer growth, the same as `observeOn` and `zip` instead of blocking the producer threads. \n### Conclusion\n\nThe implementation in this pull request can and likely will be improved over time. The other implementations are purposefully being shown to allow others to provide further insight on how to do this better. \n\nThis change is important to ensure RxJava is non-blocking and our canary testing of this change in the Netflix production environment suggests this change is both performant and functional.", "NaN"], ["963", "A more robust JMH benchmarking set-up", "Gleb Smirnov", "gvsmirnov", "03/13/14, 08:36:51 PM", "Usage:\n\n```\n$ gradle benchmarks\n$ java -jar rxjava-core/build/distributions/rxjava-core-0.17.2-SNAPSHOT-benchmarks.jar [...]\n```\n\nFor example:\n\n```\n$ java -jar rxjava-core/build/distributions/rxjava-core-0.17.2-SNAPSHOT-benchmarks.jar -f 1 -wi 10 -i 10 -tu us -bm avgt\n\nBenchmark                                  (size)   Mode   Samples         Mean   Mean error    Units\nr.o.ObservableBenchmark.measureBaseline         1   avgt        10        0.003        0.000    us/op\nr.o.ObservableBenchmark.measureBaseline      1024   avgt        10        2.764        0.051    us/op\nr.o.ObservableBenchmark.measureBaseline   1048576   avgt        10     3104.088       49.586    us/op\nr.o.ObservableBenchmark.measureMap              1   avgt        10        0.100        0.003    us/op\nr.o.ObservableBenchmark.measureMap           1024   avgt        10        5.036        0.059    us/op\nr.o.ObservableBenchmark.measureMap        1048576   avgt        10     6693.271      277.604    us/op\n```\n\nSee https://github.com/Netflix/RxJava/issues/776 for more details.", "NaN"], ["964", "SubjectSubscriptionManager fix.", "David Karnok", "akarnokd", "03/13/14, 10:48:03 PM", "Fix for #961\n\nIf an already unsubscribed Subscriber is added, the subscription function ends up in an infinite loop as the inner unsubscription logic changes the state to another object before the outer state machine continues.\n- The outer state machine loop now exits if unsubscription happened and doesn't attempt to modify the state.\n- The removeObserver method is changed so that if the subscription to be removed is not in the array, it returns this instead of an unnecessary copy. In addition, copyOf calls have been replaced by arraycopy to avoid reflective array creation.", "NaN"], ["965", "BugFix: Chain Subscription in TimeoutSubscriber and SerializedSubscriber", "Shixiong Zhu", "zsxwing", "03/25/14, 09:06:11 PM", "This PR chains Subscription in TimeoutSubscriber  and SerializedSubscriber. Found by @rbramw #951. Thanks for your unit tests, @rbramw", "NaN"], ["966", "Reimplement the ElementAt operator and add it to rxjava-scala", "Shixiong Zhu", "zsxwing", "03/25/14, 09:05:10 PM", "NaN", "NaN"], ["967", "Reimplement the 'single' operator", "Shixiong Zhu", "zsxwing", "04/20/14, 03:34:21 AM", "This PR did the following work:\n- Reimplement the `single` operator\n- Add `first`, `last`, `single` to rxjava-scala\n- When the `Observable` is empty, `first`, `last`, `single` will throw `NoSuchElementException` instead of `IllegalArgumentException`. It's more consistent with the Java Collection API, e.g., [Deque.getFirst()](http://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#getFirst%28%29), [Deque.getLast()](http://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#getLast%28%29). This will break the current APIs.", "NaN"], ["970", "Notifications for the allocation averse.", "George Campbell", "abersnaze", "03/20/14, 04:25:16 PM", "I've seen and used the sentinel pattern in a couple of places in the implementation of operators.  I figured I'd formalize the hacks into one place where bugs can coalesce.  As a bonus the code that uses it looks a bit cleaner now.", "NaN"], ["972", "Fixed deadlock in Subjects + OperatorCache.", "David Karnok", "akarnokd", "04/16/14, 04:00:40 PM", "Fix for Issue #971.\n- I had to rewrite OperatorCache to allow testing for deadlocks in all Subject types.\n- The terminationLatch was unnecessarily waiting for existing subscribers to deliver their termination events, which caused deadlock with repeat().\n- Treating subjects as internal implementations was not necessary to fix the problem.", "NaN"], ["973", "Merge - Handle Bad Observables", "Ben Christensen", "benjchristensen", "03/20/14, 04:55:08 PM", "- concurrency unit tests\n- handle Observable that emits onComplete multiple times\n\nSee https://github.com/Netflix/RxJava/pull/962#issuecomment-38191868", "NaN"], ["974", "TestSubject, TestObserver and TestScheduler Improvements", "Ben Christensen", "benjchristensen", "03/20/14, 05:39:52 PM", "NaN", "NaN"], ["975", "GroupBy & Time Gap Fixes", "Ben Christensen", "benjchristensen", "03/20/14, 05:47:37 PM", "I ran head-on into the \"time gap\" (https://github.com/Netflix/RxJava/issues/844) issue while working on a stream processing use case (and new 'pivot' operator I'm writing).\nThis is a solution. It's still not ideal as the Javadocs of BufferUntilSubscriber mention, but this is working better than nothing and does not require blocking threads.\nA better solution will come as part of the back pressure work where BufferUntilSubscriber will evolve to have a bounded buffer.", "NaN"], ["976", "parallel-merge unit test assertions", "Ben Christensen", "benjchristensen", "03/20/14, 06:32:18 PM", "Using serialize for merge allows less threads to be used under contention instead of blocking and using them all.\nThis changes the assertion to be <= 3 instead of == 3 because of that.", "NaN"], ["977", "Dematerialize - handle non-materialized terminal events", "Ben Christensen", "benjchristensen", "03/20/14, 09:35:58 PM", "This is used for a use case such as:\n\n``` java\nobservable.flatMap(t -> {\nif(x) {\n  return Observable.from(Notification.create(t));\n} else {\n  return Observable.error(e);\n}).dematerialize();\n```", "NaN"], ["982", "Pivot Operator", "Ben Christensen", "benjchristensen", "03/25/14, 04:34:26 PM", "NaN", "NaN"], ["983", "add OperationToOperator and unit tests and overload for lift method", "Dave Moten", "davidmoten", "07/08/14, 08:12:26 PM", "I found myself using this method a lot to easily create an Operator so that I can use the lift method. For example:\n\nSuppose I want to use lift to perform a concat on a sequence of observables followed by count:\n\n``` java\nprivate static <T> Func1<Observable<Observable<T>>, Observable<Integer>> concatCount() {\n    return new Func1<Observable<Observable<T>>, Observable<Integer>>() {\n        @Override\n        public Observable<Integer> call(Observable<Observable<T>> source) {\n            return Observable.concat(source).count();\n        }\n    };\n}\n```\n\nI can then use the suggested lift overload with the function above:\n\n``` java\nsource.lift(MyClass.<Integer> concatCount());\n```\n\nor I could have made an Operator form of it (especially if its component operations don't have readily available Operator forms to chain together):\n\n``` java\nprivate static <T> Operator<Integer, Observable<T>> concatCountOperator() {\n    return OperationToOperator.toOperator(MyClass.<T> concatCount());\n}\n```", "NaN"], ["984", "Tests and Javadoc for Pivot", "Ben Christensen", "benjchristensen", "03/25/14, 06:36:00 PM", "NaN", "NaN"], ["986", "Fix SynchronizedObserver.runConcurrencyTest", "Ben Christensen", "benjchristensen", "03/25/14, 09:32:16 PM", "It wasn't waiting on all threads before emitting onCompleted.", "NaN"], ["987", "Fix Non-Deterministic Pivot Test", "Ben Christensen", "benjchristensen", "03/25/14, 09:38:04 PM", "This fixes a test that failed on build servers (small, slow, single or dual-core machines).", "NaN"], ["988", "OnErrorFailedException", "Ben Christensen", "benjchristensen", "03/25/14, 10:02:48 PM", "Re-throw when onError throws an Exception.\nThis fixes https://github.com/Netflix/RxJava/issues/969", "NaN"], ["990", "Quasar integration contrib module", "Ron Pressler", "pron", "04/02/14, 06:36:43 AM", "This module integrates RxJava with [Quasar](https://github.com/puniverse/quasar) in several ways. It provides:\n- A fiber-based scheduler\n- A fiber-blocking version of BlockingObservables\n- Viewing Quasar channels as Observables and transforming Observables into channels (Quasar channels are a CSP mechanism very similar to channels in the Go programming language).", "NaN"], ["991", "JMH Benchmark Build Config", "Ben Christensen", "benjchristensen", "03/26/14, 11:01:58 PM", "Fixes the Gradle config for JMH so it works from command-line and projects import into Eclipse correctly. \n\nSee https://github.com/Netflix/RxJava/pull/963\n\nThanks @quidryan !", "NaN"], ["993", "JMH Perf Tests", "Ben Christensen", "benjchristensen", "03/27/14, 05:49:30 AM", "1) Migrate all previous tests into `rx.archive` until we have matured with JMH\n2) JMH config in gradle\n3) Start of benchmarking with JMH for `baseline`, `map` and `serialize`\n\n**To Run**\n\nInside ./rxjava-core/ invoke `../gradlew benchmarks`\n\nOr from base invoke `./gradlew benchmarks` and it will scan each sub-module for benchmarks and then only find them in rxjava-core.\n\n**Output**\n\n```\nResult : 72.204 \u00b1(99.9%) 7.524 ns/op\n  Statistics: (min, avg, max) = (69.221, 72.204, 74.048), stdev = 1.954\n  Confidence interval (99.9%): [64.680, 79.729]\n\n\nBenchmark                                                          (size)   Mode   Samples         Mean   Mean error    Units\nr.jmh.Baseline.forLoopInvokingFunction                               1024   avgt         5     3230.689      486.080    ns/op\nr.jmh.Baseline.forLoopInvokingFunction                            1048576   avgt         5  3394679.521   148858.373    ns/op\nr.operators.OperatorMapPerf.mapIdentityFunction                         1   avgt         5       91.338        8.504    ns/op\nr.operators.OperatorMapPerf.mapIdentityFunction                      1024   avgt         5     5626.727     1209.108    ns/op\nr.operators.OperatorMapPerf.mapIdentityFunction                   1048576   avgt         5  6268747.085   258008.983    ns/op\nr.operators.OperatorSerializePerf.noSerializationSingleThreaded      1024   avgt         5       42.198        0.791    ns/op\nr.operators.OperatorSerializePerf.noSerializationSingleThreaded   1048576   avgt         5       45.935        0.911    ns/op\nr.operators.OperatorSerializePerf.serializedSingleStream             1024   avgt         5       69.410       10.499    ns/op\nr.operators.OperatorSerializePerf.serializedSingleStream          1048576   avgt         5       72.305       11.450    ns/op\nr.operators.OperatorSerializePerf.synchronizedSingleStream           1024   avgt         5       72.238        7.233    ns/op\nr.operators.OperatorSerializePerf.synchronizedSingleStream        1048576   avgt         5       72.204        7.524    ns/op\n\n\n```", "NaN"], ["994", "Use @SafeVarargs for From and Merge", "Ben Christensen", "benjchristensen", "03/28/14, 05:41:45 PM", "A proposed change if we can demonstrate it works with Android.\n\nSee https://github.com/Netflix/RxJava/issues/992 for discussion.\nIntended to eliminate overloads as defined in https://github.com/Netflix/RxJava/issues/686", "NaN"], ["995", "Support Custom JMH Args", "Ben Christensen", "benjchristensen", "03/27/14, 09:56:20 PM", "Support executions of benchmarks such as:\n\n```\n../gradlew benchmarks '-Pjmh=-f 1 -tu ns -bm avgt -wi 5 -i 5 -r 1 .*OperatorSerializePerf.*'\n```\n\nBy default it will run all benchmarks if no args are passed.", "NaN"], ["996", "Perfshadowjar", "Rob Spieldenner", "rspieldenner", "03/28/14, 02:42:26 AM", "NaN", "NaN"], ["999", "New Implementation of SerializedObserver", "Ben Christensen", "benjchristensen", "04/01/14, 09:00:12 PM", "Rewrite of `SerializedObserver` by @akarnokd discussed at  https://github.com/Netflix/RxJava/pull/962#discussion_r10601839 from this Gist: https://gist.github.com/akarnokd/9545150\n#### JMH Benchmarks\n\n0.17.3\n\n```\nBenchmark                                                          (size)   Mode   Samples         Mean   Mean error    Units\nr.operators.OperatorSerializePerf.noSerializationSingleThreaded      1024   avgt         5       45.504        1.710    ns/op\nr.operators.OperatorSerializePerf.noSerializationSingleThreaded   1048576   avgt         5       58.600        5.647    ns/op\nr.operators.OperatorSerializePerf.serializedSingleStream             1024   avgt         5       68.610        4.596    ns/op\nr.operators.OperatorSerializePerf.serializedSingleStream          1048576   avgt         5       71.313        2.318    ns/op\nr.operators.OperatorSerializePerf.synchronizedSingleStream           1024   avgt         5       73.322        3.666    ns/op\nr.operators.OperatorSerializePerf.synchronizedSingleStream        1048576   avgt         5       76.518        1.355    ns/op\n```\n\n0.17.2\n\n```\nBenchmark                                                          (size)   Mode   Samples         Mean   Mean error    Units\nr.operators.OperatorSerializePerf.noSerializationSingleThreaded      1024   avgt         5       45.790        1.184    ns/op\nr.operators.OperatorSerializePerf.noSerializationSingleThreaded   1048576   avgt         5       58.518        3.788    ns/op\nr.operators.OperatorSerializePerf.serializedSingleStream             1024   avgt         5       72.665        7.851    ns/op\nr.operators.OperatorSerializePerf.serializedSingleStream          1048576   avgt         5       74.788        2.946    ns/op\nr.operators.OperatorSerializePerf.synchronizedSingleStream           1024   avgt         5       73.661        3.499    ns/op\nr.operators.OperatorSerializePerf.synchronizedSingleStream        1048576   avgt         5       78.386        5.036    ns/op\n```\n#### Manual Benchmarks\n\n``` java\n/**\n * 0.17.3:\n *\n * Run: 10 - 9,746,505 ops/sec\n * Run: 11 - 9,956,019 ops/sec\n * Run: 12 - 10,053,770 ops/sec\n * Run: 13 - 10,076,958 ops/sec\n * Run: 14 - 9,983,319 ops/sec\n *\n * 0.17.2:\n *\n * Run: 10 - 9,851,999 ops/sec\n * Run: 11 - 9,726,975 ops/sec\n * Run: 12 - 9,719,762 ops/sec\n * Run: 13 - 9,668,141 ops/sec\n * Run: 14 - 9,799,700 ops/sec\n *\n * @param input\n */\npublic void serializedSingleStream(Input input) {\n    for (int i = 0; i < reps; i++) {\n        input.observable.serialize().subscribe(input.subscriber);\n    }\n}\n```", "NaN"], ["1003", "Func0 can transparently implement java.util.concurrent.Callable.", "Rick Warren", "rickbw", "03/31/14, 04:30:35 PM", "This change doesn't change the API at all for users of `Func0`, but it makes all `Func0` objects immediately reusable with any JDK API that accepts `Callables`. For example, a `Func0` can now be submitted directly to an `ExecutorService` for asynchronous execution. It also allows the elimination of a small amount of redundant code within RxJava itself.", "NaN"], ["1005", "add toMap from Java Observable", null, "suncelesta", "04/15/14, 10:07:47 PM", "Added three overloads of toMap to Scala Observable", "NaN"], ["1008", "Fix premature garbage collection of subscriber", "Samuel Tardieu", "samueltardieu", "04/05/14, 04:57:42 PM", "Keeping a weak binding onto the subscriber makes it possible to prematurely get the subscriber garbage collected if there are no other references to it.\n\nHere, we chose to pass around the component to which the subscriber is tied in form of a pair (`BoundPayload`). This allows the subscribers to get a reference on the (guaranteed non-collected) target without keeping it in the closure.\n\nThis introduces an interface change, but the current implementation is wrong and should never be used (see issues #979 and #1006).\n\nAn example usage can be seen at https://github.com/samueltardieu/cgeo/blob/bound-payload/main/src/cgeo/geocaching/PocketQueryList.java#L50 where `selectFromPocketQueries` references the target activity through `pocketQueryLists.target` in the subscriber.\n\ncc @mttkay", "NaN"], ["1009", "Android - Adding a new RetainedFragment example", "Zac Siegel", "zsiegel", "04/16/14, 04:01:51 PM", "I wanted to augment the current `RetainedFragment` example class to address some scenarios I have run into using the patterns defined in the current example.  \n\nI was hoping to get some feedback on a more complete scenario I have been working on which is the following.\n\nOn a typical login screen when the user taps a button we want to fire off our network request in an observable. We want to show a progress dialog and then show either success or an error dialog when it fails. We want to gracefully handle rotation and app switching in case a user does something else after firing off the login call. When the user returns we should be able to tell them there was an error or continue forward. \n\nI tried to address this scenario above but specifically I wanted to try and complete the following.\n- Get all the benefits from the current example - i.e. rotation support\n- Make sure the callbacks are not triggered while the app is not in focus\n- Make the example be triggered by a user action - i.e. a user tapping a button\n\nHoping to get some feedback on the example and see if there are any issues with the sample implementation. \n\nAny issues you see here @mttkay or other android RX users?\n\nThanks", "NaN"], ["1010", "UnsafeSubscribe", "Ben Christensen", "benjchristensen", "04/03/14, 04:41:49 AM", "Migrate from reflection to unsafeSubscribe as per discussion at https://github.com/Netflix/RxJava/issues/676\n\nAll operators are migrated to using `unsafeSubscribe` instead of relying on their package to avoid `SafeSubscriber` wrapping.", "NaN"], ["1012", "Removed window between the two synchronized blocks.", "David Karnok", "akarnokd", "04/02/14, 07:36:00 PM", "In the original version, there was a window between finding a null queue and setting emitting false due to being in different synchronized block. If another thread came in this window, it created a new queue with its event which was not emitted until another onXXX method was called, causing unnecessary event delivery delay.\n\nWhile running the tests, the `SerializedObserverTest.testNotificationDelay` failed from time to time due to thread timing. I haven't fixed this test.", "NaN"], ["1014", "Scheduler with Recurse/Inner", "Ben Christensen", "benjchristensen", "04/11/14, 08:01:41 PM", "API changes as per https://github.com/Netflix/RxJava/issues/997\n\nUsage looks like this:\n\n``` java\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Scheduler.Inner;\nimport rx.Scheduler.Recurse;\nimport rx.functions.Action1;\nimport rx.schedulers.Schedulers;\n\npublic class Test {\n\n    public static void main(String args[]) {\n\n        Schedulers.newThread().schedule(new Action1<Recurse>() {\n\n            @Override\n            public void call(Recurse inner) {\n                System.out.println(\"do stuff\");\n                // recurse\n                inner.schedule(this);\n            }\n\n        });\n\n        Schedulers.newThread().schedule(recurse -> {\n            System.out.println(\"do stuff\");\n            recurse.schedule();\n        });\n\n        Schedulers.newThread().schedule(recurse -> {\n            System.out.println(\"do stuff\");\n            recurse.schedule(1000, TimeUnit.MILLISECONDS);\n        });\n\n        Schedulers.newThread().schedule(recurse -> {\n            recurse.schedule(re -> {\n                System.out.println(\"do more stuff\");\n            });\n        });\n\n        Inner inner = Schedulers.newThread().createInner();\n        inner.schedule(re -> {\n            System.out.println(\"do stuff\");\n            re.schedule(r -> {\n                System.out.println(\"do more stuff\");\n            });\n        });\n\n    }\n}\n```\n\nCode outline:\n\n![screen shot 2014-04-02 at 11 08 31 pm](https://cloud.githubusercontent.com/assets/813492/2600101/6c680404-baf6-11e3-916e-c41a817bc328.png)", "NaN"], ["1015", "Remove Redundant protectivelyWrap Method", "Ben Christensen", "benjchristensen", "04/03/14, 04:50:29 PM", "NaN", "NaN"], ["1019", "Fix: retry() never unsubscribes from source until operator completes", "Ben Christensen", "benjchristensen", "04/04/14, 05:16:23 PM", "This fixes https://github.com/Netflix/RxJava/issues/1018\n\nThank you @petermd", "NaN"], ["1020", "Upgrade Gradle wrapper for Android samples to Gradle 1.11", "Matthias K\u00e4ppler", "mttkay", "04/16/14, 04:02:28 PM", "Android Studio 0.5.4 refuses to build with 1.10.", "NaN"], ["1021", "OperatorWeakBinding to not use WeakReferences anymore", "Matthias K\u00e4ppler", "mttkay", "04/15/14, 09:52:27 PM", "related issues:\nhttps://github.com/Netflix/RxJava/pull/1008\nhttps://github.com/Netflix/RxJava/issues/1006\nhttps://github.com/Netflix/RxJava/issues/979\n\nI changed the samples to actually use `bindActivity` and `bindFragment`", "NaN"], ["1026", "Adding a unit test to demo a concurrency issue with Observer catchup on a ReplaySubject.", "George Campbell", "abersnaze", "04/09/14, 08:25:11 PM", "For issue #1025", "NaN"], ["1027", "isolate subscriber used for retries, cleanup tests", "Peter McDonnell", "petermd", "04/12/14, 12:09:15 AM", "potential fix for #1024\n\nthere is an outstanding question (see commit comments) about whether its appropriate for the operator to use `unsafeSubscribe` given that it does not completely isolate the `Subscriber` from a badly behaved `Observable`.", "NaN"], ["1030", "Benchmarking: Add JMH benchmark for ReplaySubject.", "Michael Nitschinger", "daschl", "04/11/14, 07:54:53 PM", "Adds some benches for the replay subject.\n\nI.E.\n\n```\nBenchmark                                     (nextRuns)   Mode   Samples         Mean   Mean error    Units\nr.s.ReplaySubjectPerf.subscribeAfterEvents             1  thrpt         5  1898239.827    57634.047    ops/s\nr.s.ReplaySubjectPerf.subscribeAfterEvents          1024  thrpt         5    35680.927      470.929    ops/s\nr.s.ReplaySubjectPerf.subscribeAfterEvents       1048576  thrpt         5       32.427        1.462    ops/s\nr.s.ReplaySubjectPerf.subscribeBeforeEvents            1  thrpt         5  1427820.733    19194.452    ops/s\nr.s.ReplaySubjectPerf.subscribeBeforeEvents         1024  thrpt         5    36835.800      264.748    ops/s\nr.s.ReplaySubjectPerf.subscribeBeforeEvents      1048576  thrpt         5       35.520        1.145    ops/s\n```", "NaN"], ["1031", "Fix NPE in SubjectSubscriptionManager", "Ben Christensen", "benjchristensen", "04/11/14, 07:54:03 PM", "If unsubscribed it should just return, not continue forward. If it does, the `newState` is null and it throws an NPE. ", "NaN"], ["1032", "Scheduler with Schedulable/EventLoop", "Ben Christensen", "benjchristensen", "04/15/14, 09:55:54 PM", "API changes as per https://github.com/Netflix/RxJava/issues/997", "NaN"], ["1033", "Manual Merge #1027", "Ben Christensen", "benjchristensen", "04/12/14, 12:09:14 AM", "While reviewing #1027 I added another unit test to understand the issue. Fix by @petermd is good.", "NaN"], ["1035", "Scala cleanup", "Eugene Vigdorchik", "vigdorchik", "04/16/14, 04:01:44 PM", "Review by @headinthebox and @samuelgruetter.", "NaN"], ["1036", "replaced FRP with RP in README title", "Georgi Khomeriki", "flatmap13", "04/15/14, 09:53:50 PM", "Mentioning \"Functional Reactive Programming\" causes confusion and misconception.\nI think it's better to simply stick with \"Reactive Programming\".", "NaN"], ["1038", "rxjava-android: parameterize OperatorViewClick by concrete view type", "Yaroslav", "Yarikx", "04/16/14, 04:02:40 PM", "Parameterize OperatorViewClick observable to actual View type.\nSo actual view with it native type can be used.\n\nSo instead of \n\n```\nObservable<View> imageClicks = ViewObservable.clicks(imageView, false);\n        //...\n        imageClicks.subscribe(new Action1<View>() {\n            @Override\n            public void call(View view) {\n                ImageView imageView = (ImageView) view;\n                imageView.setImageBitmap(bitmap);\n            }\n        });\n```\n\nyou can use\n\n```\n        Observable<ImageView> imageClicks = ViewObservable.clicks(imageView, false);\n        //...\n        imageClicks.subscribe(new Action1<ImageView>() {\n            @Override\n            public void call(ImageView view) {\n                view.setImageBitmap(bitmap);\n            }\n        });\n```", "NaN"], ["1040", "Merge and Cleanup of #972", "Ben Christensen", "benjchristensen", "04/16/14, 04:00:39 PM", "@akarnokd I have manually merged your changes (https://github.com/Netflix/RxJava/pull/972) and migrated from `Action1` to `Action0` as we discussed. \n\nCan you review what I did on top of your changes to make sure it's correct. It seems correct to me but there is some nuanced concurrency here (obviously, hence your fixes) and I would appreciate your validation. ", "NaN"], ["1042", "Kotlin M7 and full compatibility with 0.17.0", "Mario Arias", "MarioAriasC", "04/16/14, 04:01:33 PM", "NaN", "NaN"], ["1043", "Reduce the scope of locking to increase parallelism.", "Eugene Vigdorchik", "vigdorchik", "04/17/14, 07:52:30 AM", "In my rxmon project https://github.com/vigdorchik/rxmon I make heavy use of combineLatest. This change that reduces the scope of locking should help increase combineLatest throughput. I wish I could report the speedup numbers, but I couldn't find how to publish RxJava to maven locally to try it out.", "NaN"], ["1047", "Scheduler Simplification", "Ben Christensen", "benjchristensen", "04/19/14, 02:13:21 AM", "API redesign (simplification) as per discussion at https://github.com/Netflix/RxJava/issues/997\n\nThe `Scheduler` API in this pull request is:\n\n``` java\nclass Scheduler {\n    public abstract Inner Inner(); \n    public int degreeOfParallelism();\n    public long now();\n\n    public abstract static class Inner implements Subscription {\n        public abstract Subscription schedule(Action0 action, long delayTime, TimeUnit unit);\n        public abstract Subscription schedule(Action0 action);\n        public final void schedulePeriodically(Action0 action, long initialDelay, long period, TimeUnit unit);\n        public long now();\n    }\n}\n```\n\nWhile migrating to this I found a 4th use case in addition to the previously discussed 3 that required the `schedule` methods inside `Inner` to also return `Subscription` for canceling the individual tasks as opposed to the entire `Inner`.\n\nHere are the use cases:\n#### 1) Single Action\n\n``` java\nfinal Inner is = scheduler.inner();\nis.schedule(new Action0() {\n\n    @Override\n    public void call() {\n        // do work here\n    }\n})\n\nis.unsubscribe()\n```\n\nwith lambda\n\n``` java\nfinal Inner is = scheduler.inner);\nis.schedule(() -> {\n        // do work here\n})\n\nis.unsubscribe()\n```\n#### 2) Inner Recursion\n\n``` java\nfinal Inner is = scheduler.inner();\nis.schedule(new Action0() {\n\n    @Override\n    public void call() {\n        // do work here then recursively reschedule\n    is.schedule(this); // this will NOT work with lambdas, only anonymous inner classes\n    }\n})\n\nis.unsubscribe()\n```\n#### 3) Outer Recursion\n\n``` java\nfinal Inner is = scheduler.inner();\n\npublic void onNext(T t) {\n    is.schedule(new Action0() {\n\n        @Override\n        public void call() {\n            // do work here\n        }\n    })\n}\n\nis.unsubscribe()\n```\n#### 4) Outer Recursion with Task Cancellation\n\nThis is used for things like `debounce` and `throttleLast` where tasks are being scheduled and cancelled as `onNext` notifications are received.\n\n``` java\nfinal Inner is = scheduler.inner();\nSerialSubscription serial = new SerialSubscription();\n\npublic void onNext(T t) {\n    // schedule a new task and cancel previous if not yet executed\n    serial.set(is.schedule(new Action0() {\n\n        @Override\n        public void call() {\n            // do work here\n        }\n    }));\n}\n\nis.unsubscribe()\n```", "NaN"], ["1048", "Remove ExecutorScheduler - New ComputationScheduler", "Ben Christensen", "benjchristensen", "04/19/14, 04:03:28 AM", "Removing `ExecutorScheduler` as it does not comply with the contract of sequential execution. A Scheduler needs to guarantee sequential execution, but putting work on a multi-threaded thread pool allows concurrent execution. \n\nSee https://github.com/Netflix/RxJava/issues/711 and https://github.com/Netflix/RxJava/issues/713", "NaN"], ["1049", "Move rx.joins to rxjava-joins module", "Ben Christensen", "benjchristensen", "04/19/14, 04:42:06 AM", "Migrating rx.joins into a separate contrib module as part of roadmap to 1.0: https://github.com/Netflix/RxJava/issues/1001#issuecomment-40390984\nThis is being done until the rx.joins API has further time to mature as it is likely to change and we can't make breaking changes any further once we hit 1.0.", "NaN"], ["1050", "Reimplement the 'SkipLast' operator", "Shixiong Zhu", "zsxwing", "04/20/14, 03:57:28 AM", "This PR did the following work:\n- Reimplemented the `SkipLast` operator to two different classes: `OperatorSkipLast` and `OperatorSkipLastWithTimed`.\n- Fixed a bug in `OperatorSkipLastWithTimed` that when all elements are valid, `onCompleted` will not be called. The unit test is `testSkipLastTimedWhenAllElementsAreValid`.", "NaN"], ["1051", "Manual Merge #967", "Ben Christensen", "benjchristensen", "04/20/14, 03:34:21 AM", "Manually merge #967", "NaN"], ["1052", "Scheduler Cleanup", "Ben Christensen", "benjchristensen", "04/20/14, 04:12:17 AM", "ComputationScheduler -> EventLoopsScheduler\nRestoring parallel() to using Schedulers.computation()", "NaN"], ["1053", "Deprecation Cleanup", "Ben Christensen", "benjchristensen", "04/20/14, 05:28:06 AM", "The time has come to delete the deprecated methods/classes.\n\nA few still remain to be done before 1.0 but can't be done until all operators are migrated:\n- `Observable.OnSubscribeFunc`\n- `Observable.create(OnSubscribeFunc)`\n- `SafeObservableSubscription`\n- `SafeObserver`", "NaN"], ["1055", "close #1054", "Ron Pressler", "pron", "04/21/14, 04:46:26 PM", "NaN", "NaN"], ["1056", "Add drop(skip) and dropRight(skipLast) to rxscala", "Shixiong Zhu", "zsxwing", "04/21/14, 04:48:23 PM", "NaN", "NaN"], ["1057", "Fix issue #1044", "Shixiong Zhu", "zsxwing", "04/21/14, 04:48:04 PM", "This PR eliminated the ambiguities described in #1044.", "NaN"], ["1058", "Typo in javadoc", "Jacek Laskowski", "jaceklaskowski", "04/21/14, 07:55:23 PM", "NaN", "NaN"], ["1061", "OperatorAll", "David Karnok", "akarnokd", "04/23/14, 04:01:16 AM", "Reimplemented `All`.\n\nIssue #1060", "NaN"], ["1062", "OperatorAny", "David Karnok", "akarnokd", "04/23/14, 04:10:05 AM", "Reimplemented `Any`, aka `IsEmpty` and `Exists`.\n\nIssue #1060", "NaN"], ["1063", "Fix bugs in equals and hashCode of Timestamped", "Shixiong Zhu", "zsxwing", "04/23/14, 04:10:32 AM", "`equals` and `hashCode` of `Timestamped` are not correct. I just used eclipse to generate a new one.", "NaN"], ["1064", "Operator AsObservable", "David Karnok", "akarnokd", "04/23/14, 04:15:39 AM", "Rewritten AsObservable.\n\nIssue #1060", "NaN"], ["1065", "Optimize OperatorSkipLastTimed", "Shixiong Zhu", "zsxwing", "04/24/14, 06:54:49 PM", "Changed OperatorSkipLastTimed to only cache the latest items in the specified time window.", "NaN"], ["1066", "CompositeSubscription fix", "David Karnok", "akarnokd", "04/23/14, 04:19:32 AM", "A bug in the remove() method caused ArrayIndexOutOfBoundsException if the composite is not empty and trying to remove a subscription that is not in the composite at all.", "NaN"], ["1068", "add synchronous test of resubscribe after error", "Dave Moten", "davidmoten", "04/23/14, 04:20:14 AM", "I've added a simple synchronous test of resubscription after error. Retry has had a chequered history of late and I think might benefit from extra tests. The scenario is perhaps covered by the recent additions with #1027 but the test additions for that were async and more complex. This simple scenario broke for versions to 0.16.1 to 0.17.4, hung with 0.17.5 and passes in 0.17.6.", "NaN"], ["1069", "Manual Merge of OperatorAll", "Ben Christensen", "benjchristensen", "04/23/14, 04:01:15 AM", "NaN", "NaN"], ["1070", "Manual Merge of OperatorAny", "Ben Christensen", "benjchristensen", "04/23/14, 04:10:05 AM", "NaN", "NaN"], ["1071", "Manual Merge of AsObservable", "Ben Christensen", "benjchristensen", "04/23/14, 04:15:39 AM", "NaN", "NaN"], ["1072", "Scheduler.Inner -> Scheduler.Worker", "Ben Christensen", "benjchristensen", "04/23/14, 04:33:06 AM", "As per decision at https://github.com/Netflix/RxJava/issues/997#issuecomment-40998613", "NaN"], ["1073", "OperatorBuffer", "David Karnok", "akarnokd", "04/24/14, 06:56:52 PM", "Operator Buffer, split into 4 variants.\n\nIssue #1060.\n\nThere are some important behavioral changes compared to the original versions:\n- When an onError event appears from anywhere, the currently accumulated chunk(s) are _NOT_ emitted before the error is propagated. This conforms with Rx Design Guideline 6.6.\n- The Observable returned by the Func0 inside the `buffer(Func0<Observable<B>>)` now is used as long as possible and whenever it fires an event, a new buffer chunk is started. The Func0 is called only once per subscriber. The original called it and subscribed to it all the time, causing all-increasing resubscriptions.", "NaN"], ["1074", "OperatorConcat", "David Karnok", "akarnokd", "04/24/14, 06:59:12 PM", "Operator Concat\n\nIssue #1060", "NaN"], ["1075", "OperatorDebounce", "David Karnok", "akarnokd", "04/25/14, 07:53:40 AM", "Operator Debounce\n\nIssue #1060\n\nTwo notes:\n- The behavior of the timed debounce has changed. In the original, if an onCompleted event arrived after an onNext event, that last value was lost. This new version emits the last value if it can then completes. This is consistent with the selector-based debounce operator from before and now.\n- In both overloads, when the emission is run in parallel with the onCompleted of the main, the last event might or might not reach the client subscriber: one of the threads will grab the last value, but the call to the client.onCompleted might prevent the value delivery in the emission thread. This couldn't happen in the original as the event emissions where performed under the lock as well. We need to decide if we want to handle this corner case.", "NaN"], ["1079", "OperatorCombineLatest", "David Karnok", "akarnokd", "04/24/14, 09:21:37 PM", "Operator CombineLatest\n\nIssue #1060\n\nRemarks:\n- Added an overload to Observable which accepts any number of sources. Not sure why it wasn't exposed before? Perhaps removed?\n- Relying on just the SO's onNext is not enough as leaving the synchronized block allows reordering of onNext calls. Therefore, the combinator uses the trick from SerializedObserver to make sure the combination order is consistent with whe winning of the synchronization \"race\". ", "NaN"], ["1080", "OperatorDefaultIfEmpty", "David Karnok", "akarnokd", "04/24/14, 09:21:37 PM", "Operator DefaultIfEmpty\n\nIssue #1060", "NaN"], ["1081", "OperatorDefer", "David Karnok", "akarnokd", "04/24/14, 09:21:37 PM", "Operator Defer\n\nIssue #1060", "NaN"], ["1082", "OperatorDelay", "David Karnok", "akarnokd", "04/25/14, 06:42:32 AM", "Operator Delay\n\nIssue #1060\n\nI've applied the same item-delaying logic found in the timed delay to the selector-based delay. It looks elegant but adds a few extra layers layers and thus increases the per item delivery overhead.", "NaN"], ["1083", "OperatorDematerialize", "David Karnok", "akarnokd", "04/24/14, 09:21:38 PM", "Operator Dematerialize\n\nIssue #1060\n\nTwo notes:\n- Since the dematerialize() is an instance method, there is no correct type parametrization for the operator. Therefore, I just used a raw version in the call.\n- The original dematerialize could send out two onCompleted or an onError followed by an onCompleted because the materialize() always adds an onCompleted after the raw events. This affected operators due to unsafeSubscribe. This new version ensures this doesn't happen.", "NaN"], ["1084", "OperatorDistinct", "David Karnok", "akarnokd", "04/24/14, 09:21:38 PM", "Operator Distinct\n\nIssue #1060\n\nI didn't port the variant with the custom key comparator because it has been decided to rely on `Object.equals` and there were not exposed anyway.", "NaN"], ["1085", "OperatorDistinctUntilChanged", "David Karnok", "akarnokd", "04/24/14, 09:21:38 PM", "Operator DistinctUntilChanged\n\nIssue #1060\n\nAgain, I haven't ported the custom comparator version.", "NaN"], ["1086", "OperatorFinallyDo", "David Karnok", "akarnokd", "04/24/14, 09:21:38 PM", "Operator FinallyDo\n\nIssue #1060", "NaN"], ["1087", "OperatorMergeMap", "David Karnok", "akarnokd", "04/24/14, 09:21:38 PM", "Operator MergeMap, namely the paired and the one which turns all event kinds into Observables to merge.\n\nIssue #1060", "NaN"], ["1088", "OperatorToObservableFuture", "Shixiong Zhu", "zsxwing", "04/24/14, 09:21:38 PM", "Also make the Observable be able to unsubscribe.\n\nIssue #1060", "NaN"], ["1089", "Manual Merge of Several PRs", "Ben Christensen", "benjchristensen", "04/24/14, 09:21:37 PM", "This was a manual merge since each of these was conflicting due to the changing import statements at the top. I really wish Github allowed easily handling these ... ", "NaN"], ["1091", "Handle Thrown Errors with UnsafeSubscribe", "Ben Christensen", "benjchristensen", "04/25/14, 02:57:34 AM", "... oxymoronic commit here ... adding some safety to unsafeSubscribe.\n... fixes https://github.com/Netflix/RxJava/issues/1090", "NaN"], ["1092", "Restore ObservableExecutionHook.onCreate", "Ben Christensen", "benjchristensen", "04/25/14, 03:01:00 AM", "NaN", "NaN"], ["1093", "OperatorDelay", "David Karnok", "akarnokd", "05/05/14, 05:51:41 AM", "Operator Delay rewritten and improved as discussed in #1082\n\nFor Issue #1060", "NaN"], ["1094", "Operator debounce2", "David Karnok", "akarnokd", "04/30/14, 12:11:24 AM", "Operator Debounce again with improvements as discusssed in #1075\n\nFor Issue #1060", "NaN"], ["1095", "OperatorGroupByUntil", "David Karnok", "akarnokd", "04/30/14, 12:11:24 AM", "Operator GroupByUntil\n\nFor Issue #1060\n\nWhile rewriting, I've noticed a common pitfall with the observation of the duration: many other operators react to onNext or onCompleted, but one should only \"expire\" once. I'll review my recent operators and post a separate PR if any.", "NaN"], ["1096", "OperatorGroupJoin", "David Karnok", "akarnokd", "04/30/14, 12:11:24 AM", "Operator GroupJoin\n\nfor Issue #1060\n\nMaybe this could be moved to the new joins.", "NaN"], ["1097", "OperatorToMultimap", "Shixiong Zhu", "zsxwing", "04/30/14, 12:11:24 AM", "Operator `ToMultimap`\n\nIssue #1060", "NaN"], ["1098", "OperatorTimerAndSample", "David Karnok", "akarnokd", "04/30/14, 12:11:24 AM", "Operator Timer and Sample\n\nBecause there was a dependency in Sample towards the now removed Interval, I had to reimplement Sample in this PR as well.\n\nNote that the new `OperatorSampleWithTime` schedules its first sample call before any upstream code is executed. Given the TestScheduler, a sample with 1sec and a timer with 1sec as well won't sample any value. The reason is that in the internal queue of TestScheduler, the sampler's action to take the sample is followed by the action to emit the timer's value.", "NaN"], ["1099", "OperatorToMap", "Shixiong Zhu", "zsxwing", "04/30/14, 12:11:24 AM", "Operator `ToMap`\n\nIssue #1060", "NaN"], ["1100", "OperatorUsing", "Shixiong Zhu", "zsxwing", "04/30/14, 12:11:24 AM", "Operator `Using`\n\nIssue #1060", "NaN"], ["1101", "Operator async", "David Karnok", "akarnokd", "04/30/14, 12:11:24 AM", "`contrib-async-util` mostly renames, deprecated api removed, file comment fixed\n\nSidenote: for me, NetBeans 8.0 editor shows errors in all the files, unable to find rxjava-core classes. Using build command from the menu works. This is true for the other contrib packages as well. Any tips on why?", "NaN"], ["1102", "rxjava-android Poposal: Call action immediately in HandlerThreadScheduler if thread is the same", "Yaroslav", "Yarikx", "05/17/14, 03:30:08 PM", "By avoiding unnecessary Runnable creation, and posting it to handler we can decrease overhead when scheduling is made from the same thread.\n\nCurrent Activity.runOnUIThread is implemented in the same way:\n\n``` java\n    public final void runOnUiThread(Runnable action) {\n        if (Thread.currentThread() != mUiThread) {\n            mHandler.post(action);\n        } else {\n            action.run();\n        }\n    }\n```", "NaN"], ["1103", "OperatorJoin", "David Karnok", "akarnokd", "04/30/14, 12:11:24 AM", "Operator Join\n\nIssue #1060\n\nRemark: now that the client.onNext is called outside the synchronization block, joint results may appear in arbitrary order in case both left and right observables emit values concurrently. I suppose the strict ordering is not really expected here, but someone who uses this operator can tell (@duncani perhaps?) .", "NaN"], ["1104", "Operator merge delay error", "David Karnok", "akarnokd", "04/30/14, 12:11:24 AM", "Operator MergeDelayError\n\nIssue #1060", "NaN"], ["1106", "OperatorMergeMaxConcurrent", "David Karnok", "akarnokd", "04/30/14, 12:11:24 AM", "Operator MergeMaxConcurrent\n\nIssue #1060", "NaN"], ["1107", "Fix ReplaySubject's double termination problem.", "David Karnok", "akarnokd", "04/30/14, 12:11:24 AM", "Fix for issue #1105", "NaN"], ["1108", "OperatorMulticastAndReplay", "David Karnok", "akarnokd", "04/30/14, 12:11:25 AM", "Operator Multicast and Replay, because Replay is effectively a multicasted subject.\n\nIssue #1060", "NaN"], ["1109", "OperatorOnErrorResumeNextViaObservable", "David Karnok", "akarnokd", "04/30/14, 12:11:25 AM", "Operator OnErrorResumeNextViaObservable\n\nIssue #1060", "NaN"], ["1110", "OperatorOnErrorReturn", "David Karnok", "akarnokd", "04/30/14, 12:11:25 AM", "Operator OnErrorReturn\n\nIssue #1060", "NaN"], ["1111", "OperatorTimeInterval", "Shixiong Zhu", "zsxwing", "04/30/14, 12:11:25 AM", "Operator `TimeInterval`\n\nIssue #1060", "NaN"], ["1112", "OperatorThrottleFirst", "Shixiong Zhu", "zsxwing", "04/30/14, 12:11:25 AM", "Operator `ThrottleFirst` and moved tests in `ThrottleFirstTests` to `OperatorThrottleFirstTest`.\n\nIssue #1060", "NaN"], ["1113", "testing push to remote fork repository", "Peter \"Felix\" Nguyen", "PeterFelixNguyen", "04/27/14, 05:52:49 AM", "testing pull request to a fork???", "NaN"], ["1114", "testing push to remote fork repository", "Peter \"Felix\" Nguyen", "PeterFelixNguyen", "04/27/14, 05:53:39 AM", "testing pull request to a fork???", "NaN"], ["1115", "OperatorTakeWhile", "Shixiong Zhu", "zsxwing", "04/30/14, 12:11:25 AM", "Operator `TakeWhile`\n\nIssue #1060", "NaN"], ["1117", "Operator OnExceptionResumeNextViaObservable", "David Karnok", "akarnokd", "04/30/14, 12:11:25 AM", "Operator OnExceptionResumeNextViaObservable\n\nIssue #1060", "NaN"], ["1118", "Operator ParallelMerge", "David Karnok", "akarnokd", "04/30/14, 12:11:25 AM", "Operator ParallelMerge, just renamed\n\nIssue #1060", "NaN"], ["1119", "OperatorRefCount", "David Karnok", "akarnokd", "04/30/14, 12:11:25 AM", "Operator RefCount\n#1060", "NaN"], ["1120", "OperatorSequenceEqual", "David Karnok", "akarnokd", "04/30/14, 12:11:25 AM", "Operator SequenceEqual\n#1060\n\nLightened the operator, but note that NotificationLite escaping an operator may cause undesired effects in other operators relying on NotificationLite as well.", "NaN"], ["1121", "OperatorSkipTimed", "David Karnok", "akarnokd", "04/30/14, 12:11:25 AM", "Operator SkipTimed\n#1060\n\nThere was an unexpected dependency in `OperationTakeTimedTest` and is surely to cause conflict when `TakeTimed` is rewritten. Once all operators have been merged, I suggest we create a primary `TestException` and rewrite tests to use it instead of all those custom exception classes everywhere.", "NaN"], ["1122", "OperatorSkipUntil", "David Karnok", "akarnokd", "04/30/14, 12:11:25 AM", "Operator SkipUntil\n#1060", "NaN"], ["1123", "Operator Window", "David Karnok", "akarnokd", "04/30/14, 04:09:25 PM", "Operator Window\n\nIssue #1060\n\nSignificant changes have been implemented in the new Window operator's behavior:\n- The original sized, timed and start-end observable versions waited until a window has finished and emitted the buffered values as a single `Observable.from`. This is not how the Rx.NET version behaves where once a window is open, values are delivered as they appear from source. This has the same effects as `groupBy` where Observable windows not subscribed immediately will not deliver all values. Probably this is why Clojure test `test-partition-all` fails, but I don't know how to fix it there.\n- The callback boundary-observable version, similar to the buffer variant before, constantly created a new observable for each value. This new version, consistent with the new buffer, uses one boundary source per subscribing client.\n- The exact variants (such as size == skip, timespan == timeshift and observable boundary) make extra effort to ensure all events are delivered into one of the windows, i.e., no event will fall between the closing and opening of a window gap when it concurrently appears from the source.\n\nThis rewrite needs more meticulous review due to the changes and their concurrency effects.", "NaN"], ["1124", "Add lift to rxscala", "Shixiong Zhu", "zsxwing", "05/05/14, 07:09:43 PM", "This PR added `lift` to RxScala and also added a `Subscriber.apply` method to support to chain `Subscriber`s.\n\n/cc @samuelgruetter", "NaN"], ["1125", "Operator contrib math", "David Karnok", "akarnokd", "04/30/14, 12:11:26 AM", "Operators of contrib-math\n\nIssue #1060\n\nI only changed the average code to operators, left the sum and min/max as they were. Renamed files to operator.", "NaN"], ["1126", "Operator When", "David Karnok", "akarnokd", "04/30/14, 12:11:26 AM", "Operator When in contrib-joins\n\nIssue #1060", "NaN"], ["1128", "Fix for SerializedObserverTest", "David Karnok", "akarnokd", "04/30/14, 12:11:26 AM", "Fixed the SerializedObserverTest's problematic assertions:\n- `testMultiThreadedWithNPEinMiddle` might schedule all non-null values before the exception might reach the serialized observer. In addition, waiting after the serialization doesn't help because the cheap value emissions get queued up before that, again, possibly before the exception. The new code adds some delays to the non-null elements allowing the exception to get into the queue. I've looped it 10.000 times without failure, but there is still a non-zero chance the `new NullPointerException()` thread is significantly delayed and ends up as the last event.\n- `testNotificationDelay` might fail due to thread scheduling of the two `OnNextThread` delayed too much in respect to each other before the main thread allows the pass-through. The fix is to let bot instances' Thread reach the run method and then let the main thread pass through them. Again, a loop of 10.000 succeeded locally.\n- Both tests are run 10 times to be more sure.", "NaN"], ["1129", "Conditional statements contribution to Operator", "David Karnok", "akarnokd", "04/30/14, 12:11:26 AM", "Operators rewritten in contrib-computation-expressions.\n\nIssue #1060", "NaN"], ["1130", "Operator Switch", "David Karnok", "akarnokd", "04/30/14, 12:11:26 AM", "Operator Switch\n\nIssue #1060", "NaN"], ["1131", "Operator TakeTimed", "David Karnok", "akarnokd", "04/30/14, 12:11:26 AM", "Operator Take with time\n\nIssue #1060", "NaN"], ["1132", "Manual Merge of Several PRs", "Ben Christensen", "benjchristensen", "04/30/14, 12:11:23 AM", "Merging many PRs that were conflicting.\n\nHeroic work by @akarnokd and @zsxwing on #1060 \n\nAll unit tests are passing on my machine. Going to let this bake a while before a release. Other PRs on still on their way ... ", "NaN"], ["1133", "collapse imports", "Ben Christensen", "benjchristensen", "04/30/14, 12:13:02 AM", "attempt to reduce merge conflicts as it's always the import statements that are conflicting", "NaN"], ["1134", "OperatorTakeLast", "Shixiong Zhu", "zsxwing", "05/05/14, 07:11:08 PM", "Operator `TakeLast`.\n\nThere are two changes comparing with the original implementations:\n- Throw IndexOutOfBoundsException at once when calling `takeLast` with `count < 0`.\n- Replace IllegalArgumentException with IndexOutOfBoundsException  when `count < 0` in `TakeLastWithTimed`.\n\nIssue #1060", "NaN"], ["1135", "OperatorTakeUntil", "Shixiong Zhu", "zsxwing", "05/05/14, 07:12:09 PM", "Operator `TakeUntil`\n\nIssue #1060", "NaN"], ["1137", "Fixes to the operators.", "David Karnok", "akarnokd", "05/05/14, 07:15:17 PM", "Fixes for issue #1136\n- `OperatorMulticast` is straightforward from concurrency perspective. The only consideration is that if the current subscription gets unsubscribed before the `connect` reaches the `unsafeSubscribe`, it really depends on the source what it will do with an unsubscribed client. It is possible to put extra effort to make sure a newly established connection won't get unsubscribed before it is actually connected or if it gets unsubscribed immediately, no subscription is attempted at all.\n- `OperatorSampleWithTime`: didn't want to push too many PRs so I just included it here. There was a missing unsubscribe in the `onCompleted()` that makes sure the worker is stopped.\n- `Subscribers.empty()` was implemented by returning the same Subscriber to everyone, which Subscriber is stateful so if someone unsubscribes it, it will appear everywhere as unsubscribed and can have unwanted effects. There is no such problem with `Observers.empty()` as it is stateless. The change just uses `Subscribers.from()` to wrap `Observers.empty()` and every caller gets its own independent instance.\n- `OperatorRefCount` was a bit more tricky. Since it has a connection counter, one has to serialize subscriptions with unsubscriptions. However, it is possible a subscription gets unsubscribed before code reaches the connect check which may disrupt the connection counter. The solution is to keep track of the unsubscriptions that happen before the connection attempts and not change the counter in case of out-of-order behavior. The final aim was to avoid leaking the connection statuses if the `unsafeSubscribe` throws concurrently with a client unsubscribing by using weak tokens (integers wouldn't have worked as the first 0-127 are cached in the JVM and would never GC).", "NaN"], ["1138", "Operator Window and other changes", "David Karnok", "akarnokd", "05/05/14, 07:17:50 PM", "Operator Window with no-first-loss functionality.\n\nIssue #1060\n\n(I had to leave my computer so the detailed description will come within a few hours.)", "NaN"], ["1142", "Update 'contains' signature to 'contains(Object)'", "Shixiong Zhu", "zsxwing", "05/05/14, 07:18:25 PM", "The original `contains` signature can not support the following codes:\n\n``` java\n    public void test() {\n        ArrayList<String> l = new ArrayList<String>();\n        l.add(\"test\");\n        Observable<ArrayList<String>> o = Observable.<ArrayList<String>>from(l);\n        o.contains(Arrays.asList(\"test\"));\n    }\n```\n\nThis PR changes the signature from `contains(T)` to `contains(Object)`. It's also consistent with `equals(Object)`.\n\nThis change should not break the old codes.", "NaN"], ["1143", "CachedThreadScheduler for use as default IO Scheduler", "Joakim Bodin", "jbripley", "05/20/14, 10:35:14 AM", "Here is an implementation of the CachedThreadScheduler discussed in #1140.\n\nI've been testing this against my own web service using load tests and it holds up fairly well. There seems to be a bit more retention of expired event loops during high load than I like. So I would appreciate a code review to make sure I haven't missed any part of the scheduler/subscription life cycle. Or if there's any unintentional reference keeping event loops or scheduler Worker instances from being garbage collected.", "NaN"], ["1144", "Operator Delay rebase & fixes", "David Karnok", "akarnokd", "05/05/14, 07:25:55 PM", "Operator Delay\n\nIssue #1060", "NaN"], ["1145", "Large CompositeSubscription performance improvements", "David Karnok", "akarnokd", "05/30/14, 06:28:18 AM", "This is a proposition to improve the addition/removal speed of the `CompositeSubscription` in case of thousands of items in it. \n\nIn some operators, especially when using Schedulers and/or observeOn, thousands of items may be present in the composite and since adding/removing a new item is O(n), it takes more and more time to add and remove items once the composite gets large.\n\nMy proposal is to change the composite state implementation to switch to a HashSet representation above a certain threshold (and switch back below some). The following diagram shows some benchmarking results. (Configuration: i7 920 @ 2.4GHz, 32K L1 Data, 256K L2, 8M L3, 6GB DDR3 1333MHz RAM, Windows 7 x64, Java 8u05 x64.)\n\n![image](https://cloud.githubusercontent.com/assets/1269832/2877095/4779ac40-d443-11e3-9c0a-908ea49c6219.png)\n\nThis benchmark how the CompositeSubscription behaves when there are some items already in it and a new unique item is added and removed immediately (all single threaded). The blue line indicates the current master implementation; the red, green and purple show the new implementation with thresholds set to 8, 16 and 24 respectively. Once the internal array size reaches the cache-line size, it is generally better to use HashSet instead.\n\nThe second benchmark compares how fast can the CompositeSubscription be filled with subscribers to a various capacity, and how the target size affects the fill speed.\n\n![image](https://cloud.githubusercontent.com/assets/1269832/2877162/afcb76a6-d444-11e3-8c4c-c3ba85e6c1d3.png)\n\nWhen the composite is filled in, the one-by-one array resize performs better until a larger capacity is reached, but then again, using a HashSet to append further items is faster. Unfortunately, what seems to be an optimal threshold for the first case performs worse in this case.\n\nThere are some drawbacks of this hybrid approach:\n- The optimal threshold value depends on the use case and the target system. How can we enable to tune this parameter. Parameter tuning could be handy in other places in RxJava; how can we enable it?\n- I'm not 100% certain if I've correctly implemented the switchover from atomic states to mutable state and back.", "NaN"], ["1146", "Scheduler fixes505", "David Karnok", "akarnokd", "05/06/14, 07:54:15 AM", "This PR contains some changes to the NewThreadScheduler and EventLoopScheduler, which makes them work more correctly and gives some flexibility to them.\n\nNote that this conflicts with PR #1143.\n\nNotable changes:\n- Changed `NewThreadScheduler` to use a `ScheduledExecutorService` as I don't see any particular reason why not.\n- Added proper logic for tracking and unsubscribing scheduled actions.\n- Renamed inner classes to better express their purpose (got lost in all of those inner EventLoopScheduler workers).\n- Added the ability to specify the number of cores and the worker selection policy to `EventLoopScheduler`. Two policies are available: round robin and least-recent (default). A new `Schedulers.fixed()` method is added which lets the caller specify the pool size. Since the EventLoopScheduler is package private, I wasn't sure how to expose the worker selection policy. In addition, EventLoopScheduler implements Subscription so the Scheduler returned by `fixed()` can be terminated. I made sure the `computation()` scheduler can't be terminated this way.\n- Fixed `EventLoopScheduler` to track the submitted actions properly.\n- Note that the potential Subscription leak due to `innerSubscription.remove()` happening before `innerSubscription.add()` in `EventLoopWorker` is not handled. It can't happen with `NewThreadScheduler` though, although it would benefit from a `CompositeSubscription.delete()` method which doesn't unsubscribe the removed item and thus not interrupting the executor unnecessarily.", "NaN"], ["1148", "Manual Merge of Delay PR", "Ben Christensen", "benjchristensen", "05/05/14, 07:25:55 PM", "NaN", "NaN"], ["1150", "Fix ReplaySubject Terminal State Race Condition", "Ben Christensen", "benjchristensen", "05/05/14, 08:41:28 PM", "Fixes https://github.com/Netflix/RxJava/issues/1147#issuecomment-42232464 with change from @akarnokd", "NaN"], ["1158", "Scheduler correctness improvements.", "David Karnok", "akarnokd", "05/06/14, 06:31:39 PM", "Second round on the scheduler correctness issue.\n\nSure it looks more heavy as `ScheduledAction` now has its own inner `CompositeSubscription` and a shared reference to the parent `innerSubscription`.\n\nI've tried to benchmark it with `SchedulerPerformanceTests` but that test is flawed:\n- Multiple threads pound on the same long sum value, so naturally additions get lost.\n- The LongObserver gets unsubscribed after the first loop so `from` will not actually call `onNext` but `isUnsubscribed` a lot.\n- Does not wait for the computations to finish and basically measures how fast 5M tasks can be added to the NewThreadScheduler's innerSubscription.\n\nThe flawed test gives ~ 11M ops/sec on my machine. If I fix the test and run against the master, 5M takes extremely long to finish due to the inherent slowness of add/remove in CompositeSubscription if large. On my 4 core hyperthread enabled machine, I get 50k-150k ops/second for baseline with a 100k loop.\n\nThe proposed changes run with the flawed test gives ~10.8M ops/sec. With the test fixed and with the proposed changes, I get ~1.2M ops/sec.", "NaN"], ["1159", "Rxscala improvement", "Shixiong Zhu", "zsxwing", "05/06/14, 05:11:38 PM", "Add `dropUntil`, `contains`, `repeat`, `doOnTerminate`, `startWith`, `publish` variants to RxScala. #1151, #1153.\n\n/cc @headinthebox @samuelgruetter", "NaN"], ["1160", "Add `replay` and `multicast` variants to RxScala", "Shixiong Zhu", "zsxwing", "05/20/14, 04:31:05 PM", "This PR has some breaking changes:\n- Change `def multicast[R >: T](subject: rx.lang.scala.Subject[R]): (() => Subscription, Observable[R])` to `def multicast[R >: T](subject: rx.lang.scala.Subject[R]): ConnectableObservable[R]`\n- Change `def replay: (() => Subscription, Observable[T])` to `def replay: ConnectableObservable[T]`\n- Remove `Observable.apply(Int)`\n\nSo it's better to merge it at the next major release.\n#1152, #1153.\n\n/cc @headinthebox @samuelgruetter", "NaN"], ["1161", "Removed use of deprecated API from tests & operators, fixed year in head...", "David Karnok", "akarnokd", "05/06/14, 05:04:26 PM", "...ers, added and removed suppressions, fixed line endings, replaced tabs with spaces\n\nI haven't deleted `OnSubscribeFunc` because I was not sure when the general cleanup of deprecated stuff will happen; I just made sure Java tests don't use it anymore.", "NaN"], ["1162", "fix to remove drift from schedulePeriodic", "Kirk Shoop", "kirkshoop", "05/06/14, 05:11:12 PM", "When implementing the 'worker' scheduler pattern in rxcpp I implemented schedulePeriodic differently because I predicted that the RxJava version would drift. Once the changes were working, I verified my prediction in rxcpp. \n\nI decided to test the same in RxJava and contribute my approach.\n\nThis was my test:\n\n``` java\nimport java.util.concurrent.TimeUnit;\n\nimport rx.Scheduler;\nimport rx.schedulers.Schedulers;\nimport rx.functions.Action0;\n\npublic class periodic {\n\n    public static void main(String[] args) {\n\n        final Scheduler scheduler = Schedulers.immediate();\n        final Scheduler.Worker w = scheduler.createWorker();\n\n        final long initial = TimeUnit.SECONDS.toMillis(2);\n        final long period = TimeUnit.SECONDS.toMillis(1);\n        final long start = scheduler.now() + initial;\n\n        w.schedulePeriodically(new Action0() {\n            long count = 0;\n            @Override\n            public void call() {\n                long tick = scheduler.now();\n                System.out.println(String.format(\"expected -> %dms, actual -> %dms, drift -> %dms\", count*period, tick - start, tick - (start + (count*period))));\n                ++count;\n            }\n        }, initial, period, TimeUnit.MILLISECONDS);\n    }\n\n}\n```\n\nThe existing impl causes this output:\n\n```\n$ java -cp rxjava-core/build/libs/rxjava-core-0.18.3-SNAPSHOT.jar:./ periodic\nexpected -> 0ms, actual -> 1ms, drift -> 1ms\nexpected -> 1000ms, actual -> 1002ms, drift -> 2ms\nexpected -> 2000ms, actual -> 2003ms, drift -> 3ms\nexpected -> 3000ms, actual -> 3004ms, drift -> 4ms\nexpected -> 4000ms, actual -> 4005ms, drift -> 5ms\nexpected -> 5000ms, actual -> 5006ms, drift -> 6ms\nexpected -> 6000ms, actual -> 6007ms, drift -> 7ms\nexpected -> 7000ms, actual -> 7008ms, drift -> 8ms\nexpected -> 8000ms, actual -> 8009ms, drift -> 9ms\nexpected -> 9000ms, actual -> 9010ms, drift -> 10ms\nexpected -> 10000ms, actual -> 10011ms, drift -> 11ms\nexpected -> 11000ms, actual -> 11012ms, drift -> 12ms\nexpected -> 12000ms, actual -> 12013ms, drift -> 13ms\nexpected -> 13000ms, actual -> 13014ms, drift -> 14ms\nexpected -> 14000ms, actual -> 14016ms, drift -> 16ms\nexpected -> 15000ms, actual -> 15017ms, drift -> 17ms\nexpected -> 16000ms, actual -> 16018ms, drift -> 18ms\nexpected -> 17000ms, actual -> 17019ms, drift -> 19ms\nexpected -> 18000ms, actual -> 18020ms, drift -> 20ms\nexpected -> 19000ms, actual -> 19021ms, drift -> 21ms\nexpected -> 20000ms, actual -> 20022ms, drift -> 22ms\nexpected -> 21000ms, actual -> 21023ms, drift -> 23ms\nexpected -> 22000ms, actual -> 22023ms, drift -> 23ms\nexpected -> 23000ms, actual -> 23024ms, drift -> 24ms\n```\n\nWith this commit the test outputs:\n\n```\n$ java -cp ./:./rxjava-core/build/libs/rxjava-core-0.18.3-SNAPSHOT.jar periodic\nexpected -> 0ms, actual -> 3ms, drift -> 3ms\nexpected -> 1000ms, actual -> 1001ms, drift -> 1ms\nexpected -> 2000ms, actual -> 2001ms, drift -> 1ms\nexpected -> 3000ms, actual -> 3000ms, drift -> 0ms\nexpected -> 4000ms, actual -> 4001ms, drift -> 1ms\nexpected -> 5000ms, actual -> 5000ms, drift -> 0ms\nexpected -> 6000ms, actual -> 6000ms, drift -> 0ms\nexpected -> 7000ms, actual -> 7000ms, drift -> 0ms\nexpected -> 8000ms, actual -> 8001ms, drift -> 1ms\nexpected -> 9000ms, actual -> 9001ms, drift -> 1ms\nexpected -> 10000ms, actual -> 10001ms, drift -> 1ms\nexpected -> 11000ms, actual -> 11001ms, drift -> 1ms\nexpected -> 12000ms, actual -> 12001ms, drift -> 1ms\nexpected -> 13000ms, actual -> 13001ms, drift -> 1ms\nexpected -> 14000ms, actual -> 14001ms, drift -> 1ms\nexpected -> 15000ms, actual -> 15001ms, drift -> 1ms\nexpected -> 16000ms, actual -> 16001ms, drift -> 1ms\nexpected -> 17000ms, actual -> 17000ms, drift -> 0ms\nexpected -> 18000ms, actual -> 18000ms, drift -> 0ms\nexpected -> 19000ms, actual -> 19000ms, drift -> 0ms\nexpected -> 20000ms, actual -> 20000ms, drift -> 0ms\nexpected -> 21000ms, actual -> 21002ms, drift -> 2ms\nexpected -> 22000ms, actual -> 22000ms, drift -> 0ms\nexpected -> 23000ms, actual -> 23001ms, drift -> 1ms\nexpected -> 24000ms, actual -> 24001ms, drift -> 1ms\n```", "NaN"], ["1163", "Fix defer for Java 8 type-inference", "Ben Christensen", "benjchristensen", "05/06/14, 04:58:22 PM", "Fixes https://github.com/Netflix/RxJava/issues/1157", "NaN"], ["1164", "JMH Perf Tests for Schedulers.computation", "Ben Christensen", "benjchristensen", "05/06/14, 06:22:16 PM", "NaN", "NaN"], ["1165", "Update according to review in issue #1159", "Shixiong Zhu", "zsxwing", "05/08/14, 05:06:53 AM", "/cc @samuelgruetter", "NaN"], ["1166", "Scheduler Improvements 507", "David Karnok", "akarnokd", "05/12/14, 06:55:01 AM", "NewThread/EventLoop scheduler improvements proposal.\n\n**NewThreadScheduler**\n\nThere is no need to have an `innerSubscription` there as the underlying Executor knows what tasks are in its queue and a `shutdown` will cancel them anyway. In the original version, I made a small mistake by leaving out an `innerSubscription.add(s)` which was one of the main contribution to the speed improvements (did not affect correctness).\n\n**EventLoopScheduler**\n\nAn EventLoopScheduler needs to track its tasks so it can selectively cancel them in the NewThreadScheduler. Since an ELS worker is single threaded, the addition and removal of the completed tasks are more like queue operations; adding a last item and removing a first item in CompositeSubscription can be expensive even if the size is small due to the copying and state machine overhead. \n\n**SubscriptionQueue**\n\nTherefore, I've built a special array-based (ringbuffer) queue called `SubscriptionQueue` which can resize itself as needed, similar to ArrayDeque, but behaves like a composite and queued items can be unsubscribed at once and provides the usual cancellation policy. When benchmarked with a simple loop of add/remove pair, it gives ~ 532 Mops/s whereas `CompositeSubscription` gives 16 Mops/s. It uses `synchronized` as generally one needs to synchronize the producer(s) of tasks with the completion of the tasks on the worker thread, where the producer count is likely small. The initial queue capacity is 8 which favors fast tasks and the array fits nicely into a typical 64 byte cache line. One unique property is that it dequeues based on object identity and not the head of the queue. The reason for this is that when there are multiple producers, queueing their subscriptions might happen in different order than their tasks are scheduled (i.e., the head of the queue points to s1 while t2 gets scheduled first).\n\n**Perf tests**\n\nI did some perf testing with `ComputationSchedulerPerf` but I ran into some trouble: the initial 512M memory for the benchmark doesn't seem to be enough, especially on a 4/8 core machine. Both the master and this PR goes really slow or fails with GC errors because the internal queues of the Executors get flooded with tasks. Each task is about 650 byte and having tens of thousands queued up consumes lot of memory. I run the perftests with 1300M which was enough although still pounding on the GC. (Btw, I don't understand the perf code: does the subscribeOn test do 1M one-time subscription, or subscribes to a stream of 1M elements? If the latter, what are the tasks that hammer the executor?)\n\n_Master_ (https://gist.github.com/akarnokd/1fe0fb74f896c48c61a8)\n\n```\nBenchmark                                   (size)   Mode   Samples         Mean   Mean error    Units\nr.s.ComputationSchedulerPerf.observeOn           1   avgt         5     1944,238       64,954    ns/op\nr.s.ComputationSchedulerPerf.observeOn        1024   avgt         5   119353,236     1968,424    ns/op\nr.s.ComputationSchedulerPerf.observeOn     1048576   avgt         5 129596502,875 11464347,421    ns/op\nr.s.ComputationSchedulerPerf.subscribeOn         1   avgt         5     1659,862      462,385    ns/op\nr.s.ComputationSchedulerPerf.subscribeOn      1024   avgt         5  4643038,650 39587231,914    ns/op\nr.s.ComputationSchedulerPerf.subscribeOn   1048576   avgt         5   317353,904   566003,080    ns/op\n```\n\n**This proposal** (https://gist.github.com/akarnokd/6d9ba66761c5bdb8ecd7)\n\n```\nBenchmark                                   (size)   Mode   Samples         Mean   Mean error    Units\nr.s.ComputationSchedulerPerf.observeOn           1   avgt         5     1858,486       73,600    ns/op\nr.s.ComputationSchedulerPerf.observeOn        1024   avgt         5   117680,475     2305,467    ns/op\nr.s.ComputationSchedulerPerf.observeOn     1048576   avgt         5 129298288,453 14093401,564    ns/op\nr.s.ComputationSchedulerPerf.subscribeOn         1   avgt         5      839,078      293,626    ns/op\nr.s.ComputationSchedulerPerf.subscribeOn      1024   avgt         5    51253,754   150446,345    ns/op\nr.s.ComputationSchedulerPerf.subscribeOn   1048576   avgt         5   371325,179   692740,819    ns/op\n```\n\nThe ObserveOn test benefits minimally from the changes.  For the 1 onSubscribe, it drops to 840ns. For the other sizes, I suspect hectic GC overhead so I can't declare a winner.\n\n(Generally, since we use a lot of AtomicXYZ classes, they add 24 bytes to the memory footprint every time a Subscription is present. In order to get rid of them, one would need to replace it with volatile fields and `Unsafe` calls to get the CAS functionality back.)\n\nBenchmarked on an i7 920 @ 2.66GHz, 4/8 hyperthreaded cores, 6GB total RAM, Windows 7 x64, Java 7u55 x64.", "NaN"], ["1170", "fix to allow schedulePeriodic to work after 2262", "Kirk Shoop", "kirkshoop", "05/20/14, 04:25:35 AM", "Thinking further I realized that the schedulePeriodically in #1162 would begin to fail at `Fri Apr 11 16:47:16 PDT 2262`\n\nIf this is deemed too soon to fail, then the solution in this commit will still be working in 292million years.", "NaN"], ["1172", "ObserveOn: Change to batch dequeue.", "David Karnok", "akarnokd", "05/16/14, 04:06:51 AM", "Using the same batch technique as in `SerializedObserver` to dequeue and play values. I had to switch to synchronized because `ConcurrentLinkedQueue` doesn't support drain.\n\nI run the scheduler perf test with it:\n\n```\nResult : 1913,582 \u00b1(99.9%) 29,210 ns/op\n  Statistics: (min, avg, max) = (1905,303, 1913,582, 1922,427), stdev = 7,586\n  Confidence interval (99.9%): [1884,373, 1942,792]\n\nResult : 64.277,546 \u00b1(99.9%) 734,360 ns/op\n  Statistics: (min, avg, max) = (64034,953, 64277,546, 64519,884), stdev = 190,711\n  Confidence interval (99.9%): [63543,186, 65011,906]\n\nResult : 67.999.392,293 \u00b1(99.9%) 4715885,625 ns/op\n  Statistics: (min, avg, max) = (66777535,133, 67999392,293, 69525773,000), stdev = 1224700,521\n  Confidence interval (99.9%): [63283506,668, 72715277,918]\n```\n\nMaster for me was 1863,423 / 119.030,536 / 127.738.858,250 \n\nAppears to be a 2x speedup on 1024 and 1M items.", "NaN"], ["1175", "Fixed synchronous ConnectableObservable.connect problem", "David Karnok", "akarnokd", "05/16/14, 04:04:44 AM", "ConnectableObservable.connect returns a Subscription and thus cannot be unsubscribed synchronously, similar how take didn't work before the Subscriber changes. This PR modifies the `ConnectableObservable` and its current implementation `OperatorMulticast` to extract the connection Subscription token before it is connected to the source. Cancelling this extracted token makes sure the synchronous connection is unsubscribed.\n\n(The Rx.NET version of the test case seemingly doesn't exhibit the problem. I suspect it is the interplay of `IDisposable`s.)", "NaN"], ["1177", "GroupByUntil to use BufferUntilSubscriber", "David Karnok", "akarnokd", "05/09/14, 05:52:08 PM", "Matches `groupBy` behavior. (I still think throwing an error for non-first subscribers is too harsh.)", "NaN"], ["1178", "Fix issue #1173", "Shixiong Zhu", "zsxwing", "05/19/14, 05:38:40 PM", "In `Subscriber.apply(rx.Subscriber)`, `asJavaObserver` and `asJavaSubscription` will be set to `null` because the parent class will be initialized with `asJavaSubscriber==null`. #1173.\n\nThis PR did the initialization again in the subclass.", "NaN"], ["1179", "Add facilities for creating Observables from JavaFX events and Observabl...", "Alexandre Mazari", "amazari", "05/09/14, 04:15:48 PM", "...eValues.\n\nProvides:\n- a Scheduler implementation ensuring execution in the JavaFX UI thread\n- a Subscription implementation ensuring that un-subscription happens in JavaFX UI thread\n- an Observable factory method for observing UI events on JavaFX nodes\n- an Observable factory method for observing value changes of a JavaFX ObservableValue\n\nAlso the rxjava-javafx is added to the gradle build.", "NaN"], ["1181", "Behavior subject time gap fix", "David Karnok", "akarnokd", "05/09/14, 10:40:50 PM", "This fix should make sure subscribing between two event emissions won't create a gap in the received events. I had to implement my own subscription management to ensure the required coordination behavior. \n\nPerformance comparison for simple pass-through behavior:\nPublishSubject (master) ~86 MOps/s\nBehaviorSubject (master) ~47 MOps/s\nBehaviorSubject (this) ~46 MOps/s\n\nThe relative slowness compared to PS is due the volatile write on each element and the additional ~1MOps/s is due to the subscription coordination.", "NaN"], ["1182", "Add facilities for creating Observables from JavaFX events and ObservableValues", "Alexandre Mazari", "amazari", "05/09/14, 11:39:22 PM", "Heavily inspired by the swing contrib.\n\nProvides:\n- a Scheduler implementation ensuring execution in the JavaFX UI thread\n- a Subscription implementation ensuring that un-subscription happens in JavaFX UI thread\n- an Observable factory method for observing UI events on JavaFX nodes\n- an Observable factory method for observing value changes of a JavaFX ObservableValue\n\nAlso the rxjava-javafx is added to the gradle build.", "NaN"], ["1183", "NotificationLite.accept performance improvements", "David Karnok", "akarnokd", "05/09/14, 04:57:21 PM", "This is a proposal for speeding up the `accept()` method (i.e., reducing its latency).\n\nBenchmark comparison:\n\ndirect onNext: 488 MOps/s\nmaster accept: 378 MOps/s\nthis accept: 477 MOps/s\n\n(i7 4770K, JDK 1.8u5 x64)", "NaN"], ["1185", "Behavior subject time gap fix 2", "David Karnok", "akarnokd", "05/20/14, 05:11:18 AM", "Based on discussions in #1181, I've unified the behavior among the Subjects.\n\nBehaviorSubject doesn't seem to exhibit issue #658 and #1184.\n\nA second pair of eyes would be great to confirm the correctness and check if the removal of the CountDownLatch was the correct approach.", "NaN"], ["1188", "Fix issue #1187 and #1196", "Shixiong Zhu", "zsxwing", "05/16/14, 04:00:58 AM", "This PR fixed issue #1187.\n\nAlthough using `(action: => Unit)` will require the following odd codes when somebody wants to use `Function0` directly:\n\n``` Scala\n  @Test def schedulerExample5(): Unit = {\n    val worker = IOScheduler().createWorker\n    var no = 1\n    val subscription = worker.schedule(new Function0[Unit]{\n      def apply(): Unit = {\n        println(s\"Hello(${no}) from Scheduler\")\n        no += 1\n        worker.schedule(apply(), 100 millis)\n      }\n    }.apply(), 1 seconds)\n    TimeUnit.SECONDS.sleep(2)\n    subscription.unsubscribe()\n  }\n```\n\nI think people rarely use `Function0` directly in Scala. \n\nSo I chose `(action: => Unit)` finally. `schedulerExample4` is an more realistic example for recursive schedule.\n\nThis PR is a breaking change.", "NaN"], ["1190", "Scheduler fixes and related improvements", "David Karnok", "akarnokd", "05/20/14, 11:26:13 AM", "A newer set of scheduler improvements.\n- Fixed `schedulePeriodic` to properly capture the Subscription of the repeated schedule calls to allow unsubscribing the periodic task without the need to unsubscribe the whole worker.\n- Fixed `NewThreadScheduler` to call `shutdownNow` to correctly cancel all pending tasks.\n- Removed `innerSubscription` from `NewThreadScheduler` because it was unnecessary and didn't even work.\n- Took `CompositeSubscription` from #1145 to improve on the add/removal time of timed tasks with a help of a `HashSet` and atomic field updaters.\n- Added `SubscriptionQueue` that works like an ringbuffer and can add/remove non-delayed tasks faster than `CompositeSubscription`.\n- Reduced memory footprint of `CompositeSubscription` and `ScheduledAction`.\n- Modified `EventLoopScheduler` to track delayed and non-delayed task Subscriptions separately.\n- Added a few `final` modifiers.", "NaN"], ["1191", "Fix attempt for OperatorPivotTest", "David Karnok", "akarnokd", "05/16/14, 04:15:36 AM", "This is an attempt to fix the lack of concurrency in the `OperatorPivotTest.testConcurrencyAndSerialization`. Since this fails mostly on the build server, I'll try to minimize the attempts to not flood it.", "NaN"], ["1192", "ReplaySubject with time and size bounds", "David Karnok", "akarnokd", "05/19/14, 06:22:18 AM", "I've implemented the bounded `ReplaySubject` variants and removed the old `OperatorReplay.CustomReplaySubject` so the various `Observable.replay()` now use this version.\nNote that this is based on the current `SubjectSubscriptionManager` and not my manager from PR #1185. I've copied the `ReplaySubjectConcurrencyTest` to check the concurrency properties.\n\nThe bounded buffering is implemented via a doubly-linked list where the back reference is a weak reference. This allows keeping a reference to the latest `Node` for each replayState and once a Node is no longer indexed, it will be removed by GC. \n\nA concurrency review would be much appreciated.", "NaN"], ["1195", "SwingScheduler: allow negative schedule", "David Karnok", "akarnokd", "05/16/14, 04:18:31 AM", "Fix for issue #1193 \n\nThe new `schedulePeriodic` may calculate negative delay times if the next task was already due. This change will allow negative timing on the swing scheduler indicating an immediate schedule.", "NaN"], ["1197", "initial rev of two experimental event loop schedulers", null, "spodila", "07/08/14, 08:06:52 PM", "I created two new variations of EventLoopsScheduler - BalancingEventLoopScheduler and ReroutingEventLoopScheduler. These are currently experimental since they are not fully implemented for performance, but are fully functional. There are a couple of known problems and still evolving solutions. However, the ideas are concrete enough to garner discussion and feedback. The objective of rebalancing workload when there is non-trivial disparity in loads across cores is constrained by costs to both maintain state as well as to run rebalancing algorithms. Especially while maintaining the contracts of event concurrency, etc. and minimizing synchronization for gathering state and rebalancing.\nI also created a new JMH benchmark, MultipleObserversOnOneBusyObservable.java (pardon the naming), to help compare these two new variants with the existing scheduler.\n\nHere's a description of the benchmark and the two new schedulers.\n\nJMH Benchmark MultipleObserversOnOneBusyObservable.java\n\n<pre>\nsetup Input\n    theArray = Array of N numbers\n    Array of schedulers (schedlrIndex)\n        0: EventLoopsScheduler\n        1: BalancingEventLoopScheduler\n        2: ReroutingEventLoopScheduler\n    numObservers = NUM_CORES * 10\n    @GenerateMicroBenchmark\n    runAll(input)\n        for(i = 1 .. input.numObservers)\n        if(i%4 == 0)\n            theO = Observable.from(1,2,3,4,5)\n        else\n            theO = Observable.from(input.theArray)\n        theO.observeOn(input.scheduler[schedlrIndex]).subscribe(... input.blackhHole.consume(number)...)\n</pre>\n\n\nBenchmark run  on Ubuntu desktop: Intel Xeon W3550 @ 3.7 GHz, 8-Cores, 40GB memory.\n\n```\ngradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 10 -r 1 .*MultipleObserversOnOneBusyObservable.*'\n```\n\nResults:\n\n<pre>\nN=50\n\nBenchmark                                         (schedulerIndex)   Mode   Samples         Mean   Mean error    Units\nr.s.MultipleObserversOnOneBusyObservable.runAll                  0  thrpt        10     3460.543       50.047   ops/s\nr.s.MultipleObserversOnOneBusyObservable.runAll                  1  thrpt        10      430.402        1.783    ops/s\nr.s.MultipleObserversOnOneBusyObservable.runAll                  2  thrpt        10     3200.517      140.199   ops/s\n\n\nN=500\n\nBenchmark                                         (schedulerIndex)   Mode   Samples         Mean   Mean error    Units\nr.s.MultipleObserversOnOneBusyObservable.runAll                  0  thrpt        10      345.918        8.889   ops/s\nr.s.MultipleObserversOnOneBusyObservable.runAll                  1  thrpt        10      366.105       11.945    ops/s\nr.s.MultipleObserversOnOneBusyObservable.runAll                  2  thrpt        10      361.587       10.627   ops/s\n\n\nN=5000\n\nBenchmark                                         (schedulerIndex)   Mode   Samples         Mean   Mean error    Units\nr.s.MultipleObserversOnOneBusyObservable.runAll                  0  thrpt        10       36.383        1.698    ops/s\nr.s.MultipleObserversOnOneBusyObservable.runAll                  1  thrpt        10       88.317        4.917    ops/s\nr.s.MultipleObserversOnOneBusyObservable.runAll                  2  thrpt        10       37.533        0.951   ops/s\n</pre>\n\n\nNote that the workload in this benchmark isn't such that there's a much rebalancing, if any, to do. However, we need to make sure that the variants do not degrade performance in that case. \n\nSome observations:\n\n<ul>\n  <li>BalancingEventLoopScheduler does poorly for small N, but does pretty well beyond a threshold.</li>\n  <li>RebalancingEventLoopScheduler\n    <ul>\n        <li>added logic to evaluate and maintain state (1. avgLatency per core, 2. hot queue per core) and still is able to do as good as the old EventLoopsScheduler. That is, there's near zero cost to maintaining that state.</li>\n<li>Even if rebalancing proves costly and we evolve an algorithm later, the result so far itself might be a good improvement over the current one if we just \"pause\" the hot Q and randomly pick another core. </li>\n    </ul></li>\n</ul>\n\n\nBelow, I point out the problem area for each of the new schedulers. Ideas/feedback welcome.\n\n<h2>BalancingEventLoopScheduler</h2>\n\n<pre>\nN worker threads are created, 1 per core\nEach of N worker threads are assigned 0 or more worker queues to process\nOne of the worker threads is assigned as the RebalancerThread for load balancing\nScheduler.createWorker()  creates a queue and assigns to one of the worker threads\nWorkerThread.run():\n    act on Q transfers (transferring queue in, or out)\n    grab updated list of Qs\n    totalLoad=0\n    for(Q q: theQlist)\n        q.drainTo(workList)\n        now = currentTime\n        for(Action a: workList)\n        a.call()\n        load = currentTime - now\n        totalLoad += load\n        maintain hotQueue: name and load; that has the highest load\n    update current worker thread's hot queue \n    if I am the RebalancerThread, call rebalanceQs()\n    if(totalLoad == 0)\n        did no work, sleep a bit to prevent busy cpu   **PROBLEM**\n        would be nice to have a multi-queue poll() here to be called on all our Qs\n        this sleep kills performance when work comes in relatively slowly\nrebalanceQs()\n    if did rebalance recently, return\n    get HotQueues from each core thread workers\n    if none of them had a hot q, return\n    sort in increasing order, hot Qs based on core thread worker's totalLoad and the qLoad\n    for loadedWorker: from end of sorted hot Q list\n        for availableWorker: from beginning of sorted hotQ list until loadedWorker\n            if(shouldRebalancePair(loadedWorker, availableWorker), then\n                move the hotQ from loadedWorker to availableWorker\n                That is, WorkerThread[loadedWorker].transferQueue(theHotQ, WorkerThread[availableWorker])\nshouldRebalancePair(loadedWorker, availableWorker)\n    if( (loadedWorker.totalLoad - loadedWorker.hotQLoad) >= (availableWorker.totalLoad + loadedWorker.hotQLoad) )\n        return true\n    return false\n</pre>\n\n\n<h2>ReroutingEventLoopsScheduler</h2>\n\n<pre>\nN worker threads are created, 1 per core\nEach of N worker threads has a single thread executor (ScheduledThreadPoolExecutor)\nScheduler.createWorker() creates a WorkerQueue and assigns to one of the worker threads (could possibly make it pick the least loaded one; that info is available based on the details below)\nWorkerQueue.schedule() calls workerThread.schedule() on the currently assigned workerThread\nWorkerThread routinely schedules a house keeping action, latencyEval,  into its schedulerService to note time it takes for it to get executed (this measures latency)\nWorkerThread.schedule(callerQId, action)\n    wrap each runnable with \n        increment counter to track #items\n        increment per queue counter to track per queueId throughput (queueCounts)\n    executor.schedule(wrapped runnable)\nWorkerThread essentially maintains two numbers: avgLatency and throughput (overall + perWorker)\nWorkerThread.latencyEval\n    note latency (currentTime - latencyEvalLaunchTime)\n    if(queueCounts.size > 1)\n        maxQ = queue from queueCounts with max number, where number > EPS (threshold)\n        destination = shouldReroute(myWorkerIndex)\n        if(desination >= 0)\n            WorkerQueue[maxQ].rerouteTo(destination)\nshouldReroute(sourceWorker)\n    ensure nobody else is rerouting right now or just did\n    get avgLatencies for all workers (as many as #Cores)\n    pick a worker with that can take sourceWorker's load based on latencies (currently always return -1, effectively actual load balancing is turned off)\n    return picked worker \nWorkerQueue.schedule(action)\n    if am being rerouted\n        initialize reroute\n            put an ending marker action into current worker that notifies us of the last action handled\n            we can use the new worker only after the last one sent to previous one completes\n        if (ending marker indicated)\n            switch worker to the new one\n            move all actions in transfer queue to new worker\n        else\n            park action into a transfer queue\n            Don't yet know how to manage subscriptions when parking actions  **PROBLEM**\n            It is functional though since actual rebalancing isn't happening.\n            Perhaps, don't park actions, just pause until ending marker comes through. Subscriptions are managed just like before then. The caller is then blocked until rebalancing finishes. Which make be OK?\n    else\n        worker.schedule(action)\n</pre>", "NaN"], ["1198", "Support for IOSSchedulers", "Ashley", "ashleyj", "06/06/14, 04:43:11 AM", "IOSScheduler implementation for iOS, for use with RoboVM", "NaN"], ["1200", "Scheduler dispatch algorithm and tests", "David Karnok", "akarnokd", "05/31/14, 08:51:04 AM", "Implemented an event loop scheduler based on thread pinning and work stealing for #1149. In addition, I've merged #1197, added tests and fixed a few minor issues.\n\nHere are the comparative benchmark results using the `MultipleObserversOnOneBusyObservable`JMH from #1197 \n\n```\nBenchmark (NUM_INTEGERS) (schedulerIndex)   Mode   Samples         Mean   Mean error    Units\nrunAll                50                0  thrpt        10     3012,015      176,800    ops/s\nrunAll                50                1  thrpt        10       32,035        0,014    ops/s\nrunAll                50                2  thrpt        10     2537,292      201,377    ops/s\nrunAll                50                3  thrpt        10     2452,117       60,938    ops/s\nrunAll               500                0  thrpt        10      296,673        4,419    ops/s\nrunAll               500                1  thrpt        10       32,037        0,011    ops/s\nrunAll               500                2  thrpt        10      211,382       21,754    ops/s\nrunAll               500                3  thrpt        10      246,312        3,714    ops/s\nrunAll              5000                0  thrpt        10       27,458        0,083    ops/s\nrunAll              5000                1  thrpt        10       32,070        0,238    ops/s\nrunAll              5000                2  thrpt        10       27,718        0,343    ops/s\nrunAll              5000                3  thrpt        10       21,415        0,289    ops/s\n```\n\nwhere 0 is the current computation scheduler, 1 is the balanced scheduler, 2 is the rerouting scheduler and 3 is the pinning scheduler. The reason for the 32 ops/s throughput of the balanced scheduler seems to be due to the drain loop, which made some self-scheduling tests run extremely slow. Adding the `MAX_TIGHT_LOOPS` improved on the test speed and the benchmark speed to 255 ops/s. I'm not sure why it is that slow.\n\nI haven't run the other perf test, but run my own simple benchmark code: one that observes a single item 1M times and the other observes 16M items once. Results:\n\n```\nAlgorithm    Single          Many\nCurrent      1970 ns/item    117 ns/item\nBalancing    30403 ns/item   110 ns/item\nRerouting    1979 ns/item    115 ns/item\nPinning      2122 ns/item    140 ns/item\n```\n\nThe reason for the extra slowness of my implementation is the use of `LinkedBlockingDeque` as I need the `offerFirst`, but `ConcurrentLinkedDeque` is in Java 7. In addition, the cost of waiting and parking is doubled.", "NaN"], ["1203", "AndroidObservable to hold weak reference to Activity or Fragment", "David R. Bild", "drbild", "07/08/14, 08:02:37 PM", "bindActivity() and bindFragment() hold strong references to the\nActivity or Fragment, thus requiring explicit unsubscription to avoid\nleaks. This commit weakens that reference.\n\nThe observable chain should never be the owner of an Activity or\nFragment, so weakening the reference here should be safe.  An earlier\nversion of bindActivity() used weak references for both the Activity\nand the source Observable. Weakening the reference to the Observable may\nbe unsafe, as the observable chain might be the owner of an anonymous\nsource Observable.\n\nThis commit removes the need to explicitly unsubscribe, as long as the\nfinal Subscriber holds only a weak reference to the Context (i.e.,\nView, Activity, or Fragment).\n\nFor example, consider a class:\n\n```\n  public class ClickableProperty extends Subscriber<Boolean> {\n\n    private final WeakReference<View> mViewRef;\n\n    public ClickableProperty(View view) {\n      mViewRef = new WeakReference<View>(view);\n    }\n\n    @Override\n    public void onNext(Boolean clickable) {\n      View view = mViewRef.get();\n      if (view != null) {\n        view.setClickable(clickable);\n      } else {\n        unsubscribe();\n      }\n    }\n\n    @Override\n    public void onCompleted() {\n      // ignore\n    }\n\n    @Override\n    public void onError(Throwable e) {\n      // ignore\n    }\n\n  }\n```\n\nThe clickable property of a view can be safely bound to a boolean\nobservable as follows, without needing to explicitly unsubscribe in the\nActivity's onDestroy().\n\n```\n  public class MainActivity extends Activity {\n\n    Button mButton;\n\n    protected void onCreate(Bundle savedInstanceState) {\n      setContextView(R.id.activity_main);\n      mButton = findViewById(R.id.button);\n\n      Observable<Boolean> allowClicks = GlobalStaticObservables.allowClicks();\n      ClickableProperty clickableProperty = new ClickableProperty(mButton);\n      bindActivity(this, allowClicks).subscribe(clickableProperty);\n    }\n\n    protected void onDestroy() {\n      // nothing to do here\n    }\n\n  }\n```\n\nWithout weakening the Activity reference in bindActivity(), explicit\nunsubscription would still be needed to prevent Context leaks.", "NaN"], ["1208", "OperatorToObservableList: use LinkedList to buffer the sequence\u2019s items", "Matthias K\u00e4ppler", "mttkay", "05/20/14, 04:10:39 AM", "LinkedList has guaranteed constant insertion time when appending to the end of the list, whereas ArrayList takes O(1) amortized, since a reallocation might be necessary to insert further items. Since no capacity was specified for the buffer, on Hotspot this would cause the array to reallocate after the first 10 insertions, on Android even after the first insertion (since Android\u2019s ArrayList uses a default capacity of zero.)\n\nSince the buffer is copied to an ArrayList before emission, subscriber performance when working with the list should remain unaffected.\n\nSorry for the import noise, that's IntelliJ reformatting them every time I look at the file.\n\nRefs #1141", "NaN"], ["1210", "Add more operators to RxScala", "Shixiong Zhu", "zsxwing", "05/20/14, 04:07:31 AM", "Conflicts against #1178, too. I will rebase once #1178 is merged to master.\n\n/cc @samuelgruetter", "NaN"], ["1211", "Time and/or size bounded ReplaySubject extensions", "David Karnok", "akarnokd", "05/20/14, 08:38:54 AM", "ReplaySubject with time and/or size bounds.\n\nI've implemented this so that there is no need for a separate BoundedReplaySubject or CustomReplaySubject.\n\n(The previous PR was messed up a bit after the merge with main.)", "NaN"], ["1216", "Exposing PublishSubject", "Haney Maxwell", "hmrm", "05/20/14, 04:08:18 AM", "All other subjects (Async, Behavior, Replay) have non-private companion objects.", "NaN"], ["1223", "ReplaySubject enhancement with time and/or size bounds", "David Karnok", "akarnokd", "05/20/14, 04:25:09 PM", "Reapplied the enhancements to bring size and/or time bound `ReplaySubject` capabilities while exposing a single subject class (i.e., no separate BoundedReplaySubject or CustomReplaySubject). It now uses the renewed `SubjectSubscriptionManager`.\n\nIn addition, I've moved a confusing behavior from SubjectObserver into AsyncSubject where it belongs.", "NaN"], ["1224", "Implement shorter toBlocking as shorter alias for toBlockingObservable.", "Michael Nitschinger", "daschl", "05/20/14, 04:22:03 PM", "Fixes #1220", "NaN"], ["1226", "Fix bug in `zipWithIndex` and set `zip(that, selector)` public in RxScala", "Shixiong Zhu", "zsxwing", "05/20/14, 04:09:11 PM", "- The function used in `zipWithIndex` is mutable, which make the Observable cannot be reused. Fixed it using `zip((0 until Int.MaxValue).toObservable)`.\n- Make `zip(that, selector)` public and rename to `zipWith`. #1189\n\n/cc @headinthebox, @samuelgruetter  ", "NaN"], ["1228", "Git Reformats This File", "Ben Christensen", "benjchristensen", "05/20/14, 05:25:55 PM", "NaN", "NaN"], ["1229", "Remove Ambiguous Subscribe Overloads with Scheduler", "Ben Christensen", "benjchristensen", "05/20/14, 05:47:35 PM", "- Fixes https://github.com/Netflix/RxJava/issues/1116\n- These should never have been added, the subscribeOn operator already provides this functionality", "NaN"], ["1231", "Operator Alias: Share", "Ben Christensen", "benjchristensen", "05/20/14, 05:54:13 PM", "As per discussion in #682", "NaN"], ["1232", "Adopt Limit and ForEach Java 8 Naming Conventions", "Ben Christensen", "benjchristensen", "05/20/14, 06:08:52 PM", "As per discussion at https://github.com/Netflix/RxJava/issues/678\n\nCode now can look like this:\n\n``` java\nObservable.from(1, 2, 3).limit(2).forEach(System.out::println);\n```\n\nas an alias to this:\n\n``` java\nObservable.from(1, 2, 3).take(2).subscribe(System.out::println);\n```", "NaN"], ["1233", "Deprecate toBlockingObservable in favor of toBlocking", "Ben Christensen", "benjchristensen", "05/20/14, 06:13:15 PM", "As per discussion at https://github.com/Netflix/RxJava/pull/1224#issuecomment-43658284\n\nThis will better match `toParallel` and is shorter to use while still being clear as to what is happening.", "NaN"], ["1235", "Lock-free, MPSC-queue based, fast-path serializing Observer.", "David Karnok", "akarnokd", "05/29/14, 10:53:31 PM", "I've rewritten the `SerializedObserver` to improve performance. It is now lock-free, uses a multiple-producer-single-consumer queue based on Netty's implementation and employs a fast-path logic for single-threaded write-through.\n\nBenchmarked by measuring how fast 500k integers can get through it, if running 1-8 producers at the same time. For a single threaded case, master gives about 18 MOps/s, this implementation gives ~36 MOps/s (would be ~16 MOps/s on the slow path). For producers > 2, master gives ~5.5 MOps/s and this gives ~11.5 MOps/s. For 2 producers, aka 1 producer - 1 consumer, master gives ~4.5 MOps and this gives ~8.5 MOps/s.\n\nThe two new class, `PaddedAtomicInteger` and `MpscPaddedQueue` will come in handy with other lock-free structures such as Schedulers, etc. We may consider adding back the `rx.util` or some other sub-package to store these helper classes: they don't need to be part of the public API but can be left `public` to enable cross-package access internally.\n\nThings I learned during the implementation:\n- It is worth padding the wip counter to fit a cache line so the constant cache thrashing won't affect the parent class' other fields, most likely.\n- Using FieldUpdaters saves space but `sun.misc.Unsafe` can add 8-10% more throughput. To avoid platform issues, I stayed with the FieldUpdaters.\n- Using `getAndIncrement` and `decrementAndGet` are intrinsified in Java 8 and are compiled to a single x86 instruction, which generally outperforms any CAS loop. Same is true for the `getAndSet`.\n- Padding out the `tail` in the `MpscPaddedQueue` again helps separate producers trashing on the tail and a consumer reading the head. Without it, the throughput would decrease by about ~1.5 MOps/s\n- By adding the fast-path logic, the single-threaded throughput increases by a factor of 2 since it avoids an unnecessary enqueue and dequeue and all associated volatile writes. However, if taking the fast-path fails, it incurs extra cost on the slow path for everyone else because of the +1 failed CAS at the start. To fix this case, I've introduced a flag that enables and disables fast-path. To disable the fast path, the active fast path checks if it was able to change wip to zero. If not, it means there was concurrent access and continues on the emission loop path, but disables the fast-path then on. It is basically a detector for concurrent use. Since such concurrent use may be transient, the loop counts how many elements it had to emit, an if it was only 1 or 2, it reenables the fast-path. This limit is the result of trying several values with the benchmark above.\n- The fast-path logic has its weak spot in 2 producer case compared to a plain MPSC queue running in SPSC mode; the latter gives about ~11 MOps/s which is better than this implementation's ~8.5 MOps/s. In contrast, the single-treaded use for the plain MPSC is only ~16 MOps/s. Both implementations perform the same if producers > 2. Therefore, I decided it is more worth having an implementation that is weak for 2 producers but otherwise is as good or outperforms the alternatives. Note that if one knows the number of producers up front, one can create a more specialized implementation, but this is not the case with RxJava operators. This may affect `merge` and co which serialize multiple sources. Note however, that if the source speed isn't that high as in the benchmark, this implementation still provide less latency than the alternatives because the fast-path would be most likely open if the source emission is interleaved.", "NaN"], ["1236", "CompositeSubscription with atomic field updater", "David Karnok", "akarnokd", "05/21/14, 04:47:43 PM", "This PR is aimed at #1204 to reduce unnecessary memory overhead in frequently used classes. This change in `CompositeSubscription` saves about 24 bytes per instance.\n\nIn addition, the field updaters may be faster by about 8-15% for small adds and removals. I've changed the implementation of unsubscribe to use getAndSet which leverages platform intrinsics and is usually compiled to a single instruction: this makes unsubscribing a tiny bit faster and thus reducing latency in benchmarks that only pass on single element around.", "NaN"], ["1237", "SafeSubscriber memory reduction", "David Karnok", "akarnokd", "05/21/14, 04:43:39 PM", "For #1204. This saves 24 bytes per instance. ", "NaN"], ["1239", "Update docs for \"apply\" and add an example", "Shixiong Zhu", "zsxwing", "05/23/14, 04:09:44 AM", "Try to solve #1076. @vchekan, any suggestion?\n\n/cc @headinthebox, @samuelgruetter", "NaN"], ["1240", "Observable from Func0<Enumeration>", "George Campbell", "abersnaze", "07/08/14, 08:02:02 PM", "dealing with `HttpServletRequest` API that returns `Enumeration`s and want to get out of there as fast a possible.  The `Func0` emulates the `Iterable` interface so subsequent subscribes get a fresh `Enumeration`.", "NaN"], ["1242", "Android HandlerThreadScheduler fix (closes #1241)", "Vince Mi", "vinc3m1", "05/23/14, 09:29:23 AM", "Some events are not delivered due to race condition around the check to `innerSubscription.isUnsubscribed()` in the posted runnable. It's currently possible for the Handler thread to be delayed enough that innerSubscription becomes unsubscribed, and causing the action not to run.\n\nAfter cross-checking the code with `NewThreadScheduler`, it seems that the expected behavior is to continue to run the action even if the inner/parent subscription is unsubscribed, and only stop when the outer subscription is unsubscribed (which is already happening with `handler.removeCallbacks(runnable)`).\n\nThis fixes #1241.", "NaN"], ["1243", "Remove Subscription Wrapper from Observable.subscribe", "Ben Christensen", "benjchristensen", "05/22/14, 04:25:43 AM", "Remove Subscription Wrapper from Observable.subscribe\n\nPerformance increase from 7.7m to 8.8m ops/second\n\nBefore:\n\n```\nBenchmark (size) Mode Samples Mean Mean error Units\nr.u.PerfTransforms.mapTransformation 1 thrpt 5 7714453.187 362218.633 ops/s\nr.u.PerfTransforms.mapTransformation 1 thrpt 5 7527144.767 497816.471 ops/s\n```\n\nAfter:\n\n```\nBenchmark (size) Mode Samples Mean Mean error Units\nr.u.PerfTransforms.mapTransformation 1 thrpt 5 8853534.333 183494.242 ops/s\nr.u.PerfTransforms.mapTransformation 1 thrpt 5 8806958.403 452595.219 ops/s\n```\n\nTest can be run  using:\n\n```\n../gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 5 -prof GC .*PerfTransforms.mapTransformation*'\n```", "NaN"], ["1244", "Observable.from(T) using Observable.just(T)", "Ben Christensen", "benjchristensen", "05/22/14, 04:38:27 AM", "For code like `Observable.from(1)` Improve performance from ~3.9m to 4.5+m ops/second\n\nBefore;\n\n```\nr.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  3923845.687    46657.660    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     8924.953     1983.161    ops/s\n\nr.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  3623228.857   490894.492    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     9176.330      923.929    ops/s\n```\n\nAfter:\n\n```\nBenchmark                                       (size)   Mode   Samples         Mean   Mean error    Units\nr.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  4052364.587   100971.234    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5    11682.783      496.656    ops/s\n\nBenchmark                                       (size)   Mode   Samples         Mean   Mean error    Units\nr.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  4700583.987    77742.037    ops/s\nr.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5    12588.803       58.935    ops/s\n```\n\nUsing this test:\n\n```\n../gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 5 -prof GC .*PerfTransforms.flatMapTransformsUsingFrom*'\n```", "NaN"], ["1246", "Moved to atomic field updaters.", "David Karnok", "akarnokd", "05/27/14, 02:18:03 AM", "Replaced the AtomicBoolean, AtomicInteger, AtomicLong and AtomicReference instances with volatile fields and field updaters to save on memory and allocation.\n\nUnfortunately, the Clojure test `chunk_test.clj:test-chunk` fails and I don't know why since I don't understand what it is supposed to do. It appears numbers get lost somehow.", "NaN"], ["1247", "Add zip(iterable, selector) to RxScala", "Shixiong Zhu", "zsxwing", "05/27/14, 04:38:08 AM", "- Add `zip(iterable, selector)` to RxScala\n- Use `zip(iterable, selector)` to reimplement `zipWithIndex` to resolve the issue mentioned in #1226\n\n/cc @samuelgruetter", "NaN"], ["1248", "Fixed testConcurrentOnNextFailsValidation", "David Karnok", "akarnokd", "05/23/14, 04:21:09 AM", "The two instructions need to be swapped to make sure woken-up awaiters see the error reliably.", "NaN"], ["1254", "ZipIterable unsubscription fix", "David Karnok", "akarnokd", "05/27/14, 02:45:07 AM", "For issue #1253.", "NaN"], ["1260", "Fix the bug that BlockingObservable.singleOrDefault doesn't call unsubscribe", "Shixiong Zhu", "zsxwing", "05/27/14, 04:40:11 AM", "`BlockingObservable.singleOrDefault` doesn't call `unsubscribe` when throws `IllegalArgumentException(\"Sequence contains too many elements\")`. `testSingleOrDefaultUnsubscribe` proves this bug. ", "NaN"], ["1261", "Merge with Netflix", "Vanadium", "jloisel", "05/25/14, 11:45:56 AM", "NaN", "NaN"], ["1262", "Merge from Netflix", "Vanadium", "jloisel", "05/25/14, 11:49:47 AM", "NaN", "NaN"], ["1263", "Merge from Netflix", "Vanadium", "jloisel", "05/25/14, 11:50:56 AM", "NaN", "NaN"], ["1264", "ObserveOn scheduled unsubscription", "David Karnok", "akarnokd", "05/28/14, 08:36:27 PM", "Proposed fix for #1241.\n\nSome operators eagerly unsubscribe the chain in case of an error, however, this may prevent the delivery of the onError if it is run through the `observeOn` operator as the worker gets unsubscribed and may or may not reach the point where it emits the onError in the other thread. This change will schedule the unsubscription along with the event delivery and thus ensure that all events sent to observeOn prior to unsubscription will be delivered in the new thread.\n\nNote that this change makes the unsubscription delayed and if event processing is slow in the new thread, it may take a while to happen; the original version just dropped any unprocessed work and thus was faster to terminate.", "NaN"], ["1265", "Add more operators to RxScala", "Shixiong Zhu", "zsxwing", "05/29/14, 01:00:44 AM", "The commits explain this PR.\n\nIn addition, the reason that I changed `window(closings: () => Observable[Any])` to `window(boundary: => Observable[Any])` is `window(boundary: => Observable[Any])` can support both two overloads `window(Observable[U])` and `window(Func0[_ <: Observable[_ <: TClosing]])` in RxJava. ", "NaN"], ["1267", "Fix to future cancellation", "Matt Jacobs", "mattrjacobs", "05/30/14, 06:56:02 PM", "Right now, Observable.from(Future f) emits onError(CancellationException) when f starts out in a cancelled state.  This change makes Observable.from(f) emit nothing at all.", "NaN"], ["1268", "Cursor observable for Android", "Matvey Malkov", "lnevermore", "05/28/14, 10:07:22 AM", "Change version of scala to newest 2.11 for properly work and gradle execution\nAdd CursorObservable for observing android cursor changes", "NaN"], ["1269", "Fix the bug that int overflow can bypass the range check", "Shixiong Zhu", "zsxwing", "05/28/14, 07:28:35 PM", "Fix the bug mentioned in #1266", "NaN"], ["1271", "Operator Retry with predicate", "David Karnok", "akarnokd", "05/28/14, 09:47:30 PM", "Operator Retry with predicate + 1 overload for Issue #1214.\n\nThe Func1 version is simply named `retry`, the Func2 version is named `retryIf` due to lack of ideas and because to avoid overload resolution issues. I also had to open up the OperatorRetryTest classes a bit.", "NaN"], ["1272", "ExecutorScheduler to wrap an Executor", "David Karnok", "akarnokd", "05/28/14, 07:33:56 PM", "For issue #1219 (and #1206)\n\nThis implementation should conform with the Scheduler contract except it is not possible to avoid thread-hopping (don't worry, the tasks execute serially, but maybe not on the same physical thread).\n\nFew open improvement possibilities:\n- Usage of `MpscLinkedQueue` once available.\n- A better performing subscription container for this kind of queue-drain task tracking instead of `CompositeSubscription`.\n- Ability to remove a `Subscription` from a `CompositeSubscription` without it calling unsubscribe on the removed Subscription, \u00e1 la `MultipleAssignmentSubscription.set()`.", "NaN"], ["1275", "Fix Encoding/Formatting", "Ben Christensen", "benjchristensen", "05/28/14, 07:57:50 PM", "The encoding on these files is not liked by Git and it is forcing them to be updated.\n\n/cc @akarnokd As you may want to look at your setup ... this happens somewhat often on commits from you.\n\nI believe it is related to these `.gitattribute` settings:\n\n```\n# Set default behaviour, in case users don't have core.autocrlf set.\n* text=auto\n\n# Explicitly declare text files we want to always be normalized and converted \n# to native line endings on checkout.\n*.java text\n*.groovy text\n*.scala text\n*.clj text\n*.txt text\n*.md text\n\n# Denote all files that are truly binary and should not be modified.\n*.png binary\n*.jpg binary\n```", "NaN"], ["1276", "Re-submission of CachedThreadScheduler", "Joakim Bodin", "jbripley", "05/30/14, 04:27:39 PM", "Merged in the latest from the master branch and refactored some internals in CachedThreadScheduler to better match the latest `Scheduler` changes. Aimed at solving #1140", "NaN"], ["1281", "Reduce Subscription Object Allocation", "Ben Christensen", "benjchristensen", "05/29/14, 10:21:47 PM", "### Changes\n- rewrite of `CompositeSubscription` and added `ChainedSubscription`\n- significant reduction in object allocations\n- details on research available at https://github.com/Netflix/RxJava/issues/1204\n##### Atomic State Machine -> Mutation & Locks\n\nThe `CompositeSubscription` implementation was changed from using an atomic state machine to using locks. The state machine requires immutable `State` that is swapped using CAS. This means an object allocation is needed each time.\n\nIt now uses locks to protect mutable state so very few objects are created.\n##### ChainedSubscription\n\nThe `CompositeSubscription` requires support of randomly removing a `Subscription` via the `remove` method. The `Subscriber` type does not expose this so can be optimized. There is now a `ChainedSubscription` that is used by `Subscriber` instead. This allows using a `LinkedList` or `ArrayList` rather than `HashSet` as random access is never needed. This provides a slight performance boost and reduces memory usage (1 minute test shows 16.5GB allocation for `Composite` versus 14.4GC for `Chained`).\n### Allocation Comparison\n\nThis shows Java Flight Recorder output from master without these changes:\n\n![master-without-changing-compositesubscription](https://cloud.githubusercontent.com/assets/813492/3122035/66ea4e22-e762-11e3-8915-5aead429e120.png)\n\nThis shows object allocation after changing `CompositeSubscription`:\n\n![master-with-new-compositesubscription ong](https://cloud.githubusercontent.com/assets/813492/3122195/9f3641bc-e764-11e3-930f-845efc99b84a.png)\n### Throughput Comparison\n\nTesting this code:\n\n``` java\n    public void mapTransformation(UseCaseInput input) throws InterruptedException {\n        input.observable.map(i -> {\n            return String.valueOf(i);\n\n        }).map(i -> {\n            return Integer.parseInt(i);\n        }).subscribe(input.observer);\n        input.awaitCompletion();\n    }\n```\n##### Rx 0.16.1\n\n```\nRun: 10 - 2,879,355 ops/sec \nRun: 11 - 3,236,245 ops/sec \nRun: 12 - 4,468,275 ops/sec \nRun: 13 - 3,237,293 ops/sec \nRun: 14 - 4,683,840 ops/sec \n```\n##### Rx 0.17.6 - using OnSubscribeFunc\n\n```\nRun: 10 - 3,621,876 ops/sec \nRun: 11 - 6,702,412 ops/sec \nRun: 12 - 7,401,924 ops/sec \nRun: 13 - 6,653,359 ops/sec \nRun: 14 - 5,834,305 ops/sec \n```\n##### Rx 0.17.6 - using OnSubscribe\n\n```\nRun: 10 - 3,320,053 ops/sec \nRun: 11 - 4,520,795 ops/sec \nRun: 12 - 7,107,320 ops/sec \nRun: 13 - 5,089,058 ops/sec \nRun: 14 - 5,534,034 ops/sec \n\nRun: 10 - 4,930,966 ops/sec \nRun: 11 - 6,119,951 ops/sec \nRun: 12 - 7,062,146 ops/sec \nRun: 13 - 6,514,657 ops/sec \nRun: 14 - 6,369,426 ops/sec \n```\n##### Rx 0.18.3 - using OnSubscribe\n\n```\nRun: 10 - 4,178,854 ops/sec \nRun: 11 - 4,446,420 ops/sec \nRun: 12 - 5,458,515 ops/sec \nRun: 13 - 8,006,405 ops/sec \nRun: 14 - 7,849,293 ops/sec \n\nRun: 10 - 4,145,936 ops/sec \nRun: 11 - 6,553,079 ops/sec \nRun: 12 - 7,645,259 ops/sec \nRun: 13 - 7,385,524 ops/sec \nRun: 14 - 7,830,853 ops/sec \n```\n##### Rx 0.19 master - CompositeSubscription state machine\n\n```\nRun: 10 - 10,576,302 ops/sec \nRun: 11 - 10,518,786 ops/sec \nRun: 12 - 10,554,646 ops/sec \nRun: 13 - 10,314,063 ops/sec \nRun: 14 - 10,666,439 ops/sec \n```\n##### Rx 0.19 master - CompositeSubscription with synchronized HashSet\n\n```\nRun: 10 - 9,949,060 ops/sec \nRun: 11 - 10,122,379 ops/sec \nRun: 12 - 10,018,032 ops/sec \nRun: 13 - 10,072,522 ops/sec \nRun: 14 - 10,132,636 ops/sec \n```\n##### Rx 0.19 master - ChainedSubscription with synchronized ArrayList\n\n```\nRun: 10 - 11,086,351 ops/sec \nRun: 11 - 10,932,426 ops/sec \nRun: 12 - 11,002,431 ops/sec \nRun: 13 - 10,888,620 ops/sec \nRun: 14 - 11,157,227 ops/sec \n\nRun: 10 - 9,371,192 ops/sec \nRun: 11 - 9,829,169 ops/sec \nRun: 12 - 10,139,005 ops/sec \nRun: 13 - 10,099,785 ops/sec \nRun: 14 - 10,017,631 ops/sec \n```\n##### Rx 0.19 master - ChainedSubscription with synchronized LinkedList\n\n```\nRun: 10 - 10,619,431 ops/sec \nRun: 11 - 11,063,293 ops/sec \nRun: 12 - 11,001,463 ops/sec \nRun: 13 - 11,054,243 ops/sec \nRun: 14 - 10,898,826 ops/sec \n\nRun: 10 - 10,075,465 ops/sec \nRun: 11 - 9,780,716 ops/sec \nRun: 12 - 9,885,134 ops/sec \nRun: 13 - 9,584,143 ops/sec \nRun: 14 - 10,000,700 ops/sec \n```", "NaN"], ["1282", "utility function for creating observables for closeable resources", "George Campbell", "abersnaze", "07/08/14, 07:58:44 PM", "#1199 the answer to the issue was nagging at me when I tried to recommend it recently.  I think @zsxwing's solution was ok but would fail if there were repeated subscriptions to the observable returned.  I created a utility function on StringObservable to make it easier to use `using()` for objects that implement the `AutoCloseable` interface.\n\nPS. I made a breaking change to arguments of `join(Observable<Object>)` to `join(Observable<String>)` and added a `Observable<String> toString(Observable<Object>)` to make up for it.\n\nPPS. I made a `UnsafeFunc0<R>` scoped to this class but I would like to have `UnsafeFunc<N>` in the rx.functions packages and have `Func<N>` extends `UnsafeFunc<N>`.   Makes it clear to the compiler that we don't expect the code the user's are giving us to always work. This also helps the users because they don't have to always fill their closures with try catch blocks\n\n```\n() -> new FileReader(file)\n```\n\nvs.\n\n```\n() -> {\n    try {\n        return new FileReader(file);\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n```", "NaN"], ["1284", "Manual merge of Lock-free, MPSC-queue based", "Ben Christensen", "benjchristensen", "05/29/14, 10:53:31 PM", "Pulling in the MPSC queue from https://github.com/Netflix/RxJava/pull/1235. Leaving out the SerializedObserver change until further analysis. Getting this data structure in as we likely want to use it in other places.\n\nMoved it into rx.internal.util and added a README so it is very clear this is an internal package and not part of the public API.", "NaN"], ["1286", "Rename some Operator* classes to OnSubscribe* as per #1270", "Dave Moten", "davidmoten", "05/30/14, 04:08:39 PM", "See discussion in issue #1270. \n\nNumerous classes in the `rx.operator` package are not implementations of `Operator` but are actually implementations of `OnSubscribe`. The classes have been renamed in this pull request.\n\nExcuse me not squashing commits, looked complicated after doing a pull from upstream in the middle.", "NaN"], ["1287", "ReplaySubject remove replayState CHM and related SubjectObserver changes", "David Karnok", "akarnokd", "05/30/14, 04:40:10 PM", "For issue #1204\n\nThis change should help avoid CHM garbage (although boxed Integers will still fly around). In addition, I moved the NotificationLite around to make room for the index. I've also removed the callback onAdd in PublishSubject because it was unnecessary.", "NaN"], ["1288", "Ensure StringObservable.from() does not perform unnecessary read ", "Dave Moten", "davidmoten", "05/30/14, 04:07:43 PM", "An extra check is useful to check for unsubscription because as is even `StringObservable.from(InputStream).first()` performs two reads and the second read may block. \n\nAdded another check just before the `InputStream.read()` and simplified the initialization of `n`.", "NaN"], ["1289", "Schedulers.from(Executor)", "Ben Christensen", "benjchristensen", "05/30/14, 04:48:53 PM", "As per decision at https://github.com/Netflix/RxJava/issues/1219#issuecomment-44454729", "NaN"], ["1290", "Upgrade to JMH 0.7.3", "Ben Christensen", "benjchristensen", "05/30/14, 04:57:01 PM", "As per https://github.com/Netflix/RxJava/issues/1205", "NaN"], ["1291", "Check unsubscribe within observable from future", "Matt Jacobs", "mattrjacobs", "05/30/14, 06:55:48 PM", "Right now, Observable.from(Future f) emits onError(CancellationException) when f starts out in a cancelled state. This change makes Observable.from(f) emit nothing in this case, and also when an unsubscribe occurs during a Future.get() that results in an Exception.", "NaN"], ["1293", "Fix and Update JMH Perf Tests", "Ben Christensen", "benjchristensen", "05/30/14, 06:55:02 PM", "- The tests were wrong and re-using a single Subscriber instance which meant they weren't really testing much.\n- Same with the CountDownLatch which meant they weren't waiting if async.\n- Added several SerializePerf and PerfTransform tests", "NaN"], ["1294", "rx.operators -> rx.internal.operators", "Ben Christensen", "benjchristensen", "05/30/14, 07:05:14 PM", "Move `rx.operators` to `rx.internal.operators` for clarity that these can change at any time and are not part of the public API.\n\nDiscussed at https://github.com/Netflix/RxJava/issues/1270#issuecomment-44668606", "NaN"], ["1295", "Change `void accept` to `boolean accept`", "Ben Christensen", "benjchristensen", "05/30/14, 09:14:09 PM", "As per a change @akarnokd did elsewhere with `accept2` method.", "NaN"], ["1296", "Move re-used internal Scheduler classes to their own package", "Joakim Bodin", "jbripley", "05/30/14, 11:56:54 PM", "As discussed in #1294", "NaN"], ["1297", "[RxScala] rxjava-scalaz: providing some type class instances.", "Shingo Omura", "everpeace", "06/25/14, 05:11:37 PM", "Introduced 'rxjava-scalaz' project. This project provides some type class instances for Observable.\n- _Monoid_: <br/>Observable obviously forms a monoid in terms of concatenation.\n- _Functor, Applicative, Monad, MonadPlus_: <br/>Observable can be a Stream-like Monad and can be MonadPlus as well as Monoid.\n- _Traverse, Foldable_: <br/>Observable can be Stream-like traversable.  Please note that the operations for the instance is blocking calls.\n- etc.\n\nAbout testing, property based tests are applied by Scalaz's ScalaCheck binding.\nFor getting started, please refer to rx.java.scala.scalaz.examples.RxScalazDemo, or README.md.\n### Sample Usages\n\n``` scala\nimport scalaz._, Scalaz._\nimport rx.lang.scala.Observable\nimport rx.lang.scala.scalaz._\n\nObservable.items(1, 2) |+| Observable.items(3, 4)               // === Observable.items(1 2 3 4)\nObservable.items(1, 2) \u2218 {_ + 1}                                // === Observable.items(2, 3)\n(Observable.items(1, 2) |@| Observable.items(3, 4)) {_ + _}     // === Observable.items(4, 5, 5, 6)\n1.\u03b7[Observable]                                                 // === Observable.items(1)\n(Observable.items(3) >>= {(i: Int) => Observable.items(i + 1)}) // === Observable.items(4)\n```\n\n_My original proposal is #1167_", "NaN"], ["1298", "Remove Bad Perf Test", "Ben Christensen", "benjchristensen", "05/31/14, 05:23:14 AM", "- this just stresses scheduling and at this throughput creates massive garbage and tests the wrong thing", "NaN"], ["1300", "RxScala: Add convenience method for adding unsubscription callback", "Joakim Bodin", "jbripley", "05/31/14, 04:03:54 PM", "Implements enhancement detailed in #1258", "NaN"], ["1301", "RxScala: Add convenience method for adding unsubscription callback", "Joakim Bodin", "jbripley", "06/01/14, 03:04:10 PM", "Implements enhancement detailed in #1258. Now with less git screw ups.", "NaN"], ["1302", "improve variable names in OperatorGroupBy", "Dave Moten", "davidmoten", "06/02/14, 06:30:53 PM", "renamed `childObserver` to `child` as is now a `Subscriber`, `gps` to `group`,`_gps` to `_group` (gps implies multiple but is not).", "NaN"], ["1304", "Add flatMap and concatMap to RxScala", "Shixiong Zhu", "zsxwing", "06/02/14, 04:01:44 PM", "For #1251\n\n/cc @headinthebox, @samuelgruetter", "NaN"], ["1305", "Checked Exceptions", "George Campbell", "abersnaze", "07/08/14, 07:57:21 PM", "This pull request:\n- makes the Rx user's code cleaner.\n- removes the necessity for wrapping all checked `Exception`s with `RuntimeException`s.\n- is not a breaking change.\n- lets the compiler help us find places where we've made mistakes.\n\nIt's benefit is more obvious in Java 8. before:\n\n```\n() -> {\n    try {\n        return new FileReader(file);\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n\nafter:\n\n```\n() -> new FileReader(file)\n```\n\nI made a new set of interfaces `Func<0..9,N>Checked` and `Action<0..9,N>Checked`.  The original `Func<0..9,N>` and `Action<0..9,N>` now extend from the checked version but remove the `throws Exception`.  Anywhere an observable operator already invokes `Func`s or `Action`s and already wraps that call in the try catch to handle Throwables than the checked version can be woven through.\n\nI've also included a sample change where I used `Func1Checked` for `Observable::map(f)`.", "NaN"], ["1306", "Hooked RxJavaPlugins errorHandler up within all operators that swallow onErrors", "Matt Jacobs", "mattrjacobs", "06/02/14, 11:53:10 PM", "Otherwise, the only onErrors visible to RxJavaPlugins.errorHandler plugin are the ones which propagate all the way to SafeSubscriber.", "NaN"], ["1307", "testNotificationDelay - Attempt at determinism", "Ben Christensen", "benjchristensen", "06/02/14, 10:36:11 PM", "Trying to make this deterministic ... I think it was possible for scheduling in the Executor to cause different threads to be used, even when queueing happened. This forces the same thread to be used as it is different Executors.", "NaN"], ["1308", "ChainedSubscription -> SubscriptionList", "Ben Christensen", "benjchristensen", "06/03/14, 04:09:06 PM", "This matches the name decided upon in 0.18.4", "NaN"], ["1309", "Hide ChainedSubscription/SubscriptionList from Public API", "Ben Christensen", "benjchristensen", "06/03/14, 04:08:45 PM", "Instead of adding this type to the public API, it hides it as an internal implementation detail and does not expose it via the `Subscriber` constructor.\n\nIf we want to expose it later we can figure out a proper name and do so.\n\nThis also changes operator implementations to not inject a `SubscriptionList` but instead just create the `Subscriber` and use it directly.", "NaN"], ["1311", "Tiny integration test change", "Mingtao Zhang", "MagIciaNGTAO", "06/04/14, 04:38:31 PM", "It's a tiny change.\n\nI've been following this project for a while as a hobby, also want to contribute to it. \n\nCurrently I am going through test cases to learn. Found some tiny problems as we are testing \"concat\", we should care not only the total number of elements, but also the sequences.\n\nCreating this request mainly want to make sure I am writing/commiting code to the correct place.\n\nLet me know if there is any problem.\n\nBest Regards,\nMingtao", "NaN"], ["1316", "Add the rest operators to RxScala", "Shixiong Zhu", "zsxwing", "06/08/14, 03:41:20 PM", "This PR added the rest operators to RxScala. However, I think some operators in rxjava-math, rxjava-string , such as `min`, `max`, `average`, are worth to add to RxScala. What do you think? @headinthebox, @samuelgruetter", "NaN"], ["1321", "Ensuring Runnables posted with delay to a Handler are removed when unsub...", "David Marques", "dpsm", "06/12/14, 04:33:42 PM", "...scribed.\n\nThis patch ensures the delayed runnables posted to a Handler are properly\nremoved when Subscription.unsubscribe() is called on the Observable.\n\nThe original code returns the subscription from schedule() but is not used\nby the callers who instead add the Worker itself as a subsciption.\n\nSigned-off-by: David Marques dpsmarques@gmail.com", "NaN"], ["1324", "TrampolineScheduler & Unsubscribe", "Ben Christensen", "benjchristensen", "06/04/14, 11:09:38 PM", "Unsubscribing should prevent new additions to a Worker, but not prevent already scheduled work, and definitely not affect other Workers using the same thread (by modifying the ThreadLocal as it was doing).\n\nSee the unit test for details of how unsubscribing 1 Worker could prevent work from being done on a completely separate Worker.", "NaN"], ["1325", "PREVIEW-1 => Backpressure: Subscriber, Producer & ObserveOn", "Ben Christensen", "benjchristensen", "06/11/14, 03:54:48 AM", "This is the first round of dev on backpressure and not even close to final. I am publishing as PR for collaboration. /cc @headinthebox @abersnaze @akarnokd \n- 2 unit tests are failing as the sources don't yet support backpressure.\n- There are stray printlns throughout code still.\n- I have not yet attempted `merge` though I have a general strategy in mind. It is most likely my next thing to work on.\n- I have not looked at performance impact at all.\n- All names and object models are open to change.\n- I've got `Atomic*` uses that need to become `*FieldUpdaters`\n- Several TODOs showing where improvements need to be made, such as a proper ring-buffer implementation.\n\nWhat to look at:\n- `Subscriber` -> the `request` and `setProducer` methods\n- `OnSubscribeFromIterable`\n- `OperatorObserveOn`\n- `RxSpscRingBuffer`\n\nWork to do:\n- the `subscribeOn` operator needs to decorate `setProducer` to compose the scheduling of starting up the `Producer` again\n- `merge`\n- backpressure operators such as `onBackpressureDrop`, `onBackpressureBuffer`, `onBackpressureUnsubscribe`, `onBackpressureSample/Throttle/etc`\n- unit tests for various use cases\n- performance and memory allocation testing\n- prove with Netty channels\n- determine if there are any use cases that will kill this ...\n  - for example, the `filter` operator must take `request` into account otherwise when it filters out events they won't propagate and then `request` may never get called again and the chain hangs\n  - there are likely other scenarios like `take` ... and some I'm concerned are nuanced", "NaN"], ["1326", "Added overload for retry to accept a Func1<Obs, Obs>", "Aubrey Tull", "stealthcode", "07/24/14, 07:43:33 AM", "Implemented a new overload for Retry operator that accepts a `Func1<Observable<Notification>>, Observable<?>>` for determining retry behavior and reimplemented the existing retry overloads in terms of the new overload. I intend for this change to allow for implementing clean-up logic on notification of a failure prior to the retry behavior as well as expressive functional retry logic. ", "NaN"], ["1327", "Join patterns extension for 4..9 and N arity joins.", "David Karnok", "akarnokd", "06/12/14, 04:43:23 PM", "Issue #1318\n\nI made some potential breaking changes:\n- made classes final\n- made most methods protected or package private", "NaN"], ["1330", "Adding an unzip operator to split 1 observable into N observables.", "George Campbell", "abersnaze", "06/06/14, 07:29:45 PM", "This isn't ready for merging but should work for #1317.  It's a naive implementation that bases the N observables off of ReplaySubject of the source.", "NaN"], ["1332", "IOSSchedulers for RoboVM", "Ashley", "ashleyj", "06/25/14, 05:11:28 PM", "Added support for IOSchedulers for RoboVM\n\nI haven't added unit tests as \n1) they can't be automated\n2) they require the simulator\nIt sucks, I know and I'm working on a way to automate this.\n\nApologies for the double PR -- had to rebranch", "NaN"], ["1333", "Merge pull request #1 from Netflix/master", null, "fsiu", "06/06/14, 04:21:35 PM", "Remote sync", "NaN"], ["1335", "Bump build tools to 19.1 and android plugin to 0.11", "Matthias K\u00e4ppler", "mttkay", "06/12/14, 04:44:41 PM", "This is to make the project compatible with Android Studio 0.6.x (the latest release)", "NaN"], ["1336", "RxScala: Add the rest missing methods to BlockingObservable", "Shixiong Zhu", "zsxwing", "06/16/14, 11:00:55 PM", "Some comments about this PR:\n- Changed the constructor from `BlockingObservable[+T] private[scala] (val asJava: rx.observables.BlockingObservable[_ <: T])` to `BlockingObservable[+T] private[scala] (val o: Observable[T])` so that we can implement logic in `BlockingObservable`.\n- Avoided to use `toIterable` to implement `***Option` and `***OrElse` because if some exception happens, we can not unsubscribe the underlying `Observable` by `Iterable` at once.\n\n/cc @headinthebox, @samuelgruetter", "NaN"], ["1337", "Make Future receive NoSuchElementException when the BlockingObservable is empty", "Shixiong Zhu", "zsxwing", "06/12/14, 04:48:13 PM", "Now `Future.get` will return `null` if there is a single `null` in the BlockingObservable, or it is empty. People cannot distinguish between these two cases.\n\nThis PR has 2 breaking changes:\n- Throw an `NoSuchElementException` rather than returning `null` when the BlockingObservable is empty.\n- Change the exception from `IllegalStateException` to `IllegalArgumentException` when the BlockingObservable emits more than one items. This is because I used `single` directly.", "NaN"], ["1338", "Add capacity hint version of Observable.cache()", "Joakim Bodin", "jbripley", "07/22/14, 09:32:40 AM", "- Special case in ReplaySubject for create(1) to optimize for single emitted value\n- Add unit tests for Observable.cache(1) and ReplaySubject.create(1)\n\n@benjchristensen is this the kind of solution you wanted for #1303?", "NaN"], ["1345", "RxScala: Simplify doOnCompleted/Terminate, finallyDo callback usage", "Joakim Bodin", "jbripley", "06/12/14, 04:53:58 PM", "As mentioned in #1342", "NaN"], ["1347", "Allow use of the returned subscription to cancel periodic scheduling", "Samuel Tardieu", "samueltardieu", "06/12/14, 04:31:06 PM", "The documentation for schedulePeriodically indicates that the returned\nsubscription can be used to unsubscribe from the periodic action, or to\nunschedule it if it has not been scheduled yet. That was the case only\nbefore the first action took place, and it was then impossible to\nunsubscribe using the given subscription, although unsubscribing the\nworker did work.\n\nThis fixes #1344.", "NaN"], ["1350", "Baseline Performance Tests", "Ben Christensen", "benjchristensen", "06/11/14, 02:50:30 AM", "Start of suite of general performance tests for comparing overall changes.", "NaN"], ["1351", "Backpressure-3: Merge & ObserveOn (Not Production Ready)", "Ben Christensen", "benjchristensen", "06/13/14, 06:19:58 AM", "Here is a snapshot of working on backpressure. This is NOT production ready and I'm not all that happy with it right now.\n- bad performance\n- pivot and parallel operators seem broken (concurrency bugs with `merge` I think)\n- bad algorithm in `merge`\n- need to replace data structures (lists/queues)\n- apparent memory leak in `observeOn` with `Schedulers.computation()` that causes JMH tests to fail on it\n\n```\n../gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 2 -prof GC rx.usecases.*'\n```\n\nMaster branch (v0.19):\n\n```\nBenchmark                                        (size)   Mode   Samples         Mean   Mean error    Units\nr.u.PerfBaseline.forLoopConsumption                   1  thrpt         5 379615485.594 15379754.350    ops/s\nr.u.PerfBaseline.forLoopConsumption                1024  thrpt         5   328864.473    18187.666    ops/s\nr.u.PerfBaseline.iterableViaForLoopConsumption        1  thrpt         5 253622547.509 27125669.781    ops/s\nr.u.PerfBaseline.iterableViaForLoopConsumption     1024  thrpt         5   188193.794    10372.260    ops/s\nr.u.PerfBaseline.iterableViaHasNextConsumption        1  thrpt         5 338153673.244 13436554.726    ops/s\nr.u.PerfBaseline.iterableViaHasNextConsumption     1024  thrpt         5   299124.445    28327.383    ops/s\nr.u.PerfBaseline.observableConsumption                1  thrpt         5 31394747.471   781746.789    ops/s\nr.u.PerfBaseline.observableConsumption             1024  thrpt         5   245864.811     6657.154    ops/s\nr.u.PerfObserveOn.observeOnComputation                1  thrpt         5   391499.859    18397.563    ops/s\nr.u.PerfObserveOn.observeOnComputation             1024  thrpt         5    13328.636      306.077    ops/s\nr.u.PerfObserveOn.observeOnImmediate                  1  thrpt         5 21230728.918   892820.007    ops/s\nr.u.PerfObserveOn.observeOnImmediate               1024  thrpt         5   251638.525     3525.681    ops/s\nr.u.PerfObserveOn.observeOnNewThread                  1  thrpt         5    21527.805     2739.158    ops/s\nr.u.PerfObserveOn.observeOnNewThread               1024  thrpt         5    10020.191      188.225    ops/s\nr.u.PerfTransforms.flatMapInt                         1  thrpt         5  3564189.441    39217.324    ops/s\nr.u.PerfTransforms.flatMapInt                      1024  thrpt         5     7093.382      179.934    ops/s\nr.u.PerfTransforms.flatMapNestedMapFilterTake         1  thrpt         5  2292314.964   137546.825    ops/s\nr.u.PerfTransforms.flatMapNestedMapFilterTake      1024  thrpt         5       17.375        0.430    ops/s\nr.u.PerfTransforms.mapIntStringInt                    1  thrpt         5  9653977.591   122946.457    ops/s\nr.u.PerfTransforms.mapIntStringInt                 1024  thrpt         5    19772.989     1649.906    ops/s\nr.u.PerfTransforms.mapPassThru                        1  thrpt         5 19220291.170  1408394.928    ops/s\nr.u.PerfTransforms.mapPassThru                     1024  thrpt         5   202820.081    27896.934    ops/s\n```\n\nWith backpressure changes:\n\n```\nBenchmark                                        (size)   Mode   Samples         Mean   Mean error    Units\nr.u.PerfBaseline.forLoopConsumption                   1  thrpt         5 357110005.600 40841385.201    ops/s\nr.u.PerfBaseline.forLoopConsumption                1024  thrpt         5   323485.335    12560.808    ops/s\nr.u.PerfBaseline.iterableViaForLoopConsumption        1  thrpt         5 250763283.151 41052831.579    ops/s\nr.u.PerfBaseline.iterableViaForLoopConsumption     1024  thrpt         5   184443.933    17732.768    ops/s\nr.u.PerfBaseline.iterableViaHasNextConsumption        1  thrpt         5 328354319.566 20021232.226    ops/s\nr.u.PerfBaseline.iterableViaHasNextConsumption     1024  thrpt         5   295521.735    60981.106    ops/s\nr.u.PerfBaseline.observableConsumption                1  thrpt         5  9523326.320  1946455.684    ops/s     9.5m vs 31.3m\nr.u.PerfBaseline.observableConsumption             1024  thrpt         5    84990.974     4275.619    ops/s\nr.u.PerfObserveOn.observeOnComputation                1  thrpt         5   367281.334    88162.113    ops/s     367k vs 391k\nr.u.PerfObserveOn.observeOnComputation             1024  thrpt         failed (ran out of memory apparently, see below)\nr.u.PerfObserveOn.observeOnImmediate                  1  thrpt         5  7411354.828  1380680.011    ops/s     7.4m vs 21.2m\nr.u.PerfObserveOn.observeOnImmediate               1024  thrpt         5    83914.883     6175.528    ops/s\nr.u.PerfObserveOn.observeOnNewThread                  1  thrpt         5    21795.495      696.339    ops/s     21.7k vs 21.5k\nr.u.PerfObserveOn.observeOnNewThread               1024  thrpt         5    15361.160     1052.314    ops/s     15.3k vs 10k\nr.u.PerfTransforms.flatMapInt                         1  thrpt         5  1194526.066    91077.184    ops/s     1.2m vs 3.6m\nr.u.PerfTransforms.flatMapInt                      1024  thrpt         5     1799.220       70.146    ops/s\nr.u.PerfTransforms.flatMapNestedMapFilterTake         1  thrpt         5   858432.448   135990.002    ops/s     858k vs 2292k\nr.u.PerfTransforms.flatMapNestedMapFilterTake      1024  thrpt         5       45.345        1.928    ops/s     17 vs 45 (something is wrong here on both)\nr.u.PerfTransforms.mapIntStringInt                    1  thrpt         5  4433584.545  1336597.807    ops/s     4.4m vs 9.6m\nr.u.PerfTransforms.mapIntStringInt                 1024  thrpt         5    17271.313      881.956    ops/s\nr.u.PerfTransforms.mapPassThru                        1  thrpt         5  6098106.967   526635.319    ops/s     6.1m vs 19.2m\nr.u.PerfTransforms.mapPassThru                     1024  thrpt         5    81472.209     5419.922    ops/s\n\n\nr.u.PerfObserveOn.observeOnComputation with size 1024\n\nIteration   1: 1052.083 ops/s\n          GC | wall time = 2.952 secs,  GC time = 2.945 secs, GC% = 99.76%, GC count = +3\n             |\n\nIteration   2: 161.619 ops/s\n          GC | wall time = 2.766 secs,  GC time = 2.765 secs, GC% = 99.96%, GC count = +3\n             |\n```", "NaN"], ["1355", "Don't add the subscriber to the manager if it unsubscribed during the on...", "David Karnok", "akarnokd", "06/12/14, 04:29:48 PM", "...Start call\n\nThis may happen, for example, when subscribing to a ReplaySubject containing some elements and taking fewer elements than available. In the original, the logic opened a small window where the SubjectSubscriber could get an onNext event even if the actual Subscriber was already unsubscribed at that point.", "NaN"], ["1357", "MergeWith, ConcatWith, AmbWith", "Ben Christensen", "benjchristensen", "06/12/14, 05:34:41 PM", "Single-arity instance versions of merge, concat and amb.\nSince we can't use the `merge`/`concat`/`amb` names on both static and instance methods, these have the `With` suffix, which actually reads quite well.\n\n``` java\no.mergeWith(o2).subscribe(ts);\no.concatWith(o2).subscribe(ts);\no.ambWith(o2).subscribe(ts);\n```\n\nIf we feel the need for more arities fine, but I wanted to start simple.\n\nThis originated from discussions with @headinthebox and over a year of wanting instance methods for `merge`.", "NaN"], ["1358", "Backpressure-4: Merge & ObserveOn (Not Production Ready)", "Ben Christensen", "benjchristensen", "06/16/14, 11:51:47 PM", "Further progress on top of https://github.com/Netflix/RxJava/pull/1351 that adds object pooling (of ring buffers) and various improvements while looking at performance.\n- Next is to redo the merge implementation that I'm not happy with.\n- Pivot and parallel operators seem broken (concurrency bugs with `merge` I think).\n- Still have performance problems.\n\n```\n../gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 2 -prof GC rx.usecases.PerfBaseline.*'\n```\n\n```\nBenchmark                                        (size)   Mode   Samples         Mean   Mean error    Units\nr.u.PerfBaseline.observableConsumption                1  thrpt         5 29341887.334  1377398.290    ops/s\nr.u.PerfBaseline.observableConsumption             1024  thrpt         5   235288.206    36803.980    ops/s\nr.u.PerfBaseline.observableViaRange                   1  thrpt         5 10995116.886   851761.135    ops/s\nr.u.PerfBaseline.observableViaRange                1024  thrpt         5    83175.180     2983.626    ops/s\n```\n\nvs 0.19:\n\n```\nBenchmark                                        (size)   Mode   Samples         Mean   Mean error    Units\nr.u.PerfBaseline.observableConsumption                1  thrpt         5 31394747.471   781746.789    ops/s\nr.u.PerfBaseline.observableConsumption             1024  thrpt         5   245864.811     6657.154    ops/s\n```", "NaN"], ["1359", "Fixed padding of the integer and node classes.", "David Karnok", "akarnokd", "06/13/14, 04:16:05 PM", "Added proper padding of MpscLinkedQueue and PaddedAtomicInteger, based on Netty's implementation.\n\nNote that each padded class now occupies 256 bytes (which translates to either 2 or 4 cache lines) to avoid false sharing in both before and after the actual value and to avoid adjacent cache line fetch effects.\n\nFor issue #1310 ", "NaN"], ["1361", "Fix a race condition if queued actions have been handled already", "Samuel Tardieu", "samueltardieu", "06/16/14, 11:04:01 PM", "This should fix #1354.\n\nCc @Bananeweizen @akarnokd", "NaN"], ["1362", "RxScala: Fix #1340 and #1343", "Shixiong Zhu", "zsxwing", "06/16/14, 10:59:43 PM", "- Implement `create` for #1340\n- Remove `/*XXX*/` for #1343\n\n/cc @headinthebox, @samuelgruetter", "NaN"], ["1363", "Fix the bug that 'single' may unsubscribe the whole Subscription chain incorrectly", "Shixiong Zhu", "zsxwing", "06/17/14, 05:57:32 AM", "Decoupled the parent and child Subscribers to fix this bug.", "NaN"], ["1366", "Backpressure-5: Merge, ObserveOn, SubscribeOn, etc", "Ben Christensen", "benjchristensen", "06/18/14, 12:11:52 AM", "- Mostly functional backpressure with `merge` and `observeOn`.\n- Pivot and Parallel operators have issues and unit tests and ignored.\n- This is NOT production ready. Need to work on algorithms in merge, data structures and concurrency implementations.\n\nPerformance of `flatMap` compared with 0.19:\n\n```\n../gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 2 -prof GC rx.usecases.PerfObserveOn.observeOnComputation'\n```\n\nCurrent\n\n```\nBenchmark                                       (size)   Mode   Samples         Mean   Mean error    Units\nr.u.PerfTransforms.flatMapInt                        1  thrpt         5  1513055.461    35120.889    ops/s\nr.u.PerfTransforms.flatMapInt                     1024  thrpt         5     2229.818       50.863    ops/s\nr.u.PerfTransforms.flatMapNestedMapFilterTake        1  thrpt         5  1114912.405   137096.910    ops/s\nr.u.PerfTransforms.flatMapNestedMapFilterTake     1024  thrpt         5       82.799        1.695    ops/s\n```\n\n0.19 master\n\n```\nBenchmark                                       (size)   Mode   Samples         Mean   Mean error    Units\nr.u.PerfTransforms.flatMapInt                        1  thrpt         5  3372557.564   131729.592    ops/s\nr.u.PerfTransforms.flatMapInt                     1024  thrpt         5     6713.975      159.005    ops/s\nr.u.PerfTransforms.flatMapNestedMapFilterTake        1  thrpt         5  2231392.499    50190.297    ops/s\nr.u.PerfTransforms.flatMapNestedMapFilterTake     1024  thrpt         5       16.437        0.413    ops/s\n```\n\n``` java\n        input.observable.flatMap(i -> {\n            return Observable.from(i);\n        }).subscribe(input.observer);\n```\n\nCurrent\n\n```\nRun: 10 - 1,697,014 ops/sec\nRun: 11 - 1,675,210 ops/sec\nRun: 12 - 1,781,483 ops/sec\nRun: 13 - 1,674,677 ops/sec\nRun: 14 - 1,714,354 ops/sec\n```\n\nvs 0.19\n\n```\nRun: 10 - 2,809,225 ops/sec\nRun: 11 - 3,051,850 ops/sec\nRun: 12 - 3,100,006 ops/sec\nRun: 13 - 3,007,699 ops/sec\nRun: 14 - 3,114,585 ops/sec\n```", "NaN"], ["1367", "Fix the bug that 'flatMap' swallows OnErrorNotImplementedException", "Shixiong Zhu", "zsxwing", "06/21/14, 02:25:24 PM", "Fixed #1365\nNot sure if any other place will swallow `OnErrorNotImplementedException` or the fatal errors.", "NaN"], ["1369", "DebugHook got miswired before", "Matt Jacobs", "mattrjacobs", "06/17/14, 07:20:17 PM", "This was throwing ClassCastExceptions when used.  Now it works", "NaN"], ["1371", "Backpressure-6: Merge, ObserveOn, SubscribeOn, etc", "Ben Christensen", "benjchristensen", "06/21/14, 02:25:37 PM", "Mostly functional backpressure with `merge` and `observeOn`.\nThis is NOT production ready. Need to work on algorithms in merge, data structures and concurrency implementations.\n\nThis does not yet have `zip` implemented, and despite effort on performance there are still degradations as shown below.\n\n```\n../gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 2 -prof GC rx.usecases.*'\n```\n\nPerformance for 0.19.x vs 0.20 (this branch):\n\n```\nBenchmark                                        (size)           0.19             0.20     diff\nr.u.PerfBaseline.forLoopConsumption                   1  344850705.588    356169426.506     within mean error\nr.u.PerfBaseline.forLoopConsumption                1024     304909.309       311743.590     within mean error\nr.u.PerfBaseline.iterableViaForLoopConsumption        1  239518717.088    241586374.313     within mean error\nr.u.PerfBaseline.iterableViaForLoopConsumption     1024     177090.461       180974.316     within mean error\nr.u.PerfBaseline.iterableViaHasNextConsumption        1  302479118.588    307508627.346     within mean error\nr.u.PerfBaseline.iterableViaHasNextConsumption     1024     282783.917       287813.401     within mean error\nr.u.PerfBaseline.observableConsumption                1   29295739.451     28748055.426     within mean error => 29.2m vs 28.7m, mean error ~0.45m\nr.u.PerfBaseline.observableConsumption             1024     233194.851       234253.687     within mean error\nr.u.PerfBaseline.observableViaRange                                        21535829.318\nr.u.PerfBaseline.observableViaRange                                           51645.436\nr.u.PerfObserveOn.observeOnComputation                1     378476.870       310228.157     378k vs 310k, mean error ~50k\nr.u.PerfObserveOn.observeOnComputation             1024      13122.964         4423.132     WORSE: 13k vs 4k\nr.u.PerfObserveOn.observeOnImmediate                  1   20465307.041     17203295.323     WORSE: 20.4m vs 17.2m, mean error ~800k\nr.u.PerfObserveOn.observeOnImmediate               1024     232424.832        51503.696     WORSE: 232k vs 51k\nr.u.PerfObserveOn.observeOnNewThread                  1      20209.183        20055.322     within mean error\nr.u.PerfObserveOn.observeOnNewThread               1024      10170.748         4224.503     WORSE: 10k vs 4k\nr.u.PerfTransforms.flatMapInt                         1    3308740.889      2404699.223     WORSE: 3.3m vs 2.4m\nr.u.PerfTransforms.flatMapInt                      1024       6522.641         3053.996     WORSE: 6.5k vs 3.0k\nr.u.PerfTransforms.flatMapNestedMapFilterTake         1    2150209.920      1777010.078     WORSE: 2.1m vs 1.8m, mean error ~60k\nr.u.PerfTransforms.flatMapNestedMapFilterTake      1024         15.943           80.803     BETTER: 15 vs 80, mean error ~3\nr.u.PerfTransforms.mapIntStringInt                    1    9107565.666      9004589.569     within mean error\nr.u.PerfTransforms.mapIntStringInt                 1024      18774.750        15238.517     WORSE: 18.7k vs 15.2k, mean error ~500\nr.u.PerfTransforms.mapPassThru                        1   19336755.193     15719416.479     WORSE: 19.3m vs 15.7m, mean error ~500k\nr.u.PerfTransforms.mapPassThru                     1024     199751.628        49089.139     WORSE: 200k vs 49k\n```", "NaN"], ["1374", "Fix head/tail false sharing issues", "Nitsan Wakart", "nitsanw", "06/21/14, 02:22:16 PM", "See discussion in issue #1310 ", "NaN"], ["1375", "RxScala: Add idiomatic toXXX methods", "Shixiong Zhu", "zsxwing", "06/23/14, 03:58:08 PM", "Suggested by @headinthebox in https://github.com/Netflix/RxJava/pull/1336#issuecomment-46118339\n\n/cc @headinthebox, @samuelgruetter", "NaN"], ["1376", "Revision of JMH Tests", "Ben Christensen", "benjchristensen", "06/23/14, 09:48:13 PM", "This updates all perf testing to use only JMH. I tried to get all of them to follow a common pattern, and to comply with examples at https://github.com/nitsanw/jmh-samples/blob/master/src/main/java/org/openjdk/jmh/samples/ by @nitsanw. (@nitsanw if you're willing to take a look at this and confirm or correct them, I'd appreciate that).\n\nI am doing this in 0.19 so that work on 0.20 has a common set of perf tests to use for comparison.", "NaN"], ["1377", "Utility Class for Accessing Unsafe", "Ben Christensen", "benjchristensen", "07/02/14, 08:05:17 PM", "While working on code for v0.20 I have come across reasons for using sun.misc.Unsafe (such as #1372).\n\nThis provides a common way for getting access to `sun.misc.Unsafe` as well as utility methods for commonly needed APIs (that exist in Java 8, but not Java 6).\n\nI need someone to help me confirm whether this works on Android, and if not how we can make this be aware of what platform it is running on, as per https://github.com/Netflix/RxJava/issues/1372#issuecomment-46717293", "NaN"], ["1378", "BugFix: Pivot Concurrency", "Ben Christensen", "benjchristensen", "06/24/14, 02:45:50 AM", "It wasn't serializing the `onNext`.", "NaN"], ["1379", "Parallel Operator Rewrite", "Ben Christensen", "benjchristensen", "06/24/14, 02:46:08 AM", "A rewrite of the `parallel` operator that is more efficient by not using `groupBy` and ready to support backpressure.", "NaN"], ["1380", "Variety of Fixes", "Ben Christensen", "benjchristensen", "06/24/14, 03:01:58 AM", "... found while working on backpressure.", "NaN"], ["1381", "Replace Arrays.copyOf* with System.arraycopy", "Vladimir Baryshnikov", "vovkab", "07/08/14, 07:48:53 PM", "Arrays.copyOf is not supported on android api8\n\nMaybe it make sense to create helper class like ArraysCompat to have all copyOf\\* in one place?", "NaN"], ["1382", "Backpressure-7 - Merge & ObserveOn", "Ben Christensen", "benjchristensen", "07/03/14, 07:29:35 AM", "This is a functioning but non-performant implementation of backpressure. Of the major unbounded queue operators in 0.19, this implements `observeOn` and `merge` but not yet `zip`. Several attempts at performance improvements last week failed so I have rolled them back and left this with naive data structures while restarting the performance work.\n\nI want to kick off the design and functionality review while continuing to work on performance.\n### New Signatures\n\n``` java\npublic interface Producer {\n    public void request(int n);\n}\n```\n\n``` java\npublic abstract class Subscriber<T> implements Observer<T>, Subscription {\n\n    /**\n     * Optionally called from `Observable.OnSubscribe`.\n     */\n    public final void setProducer(Producer producer);\n\n    /**\n     * Allow implementing classes to capture, decorate or override the `Producer` without affecting the `Subscriber` logic.\n     */\n    protected Producer onSetProducer(Producer producer);\n\n    public final void request(int n);\n}\n```\n### `Subscriber.request` vs `Producer.request`\n\nThis is possibly confusing and I think we may want to eliminate `Subscriber.request`. It would make some operators like `take` more complicated, but for the rare time it is needed, I think it's more clear that you must \"capture\" the `Producer` and call `Producer.request`.\n### Operator Changes\n\n`OnSubscribeFromIterable` and `OnSubscribeRange` are both updated to support `Producer` and will only emit as many `onNext` as requested. The implementations are a little more complex than needed as they optimize for cases where backpressure is not requested and fallback to the \"firehose\" model of 0.19 and earlier. This allows for higher throughput in case where backpressure is not needed.\n\n`parallel` had to be rewritten with a different approach to support backpressure. The `filter`, `take`, and `skip` operators were modified to support backpressure and propagate request modifications based on each of their logic. `takeUntil` needed to be rewritten because `NotificationLite` can't be allowed to leak across operators. The `subscribeOn` operator was modified to correctly reschedule work on the given `Scheduler` when a `request(n)` occurs after the `Producer` has let itself shut down. \n### Design Questions\n##### 1) Producer\n\nIs the name and signature of `Producer.request(n)` correct?\n##### 2) Subscriber.setProducer\n\nIs this the correct signature for an `Observable.OnSubscribe` to register the `Producer`?\n##### 3) Subscriber.request\n\nThis seems confusing and should probably be removed, despite it making some use cases such as `take` and `filter` more complicated.\n##### 4) Requesting <0 for Infinite (no backpressure)\n\nTo be backwards compatible, and support performance optimizations when backpressure is not needed, `Producer.request(n)` can be invoked with a negative number. This means \"no backpressure\" and the `Producer` can then emit data in a tight-loop without further limitations.\n\nIs this acceptable and the best solution?\n##### 5) Producer.BUFFER_SIZE\n\nCurrently there is a public constant, `Producer.BUFFER_SIZE` that represents the system-wide size of buffers used for backpressure. This is exposed so that an operator implementation can optimize to skip the `setProducer` path when it knows it will emit less data that the BUFFER_SIZE. \n\nThis does have a performance benefit, but it comes at the cost of exposing implementation details. It also means all buffers MUST use the same buffer size, or at least not be any smaller.\n\nIs this something we want? Is the performance benefit worth the trade-offs and complexity?\n##### 6) Other operators like filter?\n\nAre there other operators that filter out `onNext` like `filter` does that we must modify to call `request(1)` each time it filters something out? Is there a better way of handling this so operators do not need to manually handle this?\n##### 7) onBackpressure*\n\nAre the `onBackpressureBuffer` and `onBackpressureDrop` operators well-named, clear in their usage and implemented correctly? Should we implemented others such as `onBackpressureUnsubscribe` and `onBackpressureBuffer(int limitUntilDropping)`?\n##### 8) Unit Tests and Use Cases\n\nAre there major use cases that are missing from `BackpressureTests`? \n\nWhat problems are there that are not yet resolved or handled by the design?\n##### 9) observeOn\n\nIs the design of `observeOn` as efficient and correct as it can be?\n##### 10) merge\n\nThe `merge` operator currently has a naive algorithm for handling the queue of buffers. We need to design a better one. \n\nThere are some unit tests marked as ignored for `merge` in the `BackpressureTests` class. Should those work? What should be the behavior of `merge` when merging all synchronous, all asynchronous, or mixed sync/async Observables?\n### Performance\n\nPerformance is not good right now. The biggest problem is `merge`, and that's critical since it's key to `flatMap` which is a core operator.\n\nPerformance can be tested via the JMH performance tests. This is where I'm currently focusing.", "NaN"], ["1384", "Explore SubscriptionList/Subscriber & Synchronization", "Ben Christensen", "benjchristensen", "07/07/14, 09:24:46 PM", "This is an exploratory pull request related to https://github.com/Netflix/RxJava/issues/1383 that removes SubscriptionList synchronization and synchronizes ObserveOn.unsubscribe.\n\nThe performance impact on rapid subscribe/unsubscribe (such as an `Observable` with 1 item) is significant (31m -> 47m ops/second).\n\nWhat I don't know however is if this is completely safe. Some unit tests did indeed fail when I removed the synchronization from `SubscriptionList` until I modified `observeOn` \u2013 so that's good. Then the unit tests all passed again when I made `observeOn` handle the synchronization. I have to think however that there are use cases I'm not covering with unit tests. \n\nI'd appreciate other peoples thoughts on this.\n\n```\nBEFORE\n\nBenchmark                               (size)   Mode   Samples         Mean   Mean error    Units\nr.PerfBaseline.observableConsumption         1  thrpt         5 31167007.424  2027918.084    ops/s\nr.PerfBaseline.observableConsumption      1000  thrpt         5   227387.447    32738.021    ops/s\nr.PerfBaseline.observableConsumption   1000000  thrpt         5      245.632       13.743    ops/s\n\nAFTER\n\nBenchmark                               (size)   Mode   Samples         Mean   Mean error    Units\nr.PerfBaseline.observableConsumption         1  thrpt         5 47142418.802  5341223.740    ops/s\nr.PerfBaseline.observableConsumption      1000  thrpt         5   220175.324    35936.506    ops/s\nr.PerfBaseline.observableConsumption   1000000  thrpt         5      221.077       44.437    ops/s\n```\n\nBEFORE\n\n```\nBenchmark                                         (size)   Mode   Samples         Mean   Mean error    Units\nr.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5    86331.092     5181.739    ops/s\nr.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5     8787.634      316.166    ops/s\nr.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5        8.590        4.527    ops/s\nr.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5 13074710.596   217808.611    ops/s\nr.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5   188868.055     5448.065    ops/s\nr.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5      185.372        4.190    ops/s\nr.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5    13848.943     2601.271    ops/s\nr.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5     6867.300      172.123    ops/s\nr.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5       10.100        1.925    ops/s\n\nAFTER\n\nBenchmark                                         (size)   Mode   Samples         Mean   Mean error    Units\nr.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5    69120.389    16422.228    ops/s\nr.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5    12261.472      267.137    ops/s\nr.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5       15.466        0.269    ops/s\nr.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5 13200910.511   418278.691    ops/s\nr.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5   179868.400     6465.965    ops/s\nr.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5      184.210        2.299    ops/s\nr.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5    12880.951     2183.905    ops/s\nr.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5     9164.764      385.580    ops/s\nr.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5       17.249        1.173    ops/s\n```", "NaN"], ["1385", "OperatorTake: remove unsubscribe call to parent on take(0)", "Dave Moten", "davidmoten", "06/25/14, 12:46:55 PM", "This is a very minor cleanup of `OperatorTake`. By changing the order of the existing code I removed a call to `parent.unsubscribe()`.", "NaN"], ["1386", "add Observable.sort() instance methods", "Dave Moten", "davidmoten", "07/08/14, 07:46:47 PM", "Added two `Observable.sort` instance methods that are equivalent to \n\n``` java\nObservable.toSortedList().flatMap(x -> Observable.from(x))\n```\n\nI guess you might ask well why don't people just code that. I think it adds the following:\n- a more natural reading api method\n- doesn't interrupt the observable flow with buffered type `Observable<List<T>>`\n- less mess for those people coding without lambdas", "NaN"], ["1387", "Upgrade to JMH 0.9", "Ben Christensen", "benjchristensen", "06/25/14, 05:35:34 PM", "NaN", "NaN"], ["1388", "CompositeException stops mutating nested Exceptions", "Matt Jacobs", "mattrjacobs", "06/25/14, 11:29:26 PM", "Instead, it aggregates them at print-time. Since nothing is being mutated, there's no chance of accidentally creating a cycle in the Exception chain.  We ran into this in production very intermittently and had to add handling any time we were touching the Exception chain.", "NaN"], ["1393", "Add cache(int capacity) to Observable", "G\u00e1bor Lipt\u00e1k", "gliptak", "07/22/14, 05:00:40 AM", "Proposed patch for #1303", "NaN"], ["1394", "Gradle Builds: Change provided to testCompile", "G\u00e1bor Lipt\u00e1k", "gliptak", "07/10/14, 04:11:12 PM", "Gradle now generates correct eclipse dependencies", "NaN"], ["1396", "RxScala: Fix the compiler warnings", "Shixiong Zhu", "zsxwing", "07/02/14, 04:34:18 PM", "This PR fixed the annoying warnings in RxScala, include replacing `toBlockingObservable` with `toBlocking` and adding language.\\* imports.\n\n/cc @headinthebox, @samuelgruetter", "NaN"], ["1397", "Adding the hooks unsafeSubscribe", "George Campbell", "abersnaze", "07/02/14, 04:33:36 PM", "by making the execution and error handling exactly same as safe version without the safety checks.", "NaN"], ["1398", "RxScala: Use currying to improve type inference", "Shixiong Zhu", "zsxwing", "07/08/14, 07:41:13 PM", "As per discussion in #1392.\n\n/cc @headinthebox, @samuelgruetter", "NaN"], ["1399", "Update Perf Tests", "Ben Christensen", "benjchristensen", "07/02/14, 04:46:02 PM", "matching with work being done for 0.20 to allow comparisons", "NaN"], ["1400", "Internal Data Structures", "Ben Christensen", "benjchristensen", "07/02/14, 05:45:32 PM", "Various data structures to allow performance improvements.\nI am committing these separately from the code that uses it to keep the pull requests simpler.\nNothing in RxJava depends on these classes in this commit.", "NaN"], ["1401", "OnError while emitting onNext value: object.toString", null, "samhendley", "07/07/14, 09:24:15 PM", "```\n  public OnNextValue(Object value) {\n        super(\"OnError while emitting onNext value: \" + value);\n        this.value = value;\n    }\n```\n\nI know this is probably a helpful error message in some cases but this can be a really costly operation when an objects toString is an expensive call or contains alot of output. I don't think we should be printing this in any case but if so it should be on demand (overload of getMessage()) rather than eagerly.\n\nIn my case it is causing a toString of a large context object that is normally only used for debugging purposes which makes the exception logs hard to use and they are rolling over the log files very quickly.\n\nThere is an added danger that if there is a bug in the toString method it will cause inconsistent exception creation. If the object throws an exception while rendering a string it will actually end up not seeing the real exception.", "NaN"], ["1403", "Backpressure-8 \u2013 Merge & ObserveOn", "Ben Christensen", "benjchristensen", "07/07/14, 10:46:16 PM", "This is a functioning implementation of backpressure. Of the major unbounded queue operators in 0.19, this implements `observeOn` and `merge` but not yet `zip`. Compared with the previous PRs (backpressure-7 and earlier) this brings performance to levels that are possible to be merged into master.\n### New Signatures\n\n``` java\npublic interface Producer {\n    public void request(int n);\n}\n```\n\n``` java\npublic abstract class Subscriber<T> implements Observer<T>, Subscription {\n\n    /**\n     * Optionally called from `Observable.OnSubscribe`.\n     */\n    public final void setProducer(Producer producer);\n\n    /**\n     * Allow implementing classes to capture, decorate or override the `Producer` without affecting the `Subscriber` logic.\n     */\n    protected Producer onSetProducer(Producer producer);\n\n    public final void request(int n);\n}\n```\n### Operator Changes\n\n`OnSubscribeFromIterable` and `OnSubscribeRange` are both updated to support `Producer` and will only emit as many `onNext` as requested. The implementations are a little more complex than needed as they optimize for cases where backpressure is not requested and fallback to the \"firehose\" model of 0.19 and earlier. This allows for higher throughput in case where backpressure is not needed.\n\n`parallel` had to be rewritten with a different approach to support backpressure. The `filter`, `take`, and `skip` operators were modified to support backpressure and propagate request modifications based on each of their logic. `takeUntil` needed to be rewritten because `NotificationLite` can't be allowed to leak across operators. The `subscribeOn` operator was modified to correctly reschedule work on the given `Scheduler` when a `request(n)` occurs after the `Producer` has let itself shut down. \n### Design Questions\n##### 1) Producer\n\nIs the name and signature of `Producer.request(n)` correct?\n##### 2) Subscriber.setProducer\n\nIs this the correct signature for an `Observable.OnSubscribe` to register the `Producer`?\n##### 3) Requesting <0 for Infinite (no backpressure)\n\nTo be backwards compatible, and support performance optimizations when backpressure is not needed, `Producer.request(n)` can be invoked with a negative number. This means \"no backpressure\" and the `Producer` can then emit data in a tight-loop without further limitations.\n\nIs this acceptable and the best solution?\n##### 4) onBackpressure*\n\nAre the `onBackpressureBuffer` and `onBackpressureDrop` operators well-named, clear in their usage and implemented correctly? Should we implemented others such as `onBackpressureUnsubscribe` and `onBackpressureBuffer(int limitUntilDropping)`?\n##### 5) Unit Tests and Use Cases\n\nAre there major use cases that are missing from `BackpressureTests`? \n\nWhat problems are there that are not yet resolved or handled by the design?\n### Performance\n\n```\n-------------- ../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 2 .*PerfBaseline.observable.*'\n\n------- 0.19\n\nBenchmark                                       (size)   Mode   Samples        Score  Score error    Units\nr.PerfBaseline.iterableViaForLoopConsumption         1  thrpt         5 250139466.600  6920354.087    ops/s\nr.PerfBaseline.iterableViaForLoopConsumption      1000  thrpt         5    182500.174     5244.888    ops/s\nr.PerfBaseline.iterableViaForLoopConsumption   1000000  thrpt         5       170.911        3.823    ops/s\nr.PerfBaseline.iterableViaHasNextConsumption         1  thrpt         5 320148600.957 11599243.208    ops/s\nr.PerfBaseline.iterableViaHasNextConsumption      1000  thrpt         5    297314.203     9485.727    ops/s\nr.PerfBaseline.iterableViaHasNextConsumption   1000000  thrpt         5       269.004        4.151    ops/s\n-----------------------------------------------------------------------------------------------------------\nr.PerfBaseline.observableConsumption                 1  thrpt         5  29298639.717   277675.587    ops/s\nr.PerfBaseline.observableConsumption              1000  thrpt         5    243968.954    10311.720    ops/s\nr.PerfBaseline.observableConsumption           1000000  thrpt         5       252.916        3.420    ops/s\nr.PerfBaseline.observableConsumptionUnsafe           1  thrpt         5 199935597.149 31884367.299    ops/s\nr.PerfBaseline.observableConsumptionUnsafe        1000  thrpt         5    311704.723    39346.976    ops/s\nr.PerfBaseline.observableConsumptionUnsafe     1000000  thrpt         5       307.188       58.163    ops/s\nr.PerfBaseline.observableViaRange                    1  thrpt         5  23843851.260   324794.935    ops/s\nr.PerfBaseline.observableViaRange                 1000  thrpt         5    193208.479     3741.146    ops/s\nr.PerfBaseline.observableViaRange              1000000  thrpt         5       188.261       12.172    ops/s\nr.PerfBaseline.observableViaRangeUnsafe              1  thrpt         5  45762792.585  1379450.701    ops/s\nr.PerfBaseline.observableViaRangeUnsafe           1000  thrpt         5    240280.347     3312.756    ops/s\nr.PerfBaseline.observableViaRangeUnsafe        1000000  thrpt         5       234.143        1.163    ops/s\n\n\n\n------- backpressure-8\n\nBenchmark                                       (size)   Mode   Samples        Score  Score error    Units\nr.PerfBaseline.iterableViaForLoopConsumption         1  thrpt         5 250601807.892 12009864.080    ops/s\nr.PerfBaseline.iterableViaForLoopConsumption      1000  thrpt         5    184859.869     2400.585    ops/s\nr.PerfBaseline.iterableViaForLoopConsumption   1000000  thrpt         5       172.127        4.979    ops/s\nr.PerfBaseline.iterableViaHasNextConsumption         1  thrpt         5 322464817.267  8117858.197    ops/s\nr.PerfBaseline.iterableViaHasNextConsumption      1000  thrpt         5    294868.674     7349.485    ops/s\nr.PerfBaseline.iterableViaHasNextConsumption   1000000  thrpt         5       266.602        5.682    ops/s\n-----------------------------------------------------------------------------------------------------------\nr.PerfBaseline.observableConsumption                 1  thrpt         5  33622221.238   963042.530    ops/s +\nr.PerfBaseline.observableConsumption              1000  thrpt         5    244097.704     4564.965    ops/s =\nr.PerfBaseline.observableConsumption           1000000  thrpt         5       256.587        5.404    ops/s =\nr.PerfBaseline.observableConsumptionUnsafe           1  thrpt         5 206453075.285  4940138.228    ops/s =\nr.PerfBaseline.observableConsumptionUnsafe        1000  thrpt         5    320284.165     6034.968    ops/s =\nr.PerfBaseline.observableConsumptionUnsafe     1000000  thrpt         5       314.259        7.683    ops/s =\nr.PerfBaseline.observableViaRange                    1  thrpt         5  37486671.210   887127.291    ops/s ++\nr.PerfBaseline.observableViaRange                 1000  thrpt         5    172643.588     7439.349    ops/s -\nr.PerfBaseline.observableViaRange              1000000  thrpt         5       173.171        2.794    ops/s -\nr.PerfBaseline.observableViaRangeUnsafe              1  thrpt         5 236013059.425  7822030.114    ops/s +++\nr.PerfBaseline.observableViaRangeUnsafe           1000  thrpt         5    211461.722    13717.277    ops/s -\nr.PerfBaseline.observableViaRangeUnsafe        1000000  thrpt         5       202.761       12.915    ops/s -\n\n\n\n-------------- ../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 2 .*rx.operators.OperatorMapPerf.*'\n\n------- 0.19\n\nBenchmark                                 (size)   Mode   Samples        Score  Score error    Units\nr.o.OperatorMapPerf.mapPassThru                1  thrpt         5 17853002.462   556655.574    ops/s \nr.o.OperatorMapPerf.mapPassThru             1000  thrpt         5   150669.958    16170.385    ops/s\nr.o.OperatorMapPerf.mapPassThru          1000000  thrpt         5      162.473        3.961    ops/s\nr.o.OperatorMapPerf.mapPassThruViaLift         1  thrpt         5 18947641.742   644348.550    ops/s\nr.o.OperatorMapPerf.mapPassThruViaLift      1000  thrpt         5   160047.002    20086.976    ops/s\nr.o.OperatorMapPerf.mapPassThruViaLift   1000000  thrpt         5      162.310        6.204    ops/s\n\n\n------- backpressure-8\n\nBenchmark                                 (size)   Mode   Samples        Score  Score error    Units\nr.o.OperatorMapPerf.mapPassThru                1  thrpt         5 24092718.114   586172.216    ops/s ++\nr.o.OperatorMapPerf.mapPassThru             1000  thrpt         5   149191.341     3154.653    ops/s -\nr.o.OperatorMapPerf.mapPassThru          1000000  thrpt         5      150.013        3.124    ops/s -\nr.o.OperatorMapPerf.mapPassThruViaLift         1  thrpt         5 26144219.306   368383.801    ops/s ++\nr.o.OperatorMapPerf.mapPassThruViaLift      1000  thrpt         5   150500.298     2074.296    ops/s - \nr.o.OperatorMapPerf.mapPassThruViaLift   1000000  thrpt         5      150.896        1.945    ops/s -\n\n\n\n\n\n-------------- ../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 2 .*rx.operators.OperatorObserveOnPerf.*'\n\n------- 0.19\n\nBenchmark                                         (size)   Mode   Samples        Score  Score error    Units\nr.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5   110481.792      991.073    ops/s\nr.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5     8386.714      103.294    ops/s\nr.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5        8.568        4.330    ops/s\nr.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5 13144808.808   852878.900    ops/s\nr.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5   191230.661     4066.226    ops/s\nr.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5      186.919        6.075    ops/s\nr.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5    15972.029     1955.679    ops/s\nr.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5     6606.316      104.860    ops/s\nr.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5       10.683        2.060    ops/s\n\n\n------- backpressure-8\n\nBenchmark                                         (size)   Mode   Samples        Score  Score error    Units\nr.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5    93371.544    12564.954    ops/s\nr.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5     5209.287      161.070    ops/s\nr.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5       10.070        5.387    ops/s\nr.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5 15855354.194    74122.090    ops/s\nr.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5   173351.676     5924.790    ops/s\nr.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5      170.760        4.379    ops/s\nr.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5    15524.785     1373.757    ops/s\nr.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5     4878.633       54.696    ops/s\nr.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5       15.285        0.564    ops/s\n\n\n\n\n\n\n-------------- ../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 2 .*rx.operators.OperatorMergePerf.*'\n\n------- 0.19\n\n\nBenchmark                                          (size)   Mode   Samples        Score  Score error    Units\nr.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  3047431.417    33607.539    ops/s\nr.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    70708.027     2468.027    ops/s\nr.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       70.950        3.242    ops/s\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5   106426.955     3921.743    ops/s\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        7.645        0.409    ops/s\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  2924643.167    90602.452    ops/s\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5    65041.997     4387.032    ops/s\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5     6727.579      140.162    ops/s\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  2923542.700    55565.638    ops/s\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       71.998        1.992    ops/s\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    80321.863    19568.569    ops/s\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     3832.958      236.712    ops/s\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  2927868.656   517769.910    ops/s\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5     6799.933      180.123    ops/s\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5        6.408        0.206    ops/s\n\n\n\n------- backpressure-8\n\nBenchmark                                          (size)   Mode   Samples        Score  Score error    Units\nr.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5475300.198   156741.334    ops/s\nr.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    68932.278     1311.023    ops/s\nr.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       64.405        0.611    ops/s\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5   102736.219     2948.102    ops/s\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        5.893        0.278    ops/s xxxxx\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4941243.788   109965.809    ops/s\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   368061.743    11456.008    ops/s\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    38941.345     1974.002    ops/s\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  6070127.935    58505.579    ops/s\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       57.002        1.708    ops/s\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    77911.340     2413.596    ops/s\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     4258.650      116.595    ops/s\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  5429881.489    26728.872    ops/s\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    28932.279      572.963    ops/s\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       30.147        1.253    ops/s\n\n\n\n\n-------------- ../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 2 .*rx.operators.OperatorFlatMapPerf.*'\n\n------- 0.19\n\nBenchmark                                          (size)   Mode   Samples        Score  Score error    Units\nr.o.OperatorFlatMapPerf.flatMapIntPassthruAsync         1  thrpt         5   352212.163    24668.380    ops/s\nr.o.OperatorFlatMapPerf.flatMapIntPassthruAsync      1000  thrpt         5      350.930        8.635    ops/s\nr.o.OperatorFlatMapPerf.flatMapIntPassthruAsync   1000000  thrpt         5        0.352        0.010    ops/s\nr.o.OperatorFlatMapPerf.flatMapIntPassthruSync          1  thrpt         5  3323839.174    38716.562    ops/s\nr.o.OperatorFlatMapPerf.flatMapIntPassthruSync       1000  thrpt         5     6456.484     1262.577    ops/s\nr.o.OperatorFlatMapPerf.flatMapIntPassthruSync    1000000  thrpt         5        6.337        0.149    ops/s\nr.o.OperatorFlatMapPerf.flatMapTwoNestedSync            1  thrpt         5  2117425.124    45292.911    ops/s\nr.o.OperatorFlatMapPerf.flatMapTwoNestedSync         1000  thrpt         5    35047.747      637.443    ops/s\nr.o.OperatorFlatMapPerf.flatMapTwoNestedSync      1000000  thrpt         5       35.408        1.304    ops/s\n\n\n\n------- backpressure-8\n\nBenchmark                                          (size)   Mode   Samples        Score  Score error    Units\nr.o.OperatorFlatMapPerf.flatMapIntPassthruAsync         1  thrpt         5   307489.156    24595.370    ops/s -\nr.o.OperatorFlatMapPerf.flatMapIntPassthruAsync      1000  thrpt         5      315.122       79.497    ops/s -\nr.o.OperatorFlatMapPerf.flatMapIntPassthruAsync   1000000  thrpt         5      305.585       33.345    ops/s +++ (why is this better?)\nr.o.OperatorFlatMapPerf.flatMapIntPassthruSync          1  thrpt         5  5932020.586   123609.972    ops/s ++\nr.o.OperatorFlatMapPerf.flatMapIntPassthruSync       1000  thrpt         5    26402.347     4096.510    ops/s +++\nr.o.OperatorFlatMapPerf.flatMapIntPassthruSync    1000000  thrpt         5       29.338        5.235    ops/s +++\nr.o.OperatorFlatMapPerf.flatMapTwoNestedSync            1  thrpt         5  3843959.776   204899.691    ops/s ++\nr.o.OperatorFlatMapPerf.flatMapTwoNestedSync         1000  thrpt         5    29316.657      446.403    ops/s ++\nr.o.OperatorFlatMapPerf.flatMapTwoNestedSync      1000000  thrpt         5       32.767        0.754    ops/s -\n```", "NaN"], ["1406", "Kotlin M8", "Mario Arias", "MarioAriasC", "07/07/14, 04:58:37 PM", "- Update to Kotlin milestone 8, \n- Some reformat on test \n- Replacing deprecated method calls ", "NaN"], ["1409", "Avoiding OperatorObserveOn from calling subscriber.onNext(..) after unsu...", "David Marques", "dpsm", "07/07/14, 06:54:01 PM", "...bscribe().\n\nThe OperatorObserveOn operator uses a scheduler to cancel subscriptions as well\nas to deliver the objects passing through it's onNext(..) in the right context.\n\nCalling unsubscribe will schedule the actual unsubscription while not making sure\nthat the child subscriber will no longer receive calls to onNext(..) after\nunsubscribe() returns.\n\nThis fix makes sure that after unsubscribe() returns no more onNext(..) calls will be\nmade on the child subscribers.\n\nSigned-off-by: David Marques dpsmarques@gmail.com", "NaN"], ["1412", "Backpressure & 0.20.0-RC1", "Ben Christensen", "benjchristensen", "07/08/14, 12:05:21 AM", "This is a functioning implementation of backpressure. Of the major unbounded queue operators in 0.19, this implements `observeOn` and `merge` but not yet `zip`. \n### New Signatures\n\n``` java\npublic interface Producer {\n    public void request(int n);\n}\n```\n\n``` java\npublic abstract class Subscriber<T> implements Observer<T>, Subscription {\n\n    /**\n     * Optionally called from `Observable.OnSubscribe`.\n     */\n    public final void setProducer(Producer producer);\n\n    /**\n     * Allow implementing classes to capture, decorate or override the `Producer` without affecting the `Subscriber` logic.\n     */\n    protected Producer onSetProducer(Producer producer);\n\n    public final void request(int n);\n}\n```", "NaN"], ["1413", "Switch build to Gradle 1.9", "G\u00e1bor Lipt\u00e1k", "gliptak", "07/21/14, 04:53:09 PM", "NaN", "NaN"], ["1414", "Merge Fixes", "Ben Christensen", "benjchristensen", "07/08/14, 05:47:28 AM", "A handful of fixes, particularly one that could cause non-deterministic missing data.", "NaN"], ["1417", "Proposal: Subscriber.onStart", "Ben Christensen", "benjchristensen", "07/08/14, 10:46:52 PM", "This is a proposal derived from conversations with @headinthebox to use `Subscriber.onStart` rather than constructor overloads as the mechanism for allowing `request(n)` to be called to operationally start backpressure (or do anything else at the start of a stream).\n\nThe idea is that it is at the start the same as `onError` or `onCompleted` are terminal events. It will always be called.\n\nUsage for subscribing is like this:\n\n``` java\n        Observable.from(1, 2, 3, 4).take(2).subscribe(new Subscriber<Integer>() {\n\n            @Override\n            public void onStart() {\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Integer t) {\n                System.out.println(t);\n                request(1);\n            }\n\n        });\n```\n\nor when writing an `Operator` via `lift`:\n\n``` java\n        Observable.from(1, 2, 3, 4).lift(new Operator<Integer, Integer>() {\n\n            @Override\n            public Subscriber<? super Integer> call(final Subscriber<? super Integer> child) {\n                return new Subscriber<Integer>() {\n\n                    @Override\n                    public void onStart() {\n                        request(1);\n                    }\n\n                    @Override\n                    public void onCompleted() {\n                        child.onCompleted();\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        child.onError(e);\n                    }\n\n                    @Override\n                    public void onNext(Integer t) {\n                        System.out.println(t);\n                        child.onNext(t);\n                        request(1);\n                    }\n\n                };\n            }\n\n        }).subscribe();\n```\n\nBoth of these examples are requesting 1 item at a time.", "NaN"], ["1418", "Zip with backpressure support", "David Karnok", "akarnokd", "07/15/14, 03:09:52 PM", "If I understand the backpressure correctly, zip with backpressure is relatively simple: if the client requests N items, it is forwarded to all sources because they would need to produce N events each in order to get N events zipped. Since N may vary, bounded buffering may not be feasible. \n\nIn addition, I'm not sure what type of typical backpressure tests should be written so I only included a simple one.\n\nI've also fixed the unsynchronized read of `requested` in `Subscriber.setProducer`.", "NaN"], ["1421", "Range backpressure concurrency & off-by-one bugfix", "David Karnok", "akarnokd", "07/10/14, 04:06:04 PM", "Bugs/deficiencies fixed:\n- reading of the volatile `requested` multiple times\n- `numLeft` calculated incorrectly if `start` was not 0\n- since `end` is an absolute index and `index` goes up to it, there is no need for `start`\n- `index` gets only updated by a single thread thanks to the barriers provided by the atomic `REQUESTED` updater, there is no need for volatile.\n- `numLeft` calculated incorrectly since `end` is an inclusive end index, thus the remaining count is +1\n- `completeOnFinish` was false if the exact remaining amount is requested.", "NaN"], ["1422", "Concurrency Fixes for RxRingBuffer & Merge", "Ben Christensen", "benjchristensen", "07/10/14, 10:04:23 PM", "Possible fix for #1420\n\nI was unable to exactly reproduce the issue, but was able to create a possibly related one. This fixes it.\nIt also simplifies the logic and code somewhat, at a possible small performance cost for these:\n\n```\nr.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    59407.716     2073.945    ops/s\nr.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       66.557        2.693    ops/s\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       59.293        5.046    ops/s\n```", "NaN"], ["1423", "Changed producer interface to work with long instead of int", "Aubrey Tull", "stealthcode", "07/11/14, 02:42:05 AM", "Changing `int` to `long` in `Producer` implementations. ", "NaN"], ["1428", "Simplify creation of single thread used by event loop based Schedulers", "Joakim Bodin", "jbripley", "07/22/14, 09:49:05 AM", "Removes overhead of using a ScheduledThreadPool for the single thread used by the event loop based Schedulers. Explicitly creates a single thread and uses a minimal queue implementation so that execution of scheduled actions are serialized.\n\nI've seen some spurious unit tests failures that I'm unable to reproduce, so a code review to point any concurrency issues would be much appreciated.\n\nAlso, if someone could point me to which JMH benchmarks that would be relevant for this change and how to run them, I can post some numbers to see if this change is worthwhile.", "NaN"], ["1430", "Unneeded Variance Cleanup", null, "headinthebox", "07/11/14, 04:27:59 PM", "Removed unneeded variance and replaced a few type variables in result types that don't matter with Any.\n\nUsed `@uncheckedVariance` in one place that I think is safe and correspond better with Java signature. which also just takes a `T`.\n\n```\ndef publish[R](selector: Observable[T] => Observable[R], initialValue: T @uncheckedVariance): Observable[R]\nublic final <R> Observable<R> publish(Func1<? super Observable<T>, ? extends Observable<R>> selector, final T initialValue) {\n```\n\n[Aside: Is the `class CompletenessTest extends JUnitSuite` useful, not for me at least, it requires too much manual messing around, and I am never sure what to change (and why)]", "NaN"], ["1431", "CompositeException fix for Android", "Tomasz Rozbicki", "tomrozb", "07/21/14, 11:22:07 PM", "Fixes #1405\n- revert changes from f4ae92aa\n- remove duplicated causes in stack trace chain", "NaN"], ["1432", "Remove variance, try 2", null, "headinthebox", "07/11/14, 04:33:29 PM", "Removed unneeded variance and replaced a few type variables in result types that don't matter with Any.\n\nUsed `@uncheckedVariance` in one place that I think is safe and correspond better with Java signature. which also just takes a `T`.\n\n```\ndef publish[R](selector: Observable[T] => Observable[R], initialValue: T @uncheckedVariance): Observable[R]\nublic final <R> Observable<R> publish(Func1<? super Observable<T>, ? extends Observable<R>> selector, final T initialValue) {\n```", "NaN"], ["1433", "Take 3", null, "headinthebox", "07/11/14, 04:49:56 PM", "Removed unneeded variance and replaced a few type variables in result types that don't matter with Any.\n\nUsed `@uncheckedVariance` in one place that I think is safe and correspond better with Java signature. which also just takes a `T`.\n\n```\ndef publish[R](selector: Observable[T] => Observable[R], initialValue: T @uncheckedVariance): Observable[R]\nublic final <R> Observable<R> publish(Func1<? super Observable<T>, ? extends Observable<R>> selector, final T initialValue) {\n```", "NaN"], ["1435", "Don't use postdelayed if already on right looper", "Aleksei Zakharov", "lexer", "07/25/14, 08:53:05 PM", "There is no need to do postDelayed if we are on the right looper already and no delay needed.\n\nFix is required because for some UI scenarios postDelayed latency is not acceptable. \n\nI don't know how to write test for this case. Let me know if have an idea and I will add it.\n\n@loganj @akarnokd @benjchristensen", "NaN"], ["1436", "Correct warnings", "G\u00e1bor Lipt\u00e1k", "gliptak", "07/21/14, 04:39:26 PM", "NaN", "NaN"], ["1437", "Allow us to make custom Scheduler", "Y. H. Lai", "yhlai-code", "07/21/14, 04:37:14 PM", "If someone wants to extend `Scheduler` he needs to override `asJavaScheduler`, but it's very tedious due to the `private [scala] val` declaration. In RxJava it's pretty easy to make custom Scheduler. In my opinion RxScala shouldn't prevent people doing so.", "NaN"], ["1442", "Merge Bug", "Ben Christensen", "benjchristensen", "07/15/14, 05:01:23 AM", "Working on https://github.com/Netflix/RxJava/issues/1420\n\nIn testing on prod this looks like it may solve it .... running longer term tests to confirm.", "NaN"], ["1443", "Infinite request with Long.MAX_VALUE instead of -1", "Ben Christensen", "benjchristensen", "07/15/14, 05:31:14 AM", "Migrating to this after discussions at https://github.com/reactive-streams/reactive-streams/issues/62", "NaN"], ["1446", "Zip with Backpressure Support", "Ben Christensen", "benjchristensen", "07/17/14, 07:51:49 PM", "This supports both upstream and downstream backpressure.", "NaN"], ["1448", "RxScala: Add Scala idiomatic methods", "Shixiong Zhu", "zsxwing", "07/16/14, 02:50:00 PM", "For #523\n\n/cc @headinthebox, @samuelgruetter", "NaN"], ["1449", "Add operators to create Observables from BroadcastReceiver", "Yaroslav", "Yarikx", "07/29/14, 10:42:12 AM", "wraps BroadcastReceiver with Observable. Can be used with gloabl broadcasts and with local (using LocalBroadcastManager)", "NaN"], ["1452", "Removing onStart and onSetProducer from rx.Subscriber...", "George Campbell", "abersnaze", "07/17/14, 07:47:58 PM", "...because they are unnecessary and it can't be undone once it is released.  The `rx.Subscriber` is part of the public API and these methods aren't really needed for the Rx to work.", "NaN"], ["1453", "New test case for takeWhile that currently fails", null, "spodila", "07/17/14, 08:05:45 PM", "Created a test case to verify the failing case of takeWhile() followed by toList() as mentioned in <a href=\"https://github.com/Netflix/RxJava/issues/1451\">Issue 1451</a>.", "NaN"], ["1454", "Fix issue #1451", "Shixiong Zhu", "zsxwing", "07/17/14, 08:05:37 PM", "Add `done` to make sure calling `doOnEachObserver` obey the Rx contract.", "NaN"], ["1456", "Removing onSetProducer from the API", "George Campbell", "abersnaze", "07/17/14, 09:35:07 PM", "NaN", "NaN"], ["1457", "MergeDelayError & OnErrorFlatMap w/ Merge", "Ben Christensen", "benjchristensen", "07/17/14, 09:07:31 PM", "NaN", "NaN"], ["1458", "Remove Pivot Operator", "Ben Christensen", "benjchristensen", "07/17/14, 09:29:48 PM", "as per https://github.com/Netflix/RxJava/issues/1402", "NaN"], ["1459", "Remove Subscriber.onSetProducer", "Ben Christensen", "benjchristensen", "07/17/14, 09:35:06 PM", "This is a manual merge of https://github.com/Netflix/RxJava/pull/1456\n\nRemoves the awkward `Subscriber.onSetProducer` API and makes `Subscriber.request` protected so it can't easily be misused.", "NaN"], ["1460", "Change Java future observable implementation from blocking to non blocking", null, "tbak", "08/19/14, 03:52:30 AM", "NaN", "NaN"], ["1462", "Merge Perf Fix: Re-enable fast-path", "Ben Christensen", "benjchristensen", "07/18/14, 12:43:40 AM", "Fixes https://github.com/Netflix/RxJava/issues/1461", "NaN"], ["1463", "Merge Bug: Missing Emissions", "Ben Christensen", "benjchristensen", "07/18/14, 05:02:17 PM", "Notes and temporary fix using `synchronized` to achieve correctness until a proper solution can be found.\n\nThis code does not exhibit the issue when I do production testing. Without the two `synchronized` methods I get errors in prod that I've temporarily added to `BlockingOperatorToIterator` until this is fixed so it's visible.\n\n```\n/apps/tomcat/logs$ tail -f catalina.out |grep \"Timed out waiting for value\"\nTimed out waiting for value. File a bug at github.com/Netflix/RxJava\nTimed out waiting for value. File a bug at github.com/Netflix/RxJava\nTimed out waiting for value. File a bug at github.com/Netflix/RxJava\nTimed out waiting for value. File a bug at github.com/Netflix/RxJava\nTimed out waiting for value. File a bug at github.com/Netflix/RxJava\nTimed out waiting for value. File a bug at github.com/Netflix/RxJava\nTimed out waiting for value. File a bug at github.com/Netflix/RxJava\nTimed out waiting for value. File a bug at github.com/Netflix/RxJava\nTimed out waiting for value. File a bug at github.com/Netflix/RxJava\nTimed out waiting for value. File a bug at github.com/Netflix/RxJava\nTimed out waiting for value. File a bug at github.com/Netflix/RxJava\nTimed out waiting for value. File a bug at github.com/Netflix/RxJava\nTimed out waiting for value. File a bug at github.com/Netflix/RxJava\nTimed out waiting for value. File a bug at github.com/Netflix/RxJava\nTimed out waiting for value. File a bug at github.com/Netflix/RxJava\nTimed out waiting for value. File a bug at github.com/Netflix/RxJava\nTimed out waiting for value. File a bug at github.com/Netflix/RxJava\n```", "NaN"], ["1467", "Javadocs for cache operator", "Ben Christensen", "benjchristensen", "07/22/14, 05:27:49 AM", "NaN", "NaN"], ["1468", "RxScala: Update CompletenessTest.scala", "Shixiong Zhu", "zsxwing", "07/28/14, 07:09:14 PM", "Cleaned up `CompletenessTest.scala`.\n\n`onBackpressureBuffer` and `onBackpressureDrop` are missing in RxScala now. Wait until they are finalized in RxJava.\n\n/cc @headinthebox, @samuelgruetter", "NaN"], ["1469", "ToList operator needs to ignore backpressure", "Matt Jacobs", "mattrjacobs", "07/22/14, 07:13:50 PM", "NaN", "NaN"], ["1470", "retryWhen/repeatWhen", "George Campbell", "abersnaze", "07/23/14, 05:37:37 PM", "Rebase and clean up of #1326 while Aaron is at LambdaJam.", "NaN"], ["1471", "OperatorAny needs to ignore backpressure", "Matt Jacobs", "mattrjacobs", "07/22/14, 08:44:53 PM", "NaN", "NaN"], ["1472", "Add test of backpressure to OperatorAll", "Matt Jacobs", "mattrjacobs", "07/22/14, 08:46:07 PM", "NaN", "NaN"], ["1473", "OperatorAny needs to handle backpressure", "Matt Jacobs", "mattrjacobs", "07/22/14, 09:01:56 PM", "NaN", "NaN"], ["1474", "Ignore backpressure for OperatorToObservableSortedList", "Matt Jacobs", "mattrjacobs", "07/22/14, 09:24:24 PM", "NaN", "NaN"], ["1489", "Backpressure Fixes and Docs", "Ben Christensen", "benjchristensen", "07/23/14, 06:15:30 AM", "Docs for operators that don't support backpressure, particularly all the temporal operators.\n\nFixes for several that needed to request(1) or request(Long.MAX_VALUE).", "NaN"], ["1490", "non-deterministic timeouts on slow machines", "Ben Christensen", "benjchristensen", "07/23/14, 06:32:00 AM", "NaN", "NaN"], ["1491", "Concat Outer Backpressure", "Ben Christensen", "benjchristensen", "07/23/14, 06:50:50 AM", "Fixed https://github.com/Netflix/RxJava/issues/1481", "NaN"], ["1493", "Manual merge of retryWhen/repeatWhen", "Ben Christensen", "benjchristensen", "07/23/14, 05:37:24 PM", "Manual merge and rebase of https://github.com/Netflix/RxJava/pull/1470", "NaN"], ["1494", "zipWith", "Ben Christensen", "benjchristensen", "07/23/14, 05:41:22 PM", "Match the naming convention of `mergeWith`, `concatWith`, `ambWith` etc.", "NaN"], ["1495", "Upgrade to Quasar 0.6.0", "Ron Pressler", "pron", "07/23/14, 09:28:23 PM", "NaN", "NaN"], ["1496", "Change RxRingBuffer Queue Usage", "Ben Christensen", "benjchristensen", "07/23/14, 09:28:04 PM", "There are non-determinisitic failures in the `offer` behavior of the JCTools code that I don't understand yet, so reverting to `SynchronizedQueue` which does not show the problem. The performance hit is not huge, it's even better in some cases.\n\nThis should result in more object allocation though, so that needs to be tested (I'll do so along with Netflix production testing).", "NaN"], ["1497", "spsc ring buffer concurrency test", "Ben Christensen", "benjchristensen", "07/23/14, 10:56:30 PM", "NaN", "NaN"], ["1498", "non-deterministic testUserSubscriberUsingRequestAsync", "Ben Christensen", "benjchristensen", "07/23/14, 11:08:42 PM", "fix non-deterministic failures of BackpressureTests.testUserSubscriberUsingRequestAsync\n\nI was able to replicate the occasional failure by putting it in a tight loop. With these changes it no longer fails.", "NaN"], ["1499", "retrytest.iterativeBackoff", "Ben Christensen", "benjchristensen", "07/23/14, 11:25:04 PM", "Unable to replicate failure of this test ... but adding assertNoErrors so we can see an exception if it happens again.", "NaN"], ["1501", "blocking synchronous next", "Ben Christensen", "benjchristensen", "07/24/14, 07:54:59 AM", "Fixes https://github.com/Netflix/RxJava/issues/624", "NaN"], ["1504", "Eliminate duplication of List in toList", "Ben Christensen", "benjchristensen", "07/24/14, 07:54:46 AM", "Fixes https://github.com/Netflix/RxJava/issues/1218", "NaN"], ["1507", "BufferWithSize with Backpressure Support", "Shixiong Zhu", "zsxwing", "08/11/14, 10:19:11 PM", "For #1479", "NaN"], ["1513", "Revert to copying list in toList", "Ben Christensen", "benjchristensen", "07/24/14, 09:02:36 PM", "It is a breaking change to existing code to make it immutable, so reverting back to copying.", "NaN"], ["1514", "Provide a facility for decorating a Runnable before submission to ExecutorService via Scheduler", "Matt Jacobs", "mattrjacobs", "08/11/14, 10:13:54 PM", "For Issue #1279\n\nThis provides another method of hooking into the Scheduler process.  Rather than forcing the plugin writer to write all 3 Schedulers (computation/io/newThread) from scratch, it allows the plugin writer to have access to the Runnable before it gets submitted to the ExecutorService.\n\nIn my implementation which needs to decorate Runnables, this reduced the effort from a copy-n-paste of the entire Scheduler codebase to a 1-liner.\n\nHappy to debate names or any other aspect of this proposal", "NaN"], ["1515", "Support Subject Factory with Multicast", "Ben Christensen", "benjchristensen", "07/28/14, 04:10:19 PM", "This is a proposed change to allow using a `Subject` factory with `multicast` and for methods such as `publish()` and `replay()` to use the factory so that each time `ConnectableObservable.connect()` is invoked, a new `Subject` is created and used. Otherwise, an `Observable` sequence can not be reused.\n#### Use Case\n\n``` java\n        final AtomicInteger count = new AtomicInteger();\n        Observable<Integer> subject1 = Observable.just(10);\n        Observable<Integer> subject2 = Observable.just(20);\n        Observable<Integer> combined = Observable.combineLatest(subject1, subject2, (fst, snd) -> {\n            int i = count.incrementAndGet();\n            System.out.println((fst + i) + \" + \" + (snd + i));\n            return fst + snd;\n        }).publish().refCount();\n\n        combined.subscribe(\n                System.out::println,\n                t -> t.printStackTrace(),\n                () -> System.out.println(\"Completed\"));\n\n        combined.subscribe(\n                System.out::println,\n                t -> t.printStackTrace(),\n                () -> System.out.println(\"Completed\"));\n```\n\nOutput without these changes:\n\n```\n11 + 21\n30\nCompleted\nCompleted\n```\n\nOutput with changes:\n\n```\n11 + 21\n30\nCompleted\n12 + 22\n30\nCompleted\n```\n#### Test Case\n\n``` java\n    @Test\n    public void testConnectDisconnectConnectAndSubjectState() {\n        Observable<Integer> o1 = Observable.just(10);\n        Observable<Integer> o2 = Observable.just(20);\n        Observable<Integer> combined = Observable.combineLatest(o1, o2, new Func2<Integer, Integer, Integer>() {\n\n            @Override\n            public Integer call(Integer t1, Integer t2) {\n                return t1 + t2;\n            }\n\n        }).publish().refCount();\n\n        TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>();\n        TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>();\n\n        combined.subscribe(ts1);\n        combined.subscribe(ts2);\n\n        ts1.assertTerminalEvent();\n        ts1.assertNoErrors();\n        ts1.assertReceivedOnNext(Arrays.asList(30));\n\n        ts2.assertTerminalEvent();\n        ts2.assertNoErrors();\n        ts2.assertReceivedOnNext(Arrays.asList(30));\n    }\n```", "NaN"], ["1516", "Amb with backpressure support", "Shixiong Zhu", "zsxwing", "07/30/14, 04:32:47 PM", "For #1475", "NaN"], ["1518", "Fix typos in javadoc comments.", "Sean O'Neil", "SeanPONeil", "07/25/14, 09:12:18 PM", "\"Recieve\" -> \"Receive\"", "NaN"], ["1519", "Remove unused param comments", "Ben Christensen", "benjchristensen", "07/25/14, 08:32:16 PM", "Fixed https://github.com/Netflix/RxJava/issues/1426", "NaN"], ["1520", "Fix non-deterministic test", "Ben Christensen", "benjchristensen", "07/25/14, 08:39:51 PM", "Fixes https://github.com/Netflix/RxJava/issues/1429", "NaN"], ["1521", "Fix toIterator Exception Handling", "Ben Christensen", "benjchristensen", "07/25/14, 09:10:22 PM", "Fixes https://github.com/Netflix/RxJava/issues/1450", "NaN"], ["1523", "Fix issue #1522", "Shixiong Zhu", "zsxwing", "07/29/14, 04:27:26 PM", "`TakeLast` should ignore other `request`s if it's requested with `Long.MAX_VALUE`. #1522", "NaN"], ["1524", "Bump to Robolectric 2.3, make samples build under Studio 0.8.+", "Matthias K\u00e4ppler", "mttkay", "07/29/14, 04:30:39 PM", "This should help get https://github.com/Netflix/RxJava/pull/1449 off the ground", "NaN"], ["1526", "Restore use of SpmcArrayQueue in RxRingBuffer", "Ben Christensen", "benjchristensen", "07/29/14, 12:41:30 AM", "- Modification of SpmcArrayQueue with fix from https://github.com/JCTools/JCTools/issues/21\n  - I expect updates to this code over time but wanted to move forward with a working solution for now\n- Restore RxRingBuffer to use SpmcArrayQueue\n  - this reduces object allocation significantly and increases performance in some use cases\n### Performance Diff\n#### 0.20.0-RC3\n\n```\n../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 2 .*rx.internal.RxRingBufferPerf.*'\n\nBenchmark                                            Mode   Samples        Score  Score error    Units\nr.i.RxRingBufferPerf.spmcCreateUseAndDestroy1       thrpt         5 33224158.580   399867.898    ops/s\nr.i.RxRingBufferPerf.spmcCreateUseAndDestroy1000    thrpt         5    73346.934      853.989    ops/s\nr.i.RxRingBufferPerf.spmcRingBufferAddRemove1       thrpt         5 22034846.226   579563.777    ops/s\nr.i.RxRingBufferPerf.spmcRingBufferAddRemove1000    thrpt         5    21612.517      567.086    ops/s\nr.i.RxRingBufferPerf.spscCreateUseAndDestroy1       thrpt         5 32277699.473  2481022.929    ops/s\nr.i.RxRingBufferPerf.spscCreateUseAndDestroy1000    thrpt         5    72782.657     3836.229    ops/s\nr.i.RxRingBufferPerf.spscRingBufferAddRemove1       thrpt         5 21625427.399   555584.413    ops/s\nr.i.RxRingBufferPerf.spscRingBufferAddRemove1000    thrpt         5    21588.532      875.871    ops/s\n```\n\n```\n../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 2 .*rx.operators.OperatorMergePerf.*'\n\nBenchmark                                          (size)   Mode   Samples        Score  Score error    Units\nr.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5066495.356    73296.083    ops/s\nr.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    55094.237     1067.519    ops/s\nr.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       57.981        1.324    ops/s\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5    97273.839     9582.028    ops/s\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        4.754        0.115    ops/s\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4384357.616   302930.385    ops/s\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   278124.421    36626.222    ops/s\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    35179.120     1059.293    ops/s\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  5383548.483   125915.654    ops/s\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       54.551        3.245    ops/s\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    66546.808    30474.772    ops/s\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     2828.244      103.470    ops/s\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  5030721.519   181734.814    ops/s\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    24489.183      759.520    ops/s\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       30.101        0.802    ops/s\n```\n\nMemory allocation capture with Java Flight Recorder while executing:\n\n```\n../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 20 .*rx.operators.OperatorMergePerf.mergeNAsyncStreamsOfN.*'\n```\n\n![object-allocation-with-linkedlist](https://cloud.githubusercontent.com/assets/813492/3727745/35c44dca-16a1-11e4-89c1-7a1c2475bcbb.png)\n#### with JCTools impl\n\n```\n../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 2 .*rx.internal.RxRingBufferPerf.*'\n\nBenchmark                                            Mode   Samples        Score  Score error    Units\nr.i.RxRingBufferPerf.spmcCreateUseAndDestroy1       thrpt         5 27028267.871  2547216.752    ops/s\nr.i.RxRingBufferPerf.spmcCreateUseAndDestroy1000    thrpt         5    78238.446     2539.165    ops/s\nr.i.RxRingBufferPerf.spmcRingBufferAddRemove1       thrpt         5 43396574.546   918454.062    ops/s\nr.i.RxRingBufferPerf.spmcRingBufferAddRemove1000    thrpt         5    64074.506      531.873    ops/s\nr.i.RxRingBufferPerf.spscCreateUseAndDestroy1       thrpt         5 27163028.506   506868.149    ops/s\nr.i.RxRingBufferPerf.spscCreateUseAndDestroy1000    thrpt         5    77472.474     2875.597    ops/s\nr.i.RxRingBufferPerf.spscRingBufferAddRemove1       thrpt         5 43309504.983   337590.502    ops/s\nr.i.RxRingBufferPerf.spscRingBufferAddRemove1000    thrpt         5    64140.916     1292.265    ops/s\n```\n\n```\n../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 2 .*rx.operators.OperatorMergePerf.*'\n\nBenchmark                                          (size)   Mode   Samples        Score  Score error    Units\nr.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5146417.279   168011.480    ops/s\nr.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    56640.224      789.709    ops/s\nr.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       60.610        1.022    ops/s\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5    97759.963     1897.592    ops/s\nr.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        5.937        0.404    ops/s\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4511685.053   136414.240    ops/s\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   285644.030     9325.626    ops/s\nr.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    32789.901     1143.208    ops/s\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  5415231.898   107538.428    ops/s\nr.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       55.918        0.660    ops/s\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    74341.892     3274.847    ops/s\nr.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     4138.087      329.935    ops/s\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  5026384.994   242183.595    ops/s\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    24700.473      334.516    ops/s\nr.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       30.458        0.603    ops/s\n```\n\nMemory allocation capture with Java Flight Recorder while executing:\n\n```\n../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 20 .*rx.operators.OperatorMergePerf.mergeNAsyncStreamsOfN.*'\n```\n\n![object-allocation-with-arrayqueue](https://cloud.githubusercontent.com/assets/813492/3727746/38de2d8c-16a1-11e4-93cd-32dba4497a5f.png)", "NaN"], ["1527", "Failing unit test for reduce, showing it does not implement backpressure correctly", "Matt Jacobs", "mattrjacobs", "07/29/14, 04:40:10 PM", "NaN", "NaN"], ["1528", "Add operators to create Observables from BroadcastReceiver (rebased)", "Yaroslav", "Yarikx", "07/29/14, 04:30:37 PM", "Rebase https://github.com/Netflix/RxJava/pull/1449 on the top of https://github.com/Netflix/RxJava/pull/1524\n\nAdd test for OperatorBroadcastRegister", "NaN"], ["1529", "Make \"single\"  support backpressure (Fix #1527)", "Shixiong Zhu", "zsxwing", "07/29/14, 02:11:45 PM", "Fix #1527", "NaN"], ["1530", "Fix the unbounded check for merge", "Shixiong Zhu", "zsxwing", "07/29/14, 04:19:26 PM", "NaN", "NaN"], ["1532", "Added unit tests of backpressure to OperatorReduce", "Matt Jacobs", "mattrjacobs", "07/29/14, 04:49:21 PM", "Replaced PR #1527", "NaN"], ["1533", "Amb + Backpressure", "Ben Christensen", "benjchristensen", "07/30/14, 04:31:18 PM", "Building on top of https://github.com/Netflix/RxJava/pull/1516", "NaN"], ["1534", "Concat Backpressure", "Ben Christensen", "benjchristensen", "07/30/14, 04:33:07 PM", "Route backpressure through the inner subscribers.\nFixes https://github.com/Netflix/RxJava/issues/1480", "NaN"], ["1537", "recursive scheduling in RxScala", "Georgi Khomeriki", "flatmap13", "08/08/14, 08:52:27 PM", "This PR adds a `scheduleRec` method to the `Scheduler.Worker` trait to make recursive scheduling more convenient in Scala. This issue is raised in #1348.", "NaN"], ["1540", "BufferWithSize backpressure", "Dave Moten", "davidmoten", "08/01/14, 04:26:55 AM", "Added backpressure handling to `OperatorBufferWithSize`. \n\nThis was required because requesting 1 item (a list) from an `OperatorBufferWithSize`  subscriber translates to requesting `count + (n-1) * skip` items from upstream.\n\nIncludes unit tests that failed with 0.20.0-RC4.", "NaN"], ["1545", "Make Android ViewObservable.input observe TextView instead of String", "Ron Shapiro", "ronshapiro", "08/14/14, 09:44:36 PM", "The previous version required `ViewObservable.input(TextView, boolean)` to emit just `String`s of the updated text, but not `CharSequence`s, which is the declared implementation of `TextView`'s `mText`. This still allows for similar functionality as before via: \n\n``` java\nViewObservable.input(myTextView, false).map((textView) -> textView.getText().toString())\n```\n\nIt is also flexible like `ViewObservable.clicks` in that it returns a reference to the `View`, which should make it more flexible for using it with other reactive methods.\n\nI held off from doing the same to `ViewObservable.input(CompoundButton, boolean)` but could do so if you think it would be valuable/more consistent.\n\nThis would be a breaking change. In order to make it not a breaking change, this method could be renamed and the initial method could `map` like the above snippet. Let me know if you think this is important and I'd be happy to make this change.", "NaN"], ["1548", "Adding backpressure to OnSubscribeRedo", "Aubrey Tull", "stealthcode", "08/11/14, 10:04:50 PM", "NaN", "NaN"], ["1552", "Fixing a bug and a potential for other concurrency issues.", "George Campbell", "abersnaze", "08/08/14, 04:54:21 AM", "Fix for #1542.\n\nthe root cause of the issue was this line of code where it was casting the notification list object to T.\n\n```\n        private T getRecentValue() {\n            return (T)value;\n        }\n```\n\nWhile I was in there I noticed that is was a race condition between calling `hasNext()` and `next()` on the `Iterator`.", "NaN"], ["1555", "RxScala: Add retryWhen/repeatWhen methods", "Joakim Bodin", "jbripley", "08/08/14, 04:53:05 AM", "- Add example usage of retryWhen/repeatWhen to RxScalaDemo", "NaN"], ["1557", "SwitchOnNext with backpressure support", "Shixiong Zhu", "zsxwing", "08/11/14, 10:12:47 PM", "#1482", "NaN"], ["1558", "mergeMap generics", "Ben Christensen", "benjchristensen", "08/08/14, 07:02:44 PM", "Fixes issue #1550", "NaN"], ["1559", "More consistent hooks for scheduler plugins.  This is a rework of #1514.", "Matt Jacobs", "mattrjacobs", "08/11/14, 09:18:44 PM", "- Deprecated RxJavaDefaultSchedulers and RxJavaDefaultSchedulersDefault (I think these names are confusing)\n- Added RxJavaSchedulersHook\n- Ability to override entire schedulers from scratch\n- Ability to decorate Action0 before submission to Scheduler\n\nThe main change from #1514 is the decoration of Action0 instead of Runnable.  Action0 is an improvement as all Schedulers must handle these, whereas not all Schedulers handle Runnables.", "NaN"], ["1560", "flatMap overloads", "Ben Christensen", "benjchristensen", "08/08/14, 07:32:55 PM", "- migrate mapPair to use actual merge instead of reimplementing it\n- deprecate mergeMap\n\nDone during API review with @headinthebox", "NaN"], ["1561", "Remove Variance on Defer", "Ben Christensen", "benjchristensen", "08/08/14, 10:01:18 PM", "See https://github.com/Netflix/RxJava/issues/1157 for painful background.", "NaN"], ["1562", "TakeLastTimed with backpressure support", "Shixiong Zhu", "zsxwing", "08/11/14, 10:09:59 PM", "Implemented #1488. I moved `OperatorTakeLast.QueueProducer` to `TakeLastQueueProducer` to reuse it.", "NaN"], ["1564", "RxScala: Fix errors in Completeness.scala and also improve it", "Shixiong Zhu", "zsxwing", "08/11/14, 10:07:00 PM", "- Fixed some errors in CompletenessTest.scala and improve it.\n- Fixed the error of `defer` for #1561\n\n/cc @headinthebox, @samuelgruetter", "NaN"], ["1565", "Fixing Kotlin Defer", "Ben Christensen", "benjchristensen", "08/12/14, 12:33:20 AM", "Broke this with https://github.com/Netflix/RxJava/pull/1561", "NaN"], ["1567", "groupBy with element selector", "Ben Christensen", "benjchristensen", "08/12/14, 04:11:12 AM", "Fixes https://github.com/Netflix/RxJava/issues/1554", "NaN"], ["1568", "Compose/Transformer", "Ben Christensen", "benjchristensen", "08/12/14, 05:20:20 AM", "See https://github.com/Netflix/RxJava/issues/1416 for discussion that led to this.\n\nThis does not have co/contra-variance which needs to be figured out.", "NaN"], ["1569", "Compose/Transform Covariance", "Ben Christensen", "benjchristensen", "08/14/14, 05:54:09 AM", "Failing test while exploring generic variance for https://github.com/Netflix/RxJava/issues/1416\n\nCode like this makes these generics work:\n\n``` java\n    @Test\n    public void testCovarianceOfCompose() {\n        Observable<HorrorMovie> movie = Observable.<HorrorMovie> from(new HorrorMovie());\n        movie.compose(new Transformer<Movie, Movie>() {\n\n            @Override\n            public Observable<? extends Movie> call(Observable<? super Movie> t1) {\n                return Observable.from(new Movie());\n            }\n\n        });\n    }\n\n    @Test\n    public void testCovarianceOfCompose2() {\n        Observable<Movie> movie = Observable.<Movie> from(new HorrorMovie());\n        movie.compose(new Transformer<Movie, Movie>() {\n\n            @Override\n            public Observable<? extends Movie> call(Observable<? super Movie> t1) {\n                return Observable.from(new HorrorMovie());\n            }\n\n        });\n    }\n```\n\nhowever, I couldn't get the `compose`/`Transformer` types to correctly work.\n\nAnyone else want to help figure out generics for this?\n\nSee https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L195", "NaN"], ["1570", "Fix for mapcat, issue #1556", "Dave Ray", "daveray", "08/12/14, 03:52:09 PM", "Corrected mapcat to actually concat its results rather than merging.\nAdded warning to docstring thta this might not be ideal.\n\nAdded flatmap to cover map+merge case.", "NaN"], ["1572", "Remove Timeout in Blocking Iterator", "Ben Christensen", "benjchristensen", "08/12/14, 06:54:36 PM", "This was a temporary timeout to track down bugs.", "NaN"], ["1573", "Backpressure: parallel", "Ben Christensen", "benjchristensen", "08/12/14, 07:36:38 PM", "Fixes https://github.com/Netflix/RxJava/issues/1485", "NaN"], ["1575", "combineLatest with backpressure", "Ben Christensen", "benjchristensen", "08/14/14, 05:29:23 AM", "Implementation updated to support reactive pull: https://github.com/Netflix/RxJava/issues/1476", "NaN"], ["1576", "from(T) -> just(T)", "Ben Christensen", "benjchristensen", "08/14/14, 09:41:10 PM", "Deprecate the from(T) methods in favor of items(T)\n\nAs per discussion in https://github.com/Netflix/RxJava/issues/1563.", "NaN"], ["1577", "Fix the compose covariance", "Shixiong Zhu", "zsxwing", "08/14/14, 04:52:14 PM", "Changed the return type of `compose` from `Observable<? extends R>` to `Observable<R>`. The reason is that if returning `Observable<? extends R>`, the following codes won't work in Java:\n\n``` Java\n        Observable<String> o1 = Observable.from(\"s1\");\n        Observable<String> o2 = o1.compose(new Transformer<String, String>() {\n            @Override\n            public Observable<? extends String> call(Observable<? extends String> t1) {\n                return Observable.from(\"s2\");\n            }\n        });\n```\n\nwe have to write:\n\n``` Java\n        Observable<String> o1 = Observable.from(\"s1\");\n        Observable<? extends String> o2 = o1.compose(new Transformer<String, String>() {\n            @Override\n            public Observable<? extends String> call(Observable<? extends String> t1) {\n                return Observable.from(\"s2\");\n            }\n        });\n```\n\nBecause we cannot assign `Observable<? extends R>` to a `Observable<R>` variable, we should avoid to return `Observable<? extends R>`, otherwise the API will be inconvenient.", "NaN"], ["1581", "zip(Iterable) -> zipWith(Iterable)", "Ben Christensen", "benjchristensen", "08/14/14, 06:28:02 PM", "As per https://github.com/Netflix/RxJava/issues/1578", "NaN"], ["1582", "Deprecate GroupedObservable.from", "Ben Christensen", "benjchristensen", "08/14/14, 06:59:28 PM", "It was a bad solution. Use Observable.groupBy with element selector instead\n\nSee https://github.com/Netflix/RxJava/issues/1579", "NaN"], ["1583", "Redo/Repeat Backpressure", "Ben Christensen", "benjchristensen", "08/14/14, 07:57:13 PM", "Fix backpressure and memory leaks\n\nThis now works:\n\n``` java\n    public static void main(String[] args) {\n        Observable<Integer> o1 = Observable.from(1, 1).concatWith(Observable.just(-1).repeat());\n        Observable<Integer> o2 = Observable.from(2, 2, 2, 2);\n        Observable.zip(o1, o2, (a, b) -> a + b).forEach(System.out::println);\n    }\n```", "NaN"], ["1584", "Add ViewActions utilities for Android", "Ron Shapiro", "ronshapiro", "08/19/14, 03:52:30 AM", "NaN", "NaN"], ["1586", "RxScala: Observable.items(T*) -> Observable.just(T*)", "Joakim Bodin", "jbripley", "08/14/14, 11:00:47 PM", "NaN", "NaN"], ["1587", "RxScala: Switch mapped RxJava methods to non-deprecated versions", "Joakim Bodin", "jbripley", "08/14/14, 11:00:29 PM", "- Mark onErrorFlatMap/from(Iterable, Scheduler) as deprecated, since the RxJava versions will go away", "NaN"], ["1588", "Added doOnUnsubscribed() to Observable", "Danny Yuan", "g9yuayon", "08/15/14, 01:19:47 AM", "We often need to be notified when an Observable is unsubscribed, for cleaning up internal states, logging, metrics gathering, and etc. With this added method, users can save the effort of writing the similar boilerplate to register a listener for un-subscription events.  ", "NaN"], ["1589", "Added doOnSubscribe() to Observable", "Danny Yuan", "g9yuayon", "08/15/14, 04:26:42 PM", "We often need to be notified when an Observable is unsubscribed, for cleaning up internal states, logging, metrics gathering, and etc. With this added method, users can save the effort of writing the similar boilerplate to register a listener for un-subscription events.", "NaN"], ["1592", "Decouple Dispose Function for Using", "Ben Christensen", "benjchristensen", "08/19/14, 03:26:21 AM", "As per discussion at https://github.com/Netflix/RxJava/issues/1466", "NaN"], ["1593", "doOnSubscribe", "Ben Christensen", "benjchristensen", "08/15/14, 07:24:47 PM", "NaN", "NaN"], ["1597", "reactivex.io: RxScala getting started examples", "Georgi Khomeriki", "flatmap13", "08/18/14, 04:07:57 PM", "This PR adds a new examples folder called `reactivex` to RxScala. The idea is to embed these examples directly from the repo in the reactivex.io website.\n\nContains (runnable) Scala versions of the examples used in [how to use](https://github.com/Netflix/RxJava/wiki/How-To-Use-RxJava). ", "NaN"], ["1598", "RxScala: Add mapping to RxJava doOnUnsubscribe", "Joakim Bodin", "jbripley", "08/18/14, 04:06:27 PM", "NaN", "NaN"], ["1599", "reuse existing methods", "Dave Moten", "davidmoten", "08/18/14, 04:07:01 PM", "This is a little cleanup of methods in Observable.java that could be reusing existing methods.", "NaN"], ["1600", "RxScala: JavaDoc fixes to not use code or link", "Joakim Bodin", "jbripley", "08/18/14, 04:06:13 PM", "NaN", "NaN"], ["1601", "RxScala: Change \"multicast\" to be consistent with RxJava", "Shixiong Zhu", "zsxwing", "08/18/14, 05:17:10 PM", "Since RxJava adds `ConnectableObservable<R> multicast(Func0<? extends Subject<? super T, ? extends R>> subjectFactory)`,  we can change `def multicast[R >: T](subject: rx.lang.scala.Subject[R])` to `def multicast[R >: T](subject: => rx.lang.scala.Subject[R])` in RxScala.\n\n/cc @headinthebox, @samuelgruetter\n/cc @benjchristensen considering this is a breaking change, please merge it before releasing 0.20 if possible.", "NaN"], ["1602", "Make retryWhen the same with the Scheduler as the retryWhen without the Scheduler", "George Campbell", "abersnaze", "08/18/14, 04:04:31 PM", "came up in #1580", "NaN"], ["1605", "RxScala: Update signatures of retryWhen/repeatWhen to match RxJava", "Joakim Bodin", "jbripley", "08/18/14, 04:33:54 PM", "NaN", "NaN"], ["1606", "Added a merge instance method", "Aubrey Tull", "stealthcode", "08/19/14, 03:52:30 AM", "The use of this operator presumes that the developer knows that the type of the input Observable is an `Observable<Observable<T>>` (similar to `Observable<T>.dematerialize()`).", "NaN"], ["1608", "Add missing window with time overload", "Dave Moten", "davidmoten", "08/19/14, 03:08:24 AM", "`Observable.window` is missing an overload, the one overload to rule them all (couldn't resist). \n\nThe missing overload is below and corresponds to the ability to customize every parameter associated with the window with time functionality.\n\n`public final Observable<Observable<T>> window(long timespan, long timeshift, TimeUnit unit, int count, Scheduler scheduler)`", "NaN"], ["1609", "RxScala: Add backpressure support", "Shixiong Zhu", "zsxwing", "08/19/14, 03:14:20 AM", "As per #1603.\n\n/cc @headinthebox, @samuelgruetter", "NaN"], ["1610", "Deprecate Multicast without Factory", "Ben Christensen", "benjchristensen", "08/19/14, 03:31:00 AM", "This method is nuanced and generally causes broken behavior if the Observable is subscribed to more than once.", "NaN"], ["1611", "Deprecate Superfluous Methods with Scheduler Overload", "Ben Christensen", "benjchristensen", "08/19/14, 03:30:51 AM", "These should just use subscribeOn if scheduling is wanted.\n\nAs per https://github.com/Netflix/RxJava/issues/1580", "NaN"], ["1790", "Time marker is reset when schedule is immediate.", "Yannick Lecaillez", "ylecaillez", "11/29/14, 04:39:24 AM", "NaN", "NaN"], ["3561", "Corrected buffer operator onError behaviour documentation", "Mariusz \u0141uci\u00f3w", "mariuszluciow", "12/08/15, 08:59:02 AM", "#3560", "NaN"], ["3573", "Test PR", "Deleted user", "ghost", "12/15/15, 01:38:43 AM", "NaN", "NaN"], ["3944", "fix exception message from observer to subscriber", "Yunpeng Li", "loveyoupeng", "05/17/16, 10:06:02 PM", "NaN", "NaN"]]
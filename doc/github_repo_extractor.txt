Author: Jacob McAuley Penney <jacobmpenney@gmail.com>


Contents
    Introduction
    Configuration




==============================================================================
Configuration

FILE
The extractor is configured via a JSON object kept inside of a file. Neither
the name of the file nor its extension are considered by the program.

VALUES
The allowed configuration values are defined in the CFG_SCHEMA dictionary in
the Extractor class of extractor.py. The schema descends from Cerberus
(https://docs.python-cerberus.org/en/stable/index.html). The attributes are
orderless but their names must conform to the names given in the schema or
Cerberus will raise an error that will be presented to the user.

Below is a list of the accepted attributes and their accepted values.

    "repo": str; the owner of the repo and repo name, e.g. "JabRef/jabref"


    "auth_file": str; The path to the file containing a valid GitHub
                 personal access token


    "output_dir": str; The path to the directory where output will be stored,
                  e.g. /home/extractor/output. Note that this is not a file.

        - Note: may change in the near future. As of right now, the Writer
          class creates the output files for us, using the name of the
          repo and the output dir, e.g.
          /home/extractor/output/jabref/commit_output.json


    "range": list[int]; a list of two integers with a minimum of [0,0].
             Defines the indices in the various paginated lists of items
             which we would like to extract data from.

        - Note: may change from looking at indices to actual PR/issue numbers


    "commit_fields", "issues_fields", "pr_fields": list[str];

        These fields determine what data to ask the API for. Because
        PR (for commits and PRs) and issue numbers are included as the
        defining attribute for each row, these values need not be asked for
        but are currently included in the list of values that can be asked
        for. See
        https://pygithub.readthedocs.io/en/latest/github.html?highlight=main
        for more information on the return values discussed below.

        For commits, the available API calls are:
            "author_name": str; Commit.commit.author.name
            "committer": str; Commit.committer
            "date": str; Commit.commit.author.date.strftime (formatted to str)
            "files": Commit.file.{
                .filename, list[str];
                .additions, int;
                .changes, int;
                .patch, str;
                .deletions, int;
                .status, str;
            }
            "message": str; Commit.commit.message
            "sha": str; Commit.sha

        Note: "files" is a special case. It produces a dictionary of outputs
        itself, meaning that it is nested inside of the dict of vals for each
        attribute (issue/PR number). To update the value for the files
        attribute, then, we must recursively merge any additions to the JSON
        object. One entry inside of a JSON object for a commit with a "files"
        output will look like:

        {
            "1":{
                "author_name": "Jon Skeet",
                "files":{
                    "filenames": ["Foo", "Bar", "Baz"]
                    ...
                }
            }
        }


        For issues, the available API calls are:
            "body":
            "closed":
            "comments":
            "num":
            "title":
            "userlogin":
            "username":


        For PRs, the available API calls are:
            "body":
            "closed":
            "num":
            "merged":
            "title":
            "userlogin":
            "username":



DISPATCH TABLES
The expression below does several things:
1. the curly brackets indicate that this is a dictionary
comprehension, so it creates a dict from the iterating expression
inside

2. cmd_dict[field](cur_pr) uses the current "field" item in the
field list, which the dict comprehension loops through, as the key
to the cmd_dict, meaning that it grabs the val from the cmd_dict
at that key. That val will be a function. It then sends cur_pr as
a parameter to that function and stores the result.

3. field: cmd_dict[field](cur_pr) creates a key value pair, where
the field, e.g. "num", is the key and the output found in point #2
above is the key

In sum, this takes the current PR and gets every field of
information from the configuration file about this PR. For
example, If the user asks for "num" and "author_name" in the
"PR fields" field of the # config, this expression creates a dict
containing those values for every PR. This same concept is used
in the issues and commits getters

cur_item_pr_data = {
    field: pr_dict[field](self, cur_pr) for field in pr_fields
}
